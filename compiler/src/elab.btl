include "bittle.btls";

//==============================================================================
//== Scope

struct ScopeEntry {
    name: *Char,
    sym_index: Int,
}

struct Scope {
    entries: *List, // List<ScopeEntry>
    parent: *Scope,
}

func scope_new(parent: *Scope): *Scope {
    var scope: *Scope = calloc(1, sizeof(Scope));
    *scope = Scope { entries: list_new(), parent: parent };
    return scope;
}

func scope_drop(scope: *Scope) {
    free(scope.entries);
    free(scope);
}

func scope_lookup(scope: *Scope, name: *Char, max_depth: Int): Int {
    if (scope == null || max_depth == 0) {
        return -1;
    }
    for (var i = list_len(scope.entries) - 1; i >= 0; i -= 1) {
        var entry: *ScopeEntry = list_get(scope.entries, i);
        if (str_eq(entry.name, name)) {
            return entry.sym_index;
        }
    }
    return scope_lookup(scope.parent, name, max_depth - 1);
}

//==============================================================================
//== Context

struct ElabCtx {
    syms: *List, // List<Sym>
    scope: *Scope,
    current_func: *FuncSym,
    loop_depth: Int,
}

func enter_scope(ctx: *ElabCtx) {
    ctx.scope = scope_new(ctx.scope);
}

func exit_scope(ctx: *ElabCtx) {
    var scope = ctx.scope;
    ctx.scope = scope.parent;
    scope_drop(scope);
}

//==============================================================================
//== Symbol declaration & lookup

func lookup(ctx: *ElabCtx, name: *Char): *Sym {
    var sym_index = scope_lookup(ctx.scope, name, -1);
    if (sym_index == -1) {
        return null;
    }
    return list_get(ctx.syms, sym_index);
}

func try_get_existing(ctx: *ElabCtx, name: *Char): *Sym {
    var sym_index = scope_lookup(ctx.scope, name, 1);
    if (sym_index == -1) {
        return null;
    }
    return list_get(ctx.syms, sym_index);
}

func add_sym(ctx: *ElabCtx, sym: *Sym) {
    var entry: *ScopeEntry = calloc(1, sizeof(ScopeEntry));
    *entry = ScopeEntry { name: sym.name, sym_index: list_len(ctx.syms) };
    list_push(ctx.syms, sym);
    list_push(ctx.scope.entries, entry);
}

func define_enum(ctx: *ElabCtx, pos: *Pos, name: *Char): *EnumSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        die_at(pos, "Symbol is already defined");
    }

    var sym = calloc(1, sizeof(EnumSym)) as *EnumSym;
    *sym = EnumSym { kind: Sym_Enum, name, size: 4 };
    add_sym(ctx, sym);
    return sym;
}

func declare_record(
    ctx: *ElabCtx,
    pos: *Pos,
    is_union: Bool,
    name: *Char,
    is_definition: Bool
): *RecordSym {
    var sym = try_get_existing(ctx, name);
    if (sym) {
        if (sym.kind != Sym_Record) {
            die_at(pos, "redeclared as different kind of symbol");
        }
        if (sym_is_defined(sym) && is_definition) {
            die_at(pos, "redefinition of existing symbol");
        }
    } else {
        sym = calloc(1, sizeof(RecordSym)) as *RecordSym;
        *(sym as *RecordSym) = RecordSym {
            kind: Sym_Record,
            is_union,
            name,
            base: null,
            fields: null,
            unpadded_size: 0,
            align: 0,
            is_defined: false,
        };
        add_sym(ctx, sym);
    }
    return sym as *RecordSym;
}

func params_eq(xs: *List, ys: *List): Bool {
    if (list_len(xs) != list_len(ys)) {
        return false;
    }
    for (var i = 0; i < list_len(xs); i += 1) {
        var param1: *FuncParam = list_get(xs, i);
        var param2: *FuncParam = list_get(ys, i);
        if (!type_eq(param1.type, param2.type)) {
            return false;
        }
    }
    return true;
}

func declare_func(
    ctx: *ElabCtx,
    pos: *Pos,
    name: *Char,
    params: *List,
    rest_param: *RestParamDecl,
    return_type: *Type,
    is_definition: Bool
): *FuncSym {
    var is_variadic = rest_param != null;

    var sym = try_get_existing(ctx, name);
    if (sym) {
        if (sym.kind != Sym_Func) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        var sym = sym as *FuncSym;
        if (!params_eq(sym.params, params)) {
            die_at(pos, "Symbol redeclared with different parameters");
        }
        if (!type_eq(sym.return_type, return_type)) {
            die_at(pos, "Symbol redeclared with different return type");
        }
        if (sym.is_variadic != is_variadic) {
            die_at(pos, "Symbol redeclared with different variadicity");
        }
        if (sym_is_defined(sym) && is_definition) {
            die_at(pos, "Symbol is already defined");
        }
    } else {
        sym = calloc(1, sizeof(FuncSym)) as *FuncSym;
        *(sym as *FuncSym) = FuncSym {
            kind: Sym_Func,
            name,
            params: params,
            return_type: return_type,
            is_variadic: is_variadic,
            rest_param_name: rest_param ? rest_param.name : null,
            is_defined: is_definition,
            locals: list_new(),
            temps: list_new(),
            body: null
        };
        add_sym(ctx, sym);
    }
    return sym as *FuncSym;
}

func define_const(ctx: *ElabCtx, pos: *Pos, name: *Char, value: *ConstValue) {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        die_at(pos, "Symbol is already defined");
    }

    var sym = calloc(1, sizeof(ConstSym)) as *ConstSym;
    *sym = ConstSym { kind: Sym_Const, name, value };
    add_sym(ctx, sym);
}

func declare_global(ctx: *ElabCtx, pos: *Pos, name: *Char, type: *Type, is_definition: Bool): *GlobalSym {
    var sym = try_get_existing(ctx, name);
    if (sym) {
        if (sym.kind != Sym_Global) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        if (!type_eq((sym as *GlobalSym).type, type)) {
            die_at(pos, "Symbol redeclared with different type");
        }
        if (sym_is_defined(sym) && is_definition) {
            die_at(pos, "Symbol is already defined");
        }
    } else {
        sym = calloc(1, sizeof(GlobalSym)) as *GlobalSym;
        *(sym as *GlobalSym) = GlobalSym { kind: Sym_Global, name, type, is_defined: false };
        add_sym(ctx, sym);
    }
    return sym as *GlobalSym;
}

func define_local(ctx: *ElabCtx, pos: *Pos, name: *Char, type: *Type): *LocalSym {
    var existing = try_get_existing(ctx, name);
    var is_conflicting_redefinition = existing && existing.kind != Sym_Local;
    if (is_conflicting_redefinition) {
        die_at(pos, "Symbol is already defined");
    }

    var slot_id = list_len(ctx.current_func.locals);

    var sym = calloc(1, sizeof(LocalSym)) as *LocalSym;
    *sym = LocalSym { kind: Sym_Local, name, type, slot_id, is_indirect: false };
    add_sym(ctx, sym);

    list_push(ctx.current_func.locals, sym);

    return sym;
}

func define_params(ctx: *ElabCtx, param_decls: *List, params: *List) {
    for (var i = 0; i < list_len(params); i += 1) {
        var param_decl: *FuncParamDecl = list_get(param_decls, i);
        var param: *FuncParam = list_get(params, i);
        define_local(ctx, &param_decl.pos, param.name, param.type);
    }
}

//==============================================================================
//== Type checking

func try_coerce_with_cast(e: *Expr, target: *Type, out: **Expr): Bool {
    if (!type_implicitly_convertible(e.type, target)) {
        return false;
    }
    var cast: *CastExpr = calloc(1, sizeof(CastExpr));
    var const_value: *ConstValue = null;
    if (e.const_value) {
        const_value = const_value_cast(e.const_value, target);
    }
    *cast = CastExpr {
        kind: Expr_Cast,
        pos: e.pos,
        type: target,
        const_value,
        expr: e,
        type_expr: null
    };
    *out = cast;
    return true;
}

/*
    Desugar
        x: MyUnion = 123
    to
        x: MyUnion = MyUnion { field: 123 }
*/
func try_coerce_to_union(e: *Expr, target: *Type, out: **Expr): Bool {
    if (target.kind != Type_Record) {
        return false;
    }

    var target = target as *RecordType;
    if (!target.sym.is_union) {
        return false;
    }

    var sym = target.sym;

    var field_index = find_record_field_by_type(sym, e.type);
    if (field_index == -1) {
        return false;
    }

    var field: *RecordField = list_get(sym.fields, field_index);

    var field_init: *FieldInitializer = calloc(1, sizeof(FieldInitializer));
    *field_init = FieldInitializer {
        pos: e.pos,
        name: field.name,
        expr: e
    };

    var field_inits: *List = list_new();
    list_push(field_inits, field_init);

    var record_expr: *RecordExpr = calloc(1, sizeof(RecordExpr));
    *record_expr = RecordExpr {
        kind: Expr_Record,
        pos: e.pos,
        type: target,
        const_value: null,
        name: sym.name,
        fields: field_inits,
    };
    *out = record_expr;

    return true;
}

func try_coerce(e: *Expr, target: *Type, out: **Expr): Bool {
    return type_eq(e.type, target)
        || try_coerce_with_cast(e, target, out)
        || try_coerce_to_union(e, target, out);
}

func try_coerce_to_int(e: *Expr, out: **Expr): Bool {
    for (var size = 1; size <= 8; size *= 2) {
        if (try_coerce_with_cast(e, mk_int_type(size), out)) {
            return true;
        }
    }
    return false;
}

func check_type(e: **Expr, expected: *Type) {
    try_coerce((*e), expected, e);
    if (expected.kind == Type_Ptr && (expected as *PtrType).pointee.kind == Type_Void && (*e).type.kind == Type_Ptr) {
        return;
    }
    if (!type_eq((*e).type, expected)) {
        die_at(&(*e).pos, "Type mismatch: %s != %s.\n", pretty_type(expected), pretty_type((*e).type));
    }
}

func check_type_int(e: **Expr) {
    if (!try_coerce_to_int(*e, e)) {
        die_at(&(*e).pos, "Integer expression expected");
    }
}

func check_type_bool(e: **Expr) {
    check_type(e, mk_bool_type());
}

func unify_types(e1: **Expr, e2: **Expr) {
    try_coerce(*e2, (*e1).type, e2);
    try_coerce(*e1, (*e2).type, e1);
    check_type(e2, (*e1).type);
}

//==============================================================================
//== Types

func const_eval_int64(ctx: *ElabCtx, expr: *Expr): Int;

func eval_type(ctx: *ElabCtx, type_expr: *TypeExpr): *Type {
    if (type_expr.kind == TypeExpr_Named) {
        var name: *Char = (type_expr as *NamedTypeExpr).name;
        if (str_eq(name, "Void")) {
            return mk_void_type();
        } else if (str_eq(name, "Bool")) {
            return mk_bool_type();
        } else if (str_eq(name, "Char") || str_eq(name, "Int8")) {
            return mk_int_type(1);
        } else if (str_eq(name, "Int16")) {
            return mk_int_type(2);
        } else if (str_eq(name, "Int32")) {
            return mk_int_type(4);
        } else if (str_eq(name, "Int") || str_eq(name, "Int64")) {
            return mk_int_type(8);
        } else {
            var sym = lookup(ctx, name);
            if (!sym) {
                die_at(&type_expr.pos, "Unknown type");
            }
            if (sym.kind == Sym_Enum) {
                return mk_enum_type(sym as *EnumSym);
            } else if (sym.kind == Sym_Record) {
                return mk_record_type(sym as *RecordSym);
            } else {
                die_at(&type_expr.pos, "Expected a type");
            }
        }
    } else if (type_expr.kind == TypeExpr_Ptr) {
        var pointee = eval_type(ctx, (type_expr as *PtrTypeExpr).pointee);
        return mk_ptr_type(pointee);
    } else if (type_expr.kind == TypeExpr_Arr) {
        var type_expr = type_expr as *ArrTypeExpr;
        var elem = eval_type(ctx, type_expr.elem);
        var size = const_eval_int64(ctx, type_expr.size);
        return mk_array_type(elem, size);
    } else if (type_expr.kind == TypeExpr_Never) {
        return mk_never_type();
    } else if (type_expr.kind == TypeExpr_RestParam) {
        return mk_rest_param_type();
    } else {
        unreachable("eval_type");
    }
}

//==============================================================================
//== Constants

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type);
func elab_expr_expect(ctx: *ElabCtx, expr: **Expr, expected: *Type);

func const_eval_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type): *ConstValue {
    elab_expr_infer(ctx, expr, type_hint);
    if (!expr.const_value) {
        die_at(&expr.pos, "Expected a constant expression");
    }
    return expr.const_value;
}

func const_eval_expect(ctx: *ElabCtx, expr: *Expr, expected: *Type): *ConstValue {
    elab_expr_expect(ctx, &expr, expected);
    if (!expr.const_value) {
        die_at(&expr.pos, "Expected a constant expression");
    }
    return expr.const_value;
}

func const_eval_int64(ctx: *ElabCtx, expr: *Expr): Int {
    return (const_eval_expect(ctx, expr, mk_int_type(8)) as *IntConstValue).int;
}

func const_eval_int32(ctx: *ElabCtx, expr: *Expr): Int32 {
    return (const_eval_expect(ctx, expr, mk_int_type(4)) as *IntConstValue).int as Int32;
}

//==============================================================================
//== Expressions

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type);

func elab_expr_expect(ctx: *ElabCtx, expr: **Expr, expected: *Type) {
    elab_expr_infer(ctx, *expr, type_hint: expected);
    check_type(expr, expected);
}

func elab_expr_bool(ctx: *ElabCtx, expr: **Expr) {
    elab_expr_expect(ctx, expr, mk_bool_type());
}

func elab_expr_int(ctx: *ElabCtx, expr: **Expr, type_hint: *Type) {
    elab_expr_infer(ctx, *expr, type_hint);
    check_type_int(expr);
}

func elab_ident_expr(ctx: *ElabCtx, expr: *IdentExpr) {
    var name = expr.name;

    var sym = lookup(ctx, name);
    if (!sym) {
        die_at(&expr.pos, "Unknown symbol");
    }

    var type: *Type;
    var const_val: *ConstValue = null;
    if (sym.kind == Sym_Local) {
        type = (sym as *LocalSym).type;
    } else if (sym.kind == Sym_Global) {
        type = (sym as *GlobalSym).type;
    } else if (sym.kind == Sym_Const) {
        var sym = sym as *ConstSym;
        type = sym.value.type;
        const_val = sym.value;
    } else {
        die_at(&expr.pos, "Expected a variable or constant");
    }

    expr.sym = sym;
    expr.type = type;
    expr.const_value = const_val;
}

func elab_literal_expr(ctx: *ElabCtx, expr: *LiteralExpr, type_hint: *Type) {
    var literal = expr.literal;

    if (literal.kind == Literal_Null) {
        expr.type = mk_ptr_type(mk_void_type());
    } else if (literal.kind == Literal_Bool) {
        var literal = literal as *BoolLiteral;
        expr.type = mk_bool_type();
        expr.const_value = mk_bool_const_value(literal.value);
    } else if (literal.kind == Literal_Int) {
        var literal = literal as *IntLiteral;
        if (type_hint && type_hint.kind == Type_Int) {
            expr.type = type_hint;
        } else {
            expr.type = mk_int_type(8);
        }
        expr.const_value = mk_int_const_value(literal.value, expr.type);
    } else if (literal.kind == Literal_Char) {
        var literal = literal as *CharLiteral;
        expr.type = mk_int_type(1);
        expr.const_value = mk_int_const_value(literal.value, expr.type);
    } else if (literal.kind == Literal_String) {
        var literal = literal as *StringLiteral;
        expr.type = mk_ptr_type(mk_int_type(1));
        expr.const_value = mk_string_const_value(literal.value);
    } else {
        unreachable("elab_literal_expr");
    }
}

func elab_array_expr(ctx: *ElabCtx, expr: *ArrayExpr, type_hint: *Type) {
    var elem_type_hint: *Type = null;
    if (type_hint && type_hint.kind == Type_Arr) {
        elem_type_hint = (type_hint as *ArrType).elem;
    }

    var elems = expr.elems;

    var elem_type: *Type = null;
    var elem_count = list_len(elems);

    for (var i = 0; i < elem_count; i += 1) {
        var elem: *Expr = list_get(elems, i);
        elab_expr_infer(ctx, elem, elem_type_hint);
        if (i == 0) {
            elem_type = elem.type;
        } else {
            var prev_expr: *Expr = list_get(elems, i - 1);
            check_type(&elem, elem_type);
            list_set(elems, i, elem);
            list_set(elems, i - 1, prev_expr);
        }
    }

    if (!elem_type) {
        die_at(&expr.pos, "Empty array");
    }

    if (!is_sized(elem_type)) {
        die_at(&expr.pos, "Array element type is not sized");
    }

    expr.type = mk_array_type(elem_type, elem_count);
}



func elab_call_expr(ctx: *ElabCtx, expr: *CallExpr) {
    var callee = expr.callee;
    var args = expr.args;

    if (callee.kind != Expr_Ident) {
        die_at(&callee.pos, "Expected function name");
    }
    var sym = lookup(ctx, (callee as *IdentExpr).name);
    if (!sym) {
        die_at(&callee.pos, "Unknown function");
    }
    if (sym.kind != Sym_Func) {
        die_at(&callee.pos, "Expected a function");
    }
    var sym = sym as *FuncSym;

    var param_count = list_len(sym.params);
    var arg_count = list_len(args);

    if (arg_count < param_count) {
        die_at(&expr.pos, "Not enough arguments provided (%d < %d).\n", arg_count, param_count);
    }
    if (!sym.is_variadic && arg_count > param_count) {
        die_at(&expr.pos, "Too many arguments provided (%d > %d).\n", arg_count, param_count);
    }
    var i = 0;
    for (; i < param_count; i += 1) {
        var param: *FuncParam = list_get(sym.params, i);
        var arg: *CallArg = list_get(args, i);
        if (arg.label && !str_eq(arg.label, param.name)) {
            die_at(&arg.expr.pos, "Argument label does not match parameter name");
        }
        elab_expr_expect(ctx, &arg.expr, param.type);
    }
    for (; i < arg_count; i += 1) {
        var arg: *CallArg = list_get(args, i);
        elab_expr_infer(ctx, arg.expr, type_hint: null);
        if (!is_sized(arg.expr.type)) {
            die_at(&expr.pos, "Cannot pass an unsized type as a variadic argument");
        }
    }

    expr.resolved_callee = sym;
    expr.type = sym.return_type;
}

func elab_index_expr(ctx: *ElabCtx, expr: *IndexExpr) {
    var indexee = expr.indexee;
    var index = expr.index;

    elab_expr_infer(ctx, indexee, type_hint: null);
    elab_expr_infer(ctx, index, type_hint: null);

    var indexee_type = indexee.type;
    if (indexee_type.kind != Type_Arr && indexee_type.kind != Type_Ptr) {
        die_at(&indexee.pos, "Expression is not indexable");
    }

    var elem_type = indexee_type.kind == Type_Arr
        ? (indexee_type as *ArrType).elem
        : (indexee_type as *PtrType).pointee;

    check_type_int(&index);
    expr.type = elem_type;
    expr.index = index;
}

func elab_member_expr(ctx: *ElabCtx, expr: *MemberExpr) {
    var left = expr.left;
    var field_name = expr.name;

    elab_expr_infer(ctx, left, type_hint: null);

    var left_type = left.type;
    if (left_type.kind == Type_Ptr) {
        left_type = (left_type as *PtrType).pointee;
    }
    if (left_type.kind != Type_Record) {
        die_at(&left.pos, "Expected a record");
    }
    var left_type = left_type as *RecordType;

    var record_sym = left_type.sym;
    var field_index = find_record_field_by_name(record_sym, field_name);
    if (field_index == -1) {
        die_at(&expr.pos, "Unknown field");
    }

    var field: *RecordField = list_get(record_sym.fields, field_index);
    expr.resolved_field = field_index;
    expr.type = field.type;
}

func elab_sizeof_expr(ctx: *ElabCtx, expr: *SizeofExpr) {
    var type = eval_type(ctx, expr.type_expr);
    var size = type_size(type);
    expr.size = size;
    expr.type = mk_int_type(8);
    expr.const_value = mk_int_const_value(size, expr.type);
}

func elab_unary_expr(ctx: *ElabCtx, expr: *UnaryExpr, type_hint: *Type) {
    var op = expr.op;
    var right = expr.right;

    if (op == Tok_Minus || op == Tok_Tilde) {
        elab_expr_infer(ctx, right, type_hint);
        check_type_int(&right);
        expr.type = right.type;
        expr.right = right;
    } else if (op == Tok_Bang) {
        elab_expr_bool(ctx, &right);
        expr.type = mk_bool_type();
        expr.right = right;
    } else if (op == Tok_Star) {
        var right_type_hint: *Type = mk_ptr_type(type_hint);
        elab_expr_infer(ctx, right, type_hint: right_type_hint);
        var pointee_type = right.type;
        if (pointee_type.kind != Type_Ptr) {
            die_at(&right.pos, "Expected a pointer");
        }
        expr.type = (pointee_type as *PtrType).pointee;
    } else if (op == Tok_Amp) {
        var right_type_hint: *Type = null;
        if (right_type_hint && type_hint.kind == Type_Ptr) {
            right_type_hint = (type_hint as *PtrType).pointee;
        }
        elab_expr_infer(ctx, right, right_type_hint);
        expr.type = mk_ptr_type(right.type);
    } else {
        unreachable("elab_unary_expr");
    }
    if (right.const_value) {
        expr.const_value = const_value_unop(op, right.const_value);
    }
}

func elab_binary_expr(ctx: *ElabCtx, expr: *BinaryExpr, type_hint: *Type) {
    var op = expr.op;
    var left = expr.left;
    var right = expr.right;

    if (op == Tok_Eq || op == Tok_AmpEq || op == Tok_BarEq || op == Tok_CaretEq || op == Tok_LtLtEq || op == Tok_GtGtEq || op == Tok_PlusEq || op == Tok_MinusEq || op == Tok_StarEq || op == Tok_SlashEq || op == Tok_PercentEq) {
        if (!is_lvalue(left)) {
            die_at(&left.pos, "L-value expected");
        }
        elab_expr_infer(ctx, left, type_hint: null);
        if (op != Tok_Eq) {
            if (expr.left.type.kind != Type_Int) {
                die_at(&left.pos, "Left operand is not an integer expression");
            }
        }
        elab_expr_expect(ctx, &right, left.type);
        if (!is_sized(left.type)) {
            die_at(&left.pos, "Cannot assign to an unsized type");
        }
        expr.type = mk_void_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_AmpAmp || op == Tok_BarBar) {
        elab_expr_bool(ctx, &left);
        elab_expr_bool(ctx, &right);
        expr.type = mk_bool_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_EqEq || op == Tok_BangEq || op == Tok_Lt || op == Tok_LtEq || op == Tok_Gt || op == Tok_GtEq) {
        elab_expr_infer(ctx, left, type_hint: null);
        elab_expr_infer(ctx, right, type_hint: left.type);
        unify_types(&left, &right);
        if (!is_scalar(left.type)) {
            die_at(&left.pos, "Operands type is not comparable");
        }
        expr.type = mk_bool_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_Amp || op == Tok_Bar || op == Tok_Caret || op == Tok_LtLt || op == Tok_GtGt || op == Tok_Plus || op == Tok_Minus || op == Tok_Star || op == Tok_Slash || op == Tok_Percent) {
        elab_expr_int(ctx, &left, type_hint);
        elab_expr_int(ctx, &right, left.type);
        unify_types(&left, &right);
        expr.type = left.type;
        expr.left = left;
        expr.right = right;
    } else {
        unreachable("elab_binary_expr");
    }
    if (left.const_value && right.const_value) {
        expr.const_value = const_value_binop(op, left.const_value, right.const_value);
    }
}

func elab_ternary_expr(ctx: *ElabCtx, expr: *TernaryExpr, type_hint: *Type) {
    var cond = expr.cond;
    var then_expr = expr.then_expr;
    var else_expr = expr.else_expr;

    elab_expr_bool(ctx, &cond);
    elab_expr_infer(ctx, then_expr, type_hint: type_hint);
    elab_expr_infer(ctx, else_expr, type_hint: then_expr.type);

    unify_types(&then_expr, &else_expr);
    expr.type = then_expr.type;
    expr.cond = cond;
    expr.then_expr = then_expr;
    expr.else_expr = else_expr;
    if (cond.const_value) {
        expr.const_value = const_value_ternop(cond.const_value, then_expr.const_value, else_expr.const_value);
    }
}

func elab_cast_expr(ctx: *ElabCtx, expr: *CastExpr) {
    var subexpr = expr.expr;
    elab_expr_infer(ctx, subexpr, type_hint: null);

    var source_type = subexpr.type;
    var target_type = eval_type(ctx, expr.type_expr);

    if (!type_convertible(source_type, target_type)) {
        die_at(&expr.pos, "Invalid cast");
    }

    expr.type = target_type;

    if (subexpr.const_value) {
        expr.const_value = const_value_cast(subexpr.const_value, target_type);
    }
}

func elab_record_expr(ctx: *ElabCtx, expr: *RecordExpr, type_hint: *Type) {
    var sym = lookup(ctx, expr.name);
    if (!sym) {
        die_at(&expr.pos, "Unknown record type");
    }
    if (sym.kind != Sym_Record) {
        die_at(&expr.pos, "Expected a record type");
    }
    var sym = sym as *RecordSym;
    if (!sym.is_defined) {
        die_at(&expr.pos, "Record has incomplete type");
    }

    var fields = sym.fields;
    var n_fields = list_len(fields);

    var initializers = expr.fields;
    var n_initializers = list_len(initializers);

    var is_initialized: *Bool = calloc(n_fields, sizeof(*Bool));

    for (var i = 0; i < n_initializers; i += 1) {
        var initializer: *FieldInitializer = list_get(initializers, i);
        var field_name = initializer.name;
        var field_index = find_record_field_by_name(sym, field_name);
        if (field_index == -1) {
            die_at(&initializer.pos, "Unknown field");
        }
        var field: *RecordField = list_get(fields, field_index);

        if (is_initialized[field_index]) {
            die_at(&initializer.pos, "Field is already initialized");
        }
        is_initialized[field_index] = true;
        elab_expr_expect(ctx, &initializer.expr, field.type);
    }

    for (var i = 0; i < n_fields; i += 1) {
        var field: *RecordField = list_get(fields, i);
        is_initialized[i] = is_initialized[i] || field.default_value;
    }

    if (!sym.is_union) {
        for (var i = 0; i < n_fields; i += 1) {
            if (!is_initialized[i]) {
                var field: *RecordField = list_get(fields, i);
                die_at(&expr.pos, "Field '%s' is not initialized.", field.name);
            }
        }
    } else {
        if (n_initializers == 0) {
            die_at(&expr.pos, "No field is initialized.");
        } else if (n_initializers > 1) {
            die_at(&expr.pos, "Only one field can be initialized in a union");
        }
    }

    free(is_initialized);

    expr.type = mk_record_type(sym);
}

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type) {
    if (expr.kind == Expr_Ident) {
        elab_ident_expr(ctx, expr as *IdentExpr);
    } else if (expr.kind == Expr_Literal) {
        elab_literal_expr(ctx, expr as *LiteralExpr, type_hint);
    } else if (expr.kind == Expr_Array) {
        elab_array_expr(ctx, expr as *ArrayExpr, type_hint);
    } else if (expr.kind == Expr_Call) {
        elab_call_expr(ctx, expr as *CallExpr);
    } else if (expr.kind == Expr_Index) {
        elab_index_expr(ctx, expr as *IndexExpr);
    } else if (expr.kind == Expr_Member) {
        elab_member_expr(ctx, expr as *MemberExpr);
    } else if (expr.kind == Expr_Sizeof) {
        elab_sizeof_expr(ctx, expr as *SizeofExpr);
    } else if (expr.kind == Expr_Unary) {
        elab_unary_expr(ctx, expr as *UnaryExpr, type_hint);
    } else if (expr.kind == Expr_Binary) {
        elab_binary_expr(ctx, expr as *BinaryExpr, type_hint);
    } else if (expr.kind == Expr_Ternary) {
        elab_ternary_expr(ctx, expr as *TernaryExpr, type_hint);
    } else if (expr.kind == Expr_Cast) {
        elab_cast_expr(ctx, expr as *CastExpr);
    } else if (expr.kind == Expr_Record) {
        elab_record_expr(ctx, expr as *RecordExpr, type_hint);
    } else {
        unreachable("elab_expr_infer");
    }
    assert(expr.type, "elab_expr_infer");
}

//==============================================================================
//== Statements

func elab_stmt(ctx: *ElabCtx, stmt: *Stmt);

func elab_stmt_with_scope(ctx: *ElabCtx, stmt: *Stmt) {
    enter_scope(ctx);
    elab_stmt(ctx, stmt);
    exit_scope(ctx);
}

func elab_block_stmt(ctx: *ElabCtx, stmt: *BlockStmt) {
    enter_scope(ctx);
    for (var i = 0; i < list_len(stmt.stmts); i += 1) {
        var stmt = list_get(stmt.stmts, i);
        elab_stmt(ctx, stmt);
    }
    exit_scope(ctx);
}

func elab_local_stmt(ctx: *ElabCtx, stmt: *LocalStmt) {
    var name = stmt.name;
    var typeExpr = stmt.type;
    var init = stmt.init;

    var type: *Type = typeExpr ? eval_type(ctx, typeExpr) : null;
    if (init) {
        if (!type) {
            elab_expr_infer(ctx, init, type_hint: null);
            type = init.type;
        } else {
            elab_expr_expect(ctx, &init, type);
            stmt.init = init;
        }
    } else {
        if (!type) {
            die_at(&stmt.pos, "Type required when no initializer is provided");
        }
    }

    if (!is_sized(type)) {
        die_at(&stmt.pos, "Variable must have a size.");
    }

    var sym = define_local(ctx, &stmt.pos, name, type);
    stmt.sym = sym;
}

func elab_if_stmt(ctx: *ElabCtx, stmt: *IfStmt) {
    var cond = stmt.cond;
    var then_stmt = stmt.then_stmt;
    var else_stmt = stmt.else_stmt;

    elab_expr_bool(ctx, &cond);
    stmt.cond = cond;

    elab_stmt_with_scope(ctx, then_stmt);
    if (else_stmt) {
        elab_stmt_with_scope(ctx, else_stmt);
    }
}

func elab_while_stmt(ctx: *ElabCtx, stmt: *WhileStmt) {
    var cond = stmt.cond;
    var body = stmt.body;

    elab_expr_bool(ctx, &cond);
    stmt.cond = cond;

    ctx.loop_depth += 1;
    elab_stmt_with_scope(ctx, body);
    ctx.loop_depth -= 1;
}

func elab_for_stmt(ctx: *ElabCtx, stmt: *ForStmt) {
    var init = stmt.init;
    var cond = stmt.cond;
    var step = stmt.step;
    var body = stmt.body;

    enter_scope(ctx);

    if (init) {
        elab_stmt(ctx, init);
    }
    if (cond) {
        elab_expr_bool(ctx, &cond);
        stmt.cond = cond;
    }
    if (step) {
        elab_expr_infer(ctx, step, type_hint: null);
    }

    ctx.loop_depth += 1;
    elab_stmt_with_scope(ctx, body);
    ctx.loop_depth -= 1;

    exit_scope(ctx);
}

func elab_return_stmt(ctx: *ElabCtx, stmt: *ReturnStmt) {
    var return_expr = stmt.expr;

    var return_type = ctx.current_func.return_type;
    if (return_expr) {
        elab_expr_expect(ctx, &return_expr, return_type);
        stmt.expr = return_expr;
    } else if (return_type.kind != Type_Void) {
        die_at(&stmt.pos, "Missing return value");
    }
}

func elab_break_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (!ctx.loop_depth) {
        die_at(&stmt.pos, "Break statement outside of loop");
    }
}

func elab_continue_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (!ctx.loop_depth) {
        die_at(&stmt.pos, "Continue statement outside of loop");
    }
}

func elab_expr_stmt(ctx: *ElabCtx, stmt: *ExprStmt) {
    var expr = stmt.expr;
    elab_expr_infer(ctx, expr, type_hint: null);
}

func elab_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (stmt.kind == Stmt_Block) {
        elab_block_stmt(ctx, stmt as *BlockStmt);
    } else if (stmt.kind == Stmt_Local) {
        elab_local_stmt(ctx, stmt as *LocalStmt);
    } else if (stmt.kind == Stmt_If) {
        elab_if_stmt(ctx, stmt as *IfStmt);
    } else if (stmt.kind == Stmt_While) {
        elab_while_stmt(ctx, stmt as *WhileStmt);
    } else if (stmt.kind == Stmt_For) {
        elab_for_stmt(ctx, stmt as *ForStmt);
    } else if (stmt.kind == Stmt_Return) {
        elab_return_stmt(ctx, stmt as *ReturnStmt);
    } else if (stmt.kind == Stmt_Break) {
        elab_break_stmt(ctx, stmt);
    } else if (stmt.kind == Stmt_Continue) {
        elab_continue_stmt(ctx, stmt);
    } else if (stmt.kind == Stmt_Expr) {
        elab_expr_stmt(ctx, stmt as *ExprStmt);
    } else {
        unreachable("elab_stmt");
    }
}

//==============================================================================
//== Top-level declarations

func elab_enum_member(ctx: *ElabCtx, member_decl: *EnumMember, type: *Type, next_value: Int32): Int32 {
    var name = member_decl.name;
    var value = next_value;
    if (member_decl.value) {
        value = const_eval_int32(ctx, member_decl.value);
    }

    var const_value = mk_int_const_value(value, type);
    define_const(ctx, &member_decl.pos, name, const_value);
    return value;
}

func elab_enum_decl(ctx: *ElabCtx, decl: *EnumDecl) {
    var type: *Type;
    if (decl.name) {
        var sym = define_enum(ctx, &decl.pos, decl.name);
        type = mk_enum_type(sym);
    } else {
        type = mk_int_type(4);
    }

    var member_decls = decl.members;

    var next_value: Int32 = 0;
    for (var i = 0; i < list_len(member_decls); i += 1) {
        var member_decl: *EnumMember = list_get(member_decls, i);
        var value = elab_enum_member(ctx, member_decl, type, next_value);
        next_value = value + 1;
    }
}

func add_field_to_record(ctx: *ElabCtx, sym: *RecordSym, field_decl: *RecordFieldDecl) {
    var field_name = field_decl.name;
    var field_type = eval_type(ctx, field_decl.type);

    var existing_index = find_record_field_by_name(sym, field_name);
    if (existing_index != -1) {
        die_at(&field_decl.pos, "Duplicate field");
    }

    var default_value: *ConstValue = null;
    if (field_decl.default_value) {
        default_value = const_eval_expect(ctx, field_decl.default_value, field_type);
    }

    var field_size = type_size(field_type);
    var field_align = type_align(field_type);
    var field_offset = sym.is_union
        ? 0
        : align_up(sym.unpadded_size, field_align);

    var field: *RecordField = calloc(1, sizeof(RecordField));
    *field = RecordField {
        name: field_name,
        type: field_type,
        default_value,
        offset: field_offset,
    };

    list_push(sym.fields, field);
    if (sym.is_union) {
        sym.unpadded_size = int_max(sym.unpadded_size, field_size);
    } else {
        sym.unpadded_size = field_offset + field_size;
    }
    sym.align = int_max(sym.align, field_align);
}

func add_default_value_to_field(ctx: *ElabCtx, sym: *RecordSym, field_decl: *RecordFieldDecl) {
    var field_index = find_record_field_by_name(sym, field_decl.name);
    if (field_index == -1) {
        die_at(&field_decl.pos, "No existing field to add default value to");
    }

    var field: *RecordField = list_get(sym.fields, field_index);
    if (field.default_value) {
        die_at(&field_decl.pos, "Field already has a default value");
    }

    field.default_value = const_eval_expect(ctx, field_decl.default_value, field.type);
}

func elab_record_field_decl(ctx: *ElabCtx, field_decl: *RecordFieldDecl, sym: *RecordSym) {
    if (!field_decl.type && field_decl.default_value) {
        add_default_value_to_field(ctx, sym, field_decl);
    } else if (field_decl.type) {
        add_field_to_record(ctx, sym, field_decl);
    } else {
        die_at(&field_decl.pos, "Field type missing");
    }
}

func elab_record_base(ctx: *ElabCtx, base: *TypeExpr, record_sym: *RecordSym) {
    var base_type = eval_type(ctx, base);
    if (base_type.kind != Type_Record) {
        die_at(&base.pos, "Expected a record type");
    }
    var baseSym = (base_type as *RecordType).sym;
    var base_fields = baseSym.fields;
    if (baseSym.is_union != record_sym.is_union && list_len(base_fields) != 1) {
        die_at(&base.pos, "Base type must be the same kind of record or have exactly one field");
    }
    if (baseSym == record_sym) {
        die_at(&base.pos, "Record cannot inherit from itself");
    }
    if (!baseSym.is_defined) {
        die_at(&base.pos, "Base has incomplete type");
    }
    var fields = list_new_with_cap(list_len(base_fields));
    for (var i = 0; i < list_len(base_fields); i += 1) {
        var field: *RecordField = list_get(base_fields, i);
        var copy: *RecordField = calloc(1, sizeof(RecordField));
        *copy = *field;
        list_push(fields, copy);
    }

    *record_sym = RecordSym {
        kind: Sym_Record,
        is_union: record_sym.is_union,
        name: record_sym.name,
        base: baseSym,
        fields: fields,
        unpadded_size: baseSym.unpadded_size,
        align: baseSym.align,
        is_defined: false,
    };
}

func elab_record_decl(ctx: *ElabCtx, decl: *RecordDecl) {
    var name = decl.name;
    var base = decl.base;
    var field_decls = decl.fields;

    var is_definition = field_decls != null;

    var sym = declare_record(ctx, &decl.pos, decl.is_union, name, is_definition);

    if (base) {
        elab_record_base(ctx, base, sym);
    }

    if (field_decls) {
        if (!sym.fields) {
            sym.fields = list_new();
        }
        var fields = sym.fields;

        for (var i = 0; i < list_len(field_decls); i += 1) {
            var field_decl: *RecordFieldDecl = list_get(field_decls, i);
            elab_record_field_decl(ctx, field_decl, sym);
        }

        if (list_len(fields) == 0) {
            die_at(&decl.pos, "Empty record");
        }
    }

    if (sym.fields) {
        sym.is_defined = true;
    }
}

func string_list_contains(list: *List, value: *Char): Bool {
    for (var i = 0; i < list_len(list); i += 1) {
        var item: *Char = list_get(list, i);
        if (str_eq(item, value)) {
            return true;
        }
    }
    return false;
}

func ensure_unique_params(ctx: *ElabCtx, params_decls: *List) {
    var seen = list_new();
    for (var i = 0; i < list_len(params_decls); i += 1) {
        var param_decl: *FuncParamDecl = list_get(params_decls, i);
        var name = param_decl.name;
        if (string_list_contains(seen, name)) {
            die_at(&param_decl.pos, "Duplicate parameter name");
        }
        list_push(seen, name);
    }
}

func elab_param(ctx: *ElabCtx, param_decl: *FuncParamDecl): *FuncParam {
    var name = param_decl.name;
    var type = eval_type(ctx, param_decl.type);

    if (!is_sized(type)) {
        die_at(&param_decl.pos, "Parameter has unsized type");
    }

    var result: *FuncParam = calloc(1, sizeof(FuncParam));
    *result = FuncParam { name, type };
    return result;
}

func verify_main_signature(decl: *FuncDecl, sym: *FuncSym) {
    var param_decls = decl.params;
    var params = sym.params;
    var n_params = list_len(param_decls);
    var is_variadic = sym.is_variadic;
    var return_type = sym.return_type;

    if (!type_eq(return_type, mk_int_type(4))) {
        die_at(&decl.pos, "Return type of 'main' must be 'Int32'");
    }

    for (var i = 0; i < n_params; i += 1) {
        var param_decl: *FuncParamDecl = list_get(param_decls, i);
        var param: *FuncParam = list_get(params, i);
        if (i == 0) {
            if (!type_eq(param.type, mk_int_type(4))) {
                die_at(&param_decl.pos, "The arg count parameter of 'main' must have type 'Int32'");
            }
        } else if (i == 1) {
            if (!type_eq(param.type, mk_ptr_type(mk_ptr_type(mk_int_type(1))))) {
                die_at(&param_decl.pos, "The arg vector parameter of 'main' must have type '**Char'");
            }
        } else {
            die_at(&param_decl.pos, "The 'main' function can only have parameters 'argc: Int32' and 'argv: **Char'");
        }
    }

    if (is_variadic) {
        die_at(&decl.pos, "The 'main' function cannot be variadic");
    }
}

func elab_func_decl(ctx: *ElabCtx, decl: *FuncDecl) {
    var name = decl.name;

    var param_decls = decl.params;

    var n_params = list_len(param_decls);
    var params = list_new();
    for (var i = 0; i < n_params; i += 1) {
        var param_decl = list_get(param_decls, i);
        var param = elab_param(ctx, param_decl);
        list_push(params, param);
    }

    var return_type = decl.return_type
        ? eval_type(ctx, decl.return_type)
        : mk_void_type();

    if (return_type.kind != Type_Void && return_type.kind != Type_Never && !is_sized(return_type)) {
        die_at(&decl.pos, "Function return type must have known size");
    }

    var is_definition = decl.body != null;
    var is_variadic = decl.rest_param != null;

    var sym = declare_func(ctx, &decl.pos, name, params, decl.rest_param, return_type, is_definition);

    if (str_eq(name, "main")) {
       verify_main_signature(decl, sym);
    }

    if (decl.body) {
        enter_scope(ctx);
        ctx.current_func = sym;

        define_params(ctx, param_decls, params);

        if (decl.rest_param) {
            define_local(ctx, &decl.rest_param.pos, decl.rest_param.name, mk_rest_param_type());
        }

        elab_stmt(ctx, decl.body);

        ctx.current_func = null;
        exit_scope(ctx);

        sym.body = decl.body;
        sym.is_defined = true;
    } else {
        ensure_unique_params(ctx, param_decls);
    }
}

func elab_const_decl(ctx: *ElabCtx, decl: *ConstDecl) {
    var name = decl.name;
    var value_expr = decl.value;
    var type: *Type = null;
    if (decl.type) {
        type = eval_type(ctx, decl.type);
        if (!is_scalar(type)) {
            die_at(&decl.type.pos, "Constant must have a scalar type");
        }
    }
    var value: *ConstValue;
    if (type) {
        value = const_eval_expect(ctx, value_expr, type);
    } else {
        value = const_eval_infer(ctx, value_expr, type_hint: null);
    }
    define_const(ctx, &decl.pos, name, value);
}

func elab_global_decl(ctx: *ElabCtx, decl: *GlobalDecl) {
    var is_extern = decl.is_extern;
    var name = decl.name;
    var type = eval_type(ctx, decl.type);

    var sym = declare_global(ctx, &decl.pos, name, type, !is_extern);
    sym.is_defined = !is_extern;
}

func elab_decl(ctx: *ElabCtx, decl: *Decl) {
    if (decl.kind == Decl_Record) {
        elab_record_decl(ctx, decl as *RecordDecl);
    } else if (decl.kind == Decl_Func) {
        elab_func_decl(ctx, decl as *FuncDecl);
    } else if (decl.kind == Decl_Enum) {
        elab_enum_decl(ctx, decl as *EnumDecl);
    } else if (decl.kind == Decl_Const) {
        elab_const_decl(ctx, decl as *ConstDecl);
    } else if (decl.kind == Decl_Global) {
        elab_global_decl(ctx, decl as *GlobalDecl);
    } else {
        unreachable("elab_decl");
    }
}

func elab(ast: *Ast): *List { // *List<*Sym>
    var ctx: *ElabCtx = calloc(1, sizeof(ElabCtx));
    *ctx = ElabCtx {
        syms: list_new(),
        scope: scope_new(null),
        current_func: null,
        loop_depth: 0,
    };

    for (var i = 0; i < list_len(ast.decls); i += 1) {
        var decl = list_get(ast.decls, i);
        elab_decl(ctx, decl);
    }

    return ctx.syms;
}
