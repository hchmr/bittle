include "bittle.btls";

//==============================================================================
//== Scope

struct ScopeEntry {
    name: *Char,
    sym_index: Int,
}

struct Scope {
    entries: *List, // List<ScopeEntry>
    parent: *Scope,
}

func scope_new(parent: *Scope): *Scope {
    var scope: *Scope = calloc(1, sizeof(Scope));
    *scope = Scope { entries: list_new(), parent: parent };
    return scope;
}

func scope_drop(scope: *Scope) {
    free(scope.entries);
    free(scope);
}

func scope_lookup(scope: *Scope, name: *Char, max_depth: Int): Int {
    if (scope == null || max_depth == 0) {
        return -1;
    }
    for (var i = list_len(scope.entries) - 1; i >= 0; i -= 1) {
        var entry: *ScopeEntry = list_get(scope.entries, i);
        if (str_eq(entry.name, name)) {
            return entry.sym_index;
        }
    }
    return scope_lookup(scope.parent, name, max_depth - 1);
}

//==============================================================================
//== Context

struct ElabCtx {
    syms: *List, // List<Sym>
    scope: *Scope,
    current_func: *FuncSym,
    loop_depth: Int,
    or_pattern_depth: Int,
}

func enter_scope(ctx: *ElabCtx) {
    ctx.scope = scope_new(ctx.scope);
}

func exit_scope(ctx: *ElabCtx) {
    var scope = ctx.scope;
    ctx.scope = scope.parent;
    scope_drop(scope);
}

//==============================================================================
//== Symbol declaration & lookup

func lookup(ctx: *ElabCtx, name: *Char): *Sym {
    var sym_index = scope_lookup(ctx.scope, name, -1);
    if (sym_index == -1) {
        return null;
    }
    return list_get(ctx.syms, sym_index);
}

func try_get_existing(ctx: *ElabCtx, name: *Char): *Sym {
    var sym_index = scope_lookup(ctx.scope, name, 1);
    if (sym_index == -1) {
        return null;
    }
    return list_get(ctx.syms, sym_index);
}

func add_sym(ctx: *ElabCtx, sym: *Sym) {
    var entry: *ScopeEntry = calloc(1, sizeof(ScopeEntry));
    *entry = ScopeEntry { name: sym.name, sym_index: list_len(ctx.syms) };
    list_push(ctx.syms, sym);
    list_push(ctx.scope.entries, entry);
}

func declare_enum(ctx: *ElabCtx, pos: *Pos, name: *Char): *EnumSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Enum) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        return existing as *EnumSym;
    }

    var sym: *EnumSym = calloc(1, sizeof(EnumSym));
    *sym = EnumSym {
        kind: Sym_Enum,
        name,
        is_defined: false,
        size: -1,
    };
    add_sym(ctx, sym);
    return sym;
}

func define_enum(ctx: *ElabCtx, pos: *Pos, sym: *EnumSym, size: Int) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }
    sym.size = size;
    sym.is_defined = true;
}

func declare_record(
    ctx: *ElabCtx,
    pos: *Pos,
    is_union: Bool,
    name: *Char,
): *RecordSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Record) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        return existing as *RecordSym;
    }

    var sym: *RecordSym = calloc(1, sizeof(RecordSym));
    *sym = RecordSym {
        kind: Sym_Record,
        name,
        is_defined: false,
        is_union,
        base: null,
        fields: null,
        unpadded_size: 0,
        align: 0,
    };
    add_sym(ctx, sym);
    return sym;
}

func define_record(ctx: *ElabCtx, pos: *Pos, sym: *RecordSym) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }

    sym.is_defined = true;
}

func declare_const(ctx: *ElabCtx, pos: *Pos, name: *Char): *ConstSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Const) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        return existing as *ConstSym;
    }

    var sym = calloc(1, sizeof(ConstSym)) as *ConstSym;
    *sym = ConstSym {
        kind: Sym_Const,
        is_defined: false,
        name,
        value: null,
    };
    add_sym(ctx, sym);
    return sym;
}

func define_const(ctx: *ElabCtx, pos: *Pos, sym: *ConstSym, value: *ConstValue) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }
    sym.is_defined = true;
    sym.value = value;
}

func params_eq(xs: *List, ys: *List): Bool {
    if (list_len(xs) != list_len(ys)) {
        return false;
    }
    for (var i = 0; i < list_len(xs); i += 1) {
        var param1: *FuncParam = list_get(xs, i);
        var param2: *FuncParam = list_get(ys, i);
        if (!str_eq(param1.name, param2.name)) {
            return false;
        }
        if (!type_eq(param1.type, param2.type)) {
            return false;
        }
    }
    return true;
}

func declare_func(
    ctx: *ElabCtx,
    pos: *Pos,
    name: *Char,
    params: *List,
    rest_param: *RestParamDecl,
    return_type: *Type
): *FuncSym {
    var is_variadic = !!rest_param;

    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Func) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        var existing = existing as *FuncSym;
        if (!params_eq(existing.params, params)) {
            die_at(pos, "Symbol redeclared with different parameters");
        }
        if (is_variadic != existing.is_variadic) {
            die_at(pos, "Symbol redeclared with different variadicity");
        }
        if (
            is_variadic
            && !(
                !rest_param.name && !existing.rest_param_name
                || rest_param.name && existing.rest_param_name && str_eq(rest_param.name, existing.rest_param_name)
            )
        ) {
            die_at(pos, "Symbol redeclared with different rest parameter");
        }
        if (!type_eq(existing.return_type, return_type)) {
            die_at(pos, "Symbol redeclared with different return type");
        }
        return existing;
    }

    var sym: *FuncSym = calloc(1, sizeof(FuncSym));
    *sym = FuncSym {
        kind: Sym_Func,
        name,
        is_defined: false,
        params,
        return_type,
        is_variadic,
        rest_param_name: rest_param ? rest_param.name : null,
        locals: list_new(),
        temps: list_new(),
        body: null
    };
    add_sym(ctx, sym);
    return sym;
}

func define_func(ctx: *ElabCtx, pos: *Pos, sym: *FuncSym, body: *Stmt) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }
    sym.is_defined = true;
    sym.body = body;
}

func declare_global(ctx: *ElabCtx, pos: *Pos, name: *Char, type: *Type): *GlobalSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Global) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        var existing = existing as *GlobalSym;
        if (!type_eq(existing.type, type)) {
            die_at(pos, "Symbol redeclared with different type");
        }
        return existing;
    }

    var sym = calloc(1, sizeof(GlobalSym)) as *GlobalSym;
    *sym = GlobalSym {
        kind: Sym_Global,
        name,
        type,
        is_defined: false,
    };
    add_sym(ctx, sym);
    return sym;
}

func define_global(ctx: *ElabCtx, pos: *Pos, sym: *GlobalSym) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }
    sym.is_defined = true;
}

func define_local(ctx: *ElabCtx, pos: *Pos, name: *Char, type: *Type): *LocalSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Local) {
            die_at(pos, "Another symbol with the same name already exists");
        } else {
            // Shadowing an existing local variable is allowed
        }
    }

    var slot_id = list_len(ctx.current_func.locals);

    var sym = calloc(1, sizeof(LocalSym)) as *LocalSym;
    *sym = LocalSym {
        kind: Sym_Local,
        name,
        is_defined: true,
        type,
        slot_id,
        is_indirect: false,
    };
    add_sym(ctx, sym);
    list_push(ctx.current_func.locals, sym);

    return sym;
}

func define_params(ctx: *ElabCtx, param_decls: *List, params: *List) {
    for (var i = 0; i < list_len(params); i += 1) {
        var param_decl: *FuncParamDecl = list_get(param_decls, i);
        var param: *FuncParam = list_get(params, i);
        define_local(ctx, &param_decl.pos, param.name, param.type);
    }
}

//==============================================================================
//== Type checking

func types_compatible(t1: *Type, t2: *Type): Bool {
    if (type_eq(t1, t2)) {
        return true;
    }
    if (t1.kind == Type_Ptr && t2.kind == Type_Ptr) {
        var p1 = t1 as *PtrType;
        var p2 = t2 as *PtrType;
        return p1.pointee.kind == Type_Void || p2.pointee.kind == Type_Void;
    }
    return false;
}

func report_type_mismatch(pos: *Pos, expected: *Type, actual: *Type) {
    die_at(pos, "Type mismatch: %s != %s.\n", pretty_type(expected), pretty_type(actual));
}

func try_coerce_expr_with_cast(e: *Expr, target: *Type, out: **Expr): Bool {
    if (!type_implicitly_convertible(e.type, target)) {
        return false;
    }
    var cast: *CastExpr = calloc(1, sizeof(CastExpr));
    var const_value: *ConstValue = null;
    if (e.const_value) {
        const_value = const_value_cast(e.const_value, target);
    }
    *cast = CastExpr {
        kind: Expr_Cast,
        pos: e.pos,
        type: target,
        const_value,
        expr: e,
        type_expr: null
    };
    *out = cast;
    return true;
}

/*
Desugar
    x: MyUnion = 123
to
    x: MyUnion = MyUnion { field: 123 }
*/
func try_coerce_expr_to_union(e: *Expr, target: *Type, out: **Expr): Bool {
    if (target.kind != Type_Record) {
        return false;
    }

    var target = target as *RecordType;
    if (!target.sym.is_union) {
        return false;
    }

    var sym = target.sym;

    var field_index = find_record_field_by_type(sym, e.type);
    if (field_index == -1) {
        return false;
    }

    var field: *RecordField = list_get(sym.fields, field_index);

    var field_init: *FieldInitializer = calloc(1, sizeof(FieldInitializer));
    *field_init = FieldInitializer {
        pos: e.pos,
        name: field.name,
        expr: e
    };

    var field_inits: *List = list_new();
    list_push(field_inits, field_init);

    var record_expr: *RecordExpr = calloc(1, sizeof(RecordExpr));
    *record_expr = RecordExpr {
        kind: Expr_Record,
        pos: e.pos,
        type: target,
        const_value: null,
        name: sym.name,
        fields: field_inits,
    };
    *out = record_expr;
    return true;
}

func try_coerce_expr(e: *Expr, target: *Type, out: **Expr): Bool {
    return types_compatible(e.type, target)
        || try_coerce_expr_with_cast(e, target, out)
        || try_coerce_expr_to_union(e, target, out);
}

func try_coerce_expr_to_int(e: *Expr, out: **Expr): Bool {
    var target_type: *Type = null;
    for (var size = 1; size <= 8; size *= 2) {
        target_type = mk_int_type(size);
        if (try_coerce_expr_with_cast(e, target_type, out)) {
            return true;
        }
    }
    return false;
}

func check_expr_type(e: **Expr, expected: *Type) {
    try_coerce_expr(*e, expected, e);
    if (!types_compatible((*e).type, expected)) {
        report_type_mismatch(&(*e).pos, expected, (*e).type);
    }
}

func check_expr_type_int(e: **Expr) {
    if (!try_coerce_expr_to_int(*e, e)) {
        die_at(&(*e).pos, "Integer expression expected");
    }
}

func check_expr_type_bool(e: **Expr) {
    check_expr_type(e, mk_bool_type());
}

func unify_expr_types(e1: **Expr, e2: **Expr) {
    try_coerce_expr(*e2, (*e1).type, e2);
    try_coerce_expr(*e1, (*e2).type, e1);
    check_expr_type(e2, (*e1).type);
}

func check_pattern_type(p: **Pattern, expected: *Type) {
    if (!types_compatible((*p).type, expected)) {
        report_type_mismatch(&(*p).pos, expected, (*p).type);
    }
}

func check_pattern_type_int(p: **Pattern) {
    if ((*p).type.kind != Type_Int) {
        die_at(&(*p).pos, "Integer pattern expected");
    }
}

//==============================================================================
//== Types

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type);
func const_eval_int64(ctx: *ElabCtx, expr: *Expr): Int;

func eval_type(ctx: *ElabCtx, type_expr: *TypeExpr): *Type {
    if (type_expr.kind == TypeExpr_Named) {
        var name: *Char = (type_expr as *NamedTypeExpr).name;
        if (str_eq(name, "Void")) {
            return mk_void_type();
        } else if (str_eq(name, "Bool")) {
            return mk_bool_type();
        } else if (str_eq(name, "Char") || str_eq(name, "Int8")) {
            return mk_int_type(1);
        } else if (str_eq(name, "Int16")) {
            return mk_int_type(2);
        } else if (str_eq(name, "Int32")) {
            return mk_int_type(4);
        } else if (str_eq(name, "Int") || str_eq(name, "Int64")) {
            return mk_int_type(8);
        } else {
            var sym = lookup(ctx, name);
            if (!sym) {
                die_at(&type_expr.pos, "Unknown type");
            }
            if (sym.kind == Sym_Enum) {
                return mk_enum_type(sym as *EnumSym);
            } else if (sym.kind == Sym_Record) {
                return mk_record_type(sym as *RecordSym);
            } else {
                die_at(&type_expr.pos, "Expected a type");
            }
        }
    } else if (type_expr.kind == TypeExpr_Ptr) {
        var pointee = eval_type(ctx, (type_expr as *PtrTypeExpr).pointee);
        return mk_ptr_type(pointee);
    } else if (type_expr.kind == TypeExpr_Arr) {
        var type_expr = type_expr as *ArrTypeExpr;
        var elem = eval_type(ctx, type_expr.elem);
        var size = const_eval_int64(ctx, type_expr.size);
        return mk_array_type(elem, size);
    } else if (type_expr.kind == TypeExpr_Never) {
        return mk_never_type();
    } else if (type_expr.kind == TypeExpr_Typeof) {
        var type_expr = type_expr as *TypeofTypeExpr;
        elab_expr_infer(ctx, type_expr.expr, type_hint: null);
        return type_expr.expr.type;
    } else if (type_expr.kind == TypeExpr_RestParam) {
        return mk_rest_param_type();
    } else {
        unreachable("eval_type");
    }
}

//==============================================================================
//== Constants

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type);
func elab_expr_expect(ctx: *ElabCtx, expr: **Expr, expected: *Type);

func const_eval_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type): *ConstValue {
    elab_expr_infer(ctx, expr, type_hint);
    if (!expr.const_value) {
        die_at(&expr.pos, "Expected a constant expression");
    }
    return expr.const_value;
}

func const_eval_expect(ctx: *ElabCtx, expr: *Expr, expected: *Type): *ConstValue {
    elab_expr_expect(ctx, &expr, expected);
    if (!expr.const_value) {
        die_at(&expr.pos, "Expected a constant expression");
    }
    return expr.const_value;
}

func const_eval_int64(ctx: *ElabCtx, expr: *Expr): Int {
    return (const_eval_expect(ctx, expr, mk_int_type(8)) as *IntConstValue).int;
}

func const_eval_int32(ctx: *ElabCtx, expr: *Expr): Int32 {
    return (const_eval_expect(ctx, expr, mk_int_type(4)) as *IntConstValue).int as Int32;
}

//==============================================================================
//== Literals

func elab_literal(ctx: *ElabCtx, literal: *Literal, type_hint: *Type): *ConstValue {
    if (literal.kind == Literal_Null) {
        var type = type_hint && type_hint.kind == Type_Ptr ? type_hint : mk_ptr_type(mk_void_type());
        return mk_null_const_value(type);
    } else if (literal.kind == Literal_Bool) {
        var literal = literal as *BoolLiteral;
        return mk_bool_const_value(literal.value);
    } else if (literal.kind == Literal_Int) {
        var literal = literal as *IntLiteral;
        var type = type_hint && type_hint.kind == Type_Int ? type_hint : mk_int_type(8);
        return mk_int_const_value(literal.value, type);
    } else if (literal.kind == Literal_Char) {
        var literal = literal as *CharLiteral;
        return mk_int_const_value(literal.value, mk_int_type(1));
    } else if (literal.kind == Literal_String) {
        var literal = literal as *StringLiteral;
        return mk_string_const_value(literal.value);
    } else {
        unreachable("elab_literal");
    }
}

//==============================================================================
//== Patterns

func elab_pattern_infer(ctx: *ElabCtx, pattern: *Pattern, type_hint: *Type);

func elab_pattern_expect(ctx: *ElabCtx, pattern: **Pattern, expected: *Type) {
    elab_pattern_infer(ctx, *pattern, expected);
    check_pattern_type(pattern, expected);
}

func elab_grouped_pattern(ctx: *ElabCtx, pattern: *GroupedPattern, type_hint: *Type) {
    elab_pattern_infer(ctx, pattern.pattern, type_hint);
    pattern.type = pattern.pattern.type;
}

func elab_literal_pattern(ctx: *ElabCtx, pattern: *LiteralPattern, type_hint: *Type) {
    var literal = pattern.literal;
    pattern.value = elab_literal(ctx, literal, type_hint);
    pattern.type = pattern.value.type;
}

func elab_name_pattern(ctx: *ElabCtx, pattern: *NamePattern, type_hint: *Type) {
    var name = pattern.name;

    var sym = lookup(ctx, name);
    if (!sym) {
        die_at(&pattern.pos, "Unknown symbol");
    }
    if (sym.kind != Sym_Const) {
        die_at(&pattern.pos, "Expected a constant");
    }

    pattern.sym = sym as *ConstSym;
    pattern.type = pattern.sym.value.type;
}

func elab_wildcard_pattern(ctx: *ElabCtx, pattern: *WildcardPattern, type_hint: *Type) {
    pattern.type = type_hint;
}

func elab_var_pattern(ctx: *ElabCtx, pattern: *VarPattern, type_hint: *Type) {
    var name = pattern.name;

    elab_pattern_infer(ctx, pattern.pattern, type_hint);

    if (ctx.or_pattern_depth > 0) {
        die_at(&pattern.pos, "Variable pattern not allowed in 'or' pattern");
    }

    var sym = define_local(ctx, &pattern.pos, name, type_hint);

    pattern.sym = sym;
    pattern.type = sym.type;
}

func elab_range_pattern(ctx: *ElabCtx, pattern: *RangePattern, type_hint: *Type) {
    if (!pattern.lower && !pattern.upper) {
        die_at(&pattern.pos, "Range pattern must have at least one bound");
    }

    var lower_bound = pattern.lower ? const_eval_infer(ctx, pattern.lower, type_hint) : null;
    var upper_bound = pattern.upper ? const_eval_infer(ctx, pattern.upper, type_hint) : null;

    var lower_type = lower_bound ? lower_bound.type : upper_bound.type;
    var upper_type = upper_bound ? upper_bound.type : lower_bound.type;
    if (!type_eq(lower_type, upper_type)) {
        report_type_mismatch(&pattern.pos, lower_type, upper_type);
    }

    var type = lower_bound ? lower_bound.type : upper_bound.type;
    if (type.kind != Type_Int) {
        die_at(&pattern.pos, "Integer range pattern expected");
    }

    pattern.lower_value = lower_bound;
    pattern.upper_value = upper_bound;
    pattern.type = type;
}

func elab_or_pattern(ctx: *ElabCtx, pattern: *OrPattern, type_hint: *Type) {
    ctx.or_pattern_depth += 1;

    var patterns = pattern.patterns;

    var first_pattern: *Pattern = list_get(patterns, 0);
    elab_pattern_infer(ctx, first_pattern, type_hint);

    for (var i = 1; i < list_len(patterns); i += 1) {
        var next_pattern: *Pattern = list_get(patterns, i);
        elab_pattern_expect(ctx, &next_pattern, first_pattern.type);
    }

    pattern.type = first_pattern.type;

    ctx.or_pattern_depth -= 1;
}

func elab_pattern_infer(ctx: *ElabCtx, pattern: *Pattern, type_hint: *Type) {
    if (pattern.kind == Pattern_Grouped) {
        elab_grouped_pattern(ctx, pattern as *GroupedPattern, type_hint);
    } else if (pattern.kind == Pattern_Literal) {
        elab_literal_pattern(ctx, pattern as *LiteralPattern, type_hint);
    } else if (pattern.kind == Pattern_Name) {
        elab_name_pattern(ctx, pattern as *NamePattern, type_hint);
    } else if (pattern.kind == Pattern_Wildcard) {
        elab_wildcard_pattern(ctx, pattern as *WildcardPattern, type_hint);
    } else if (pattern.kind == Pattern_Var) {
        elab_var_pattern(ctx, pattern as *VarPattern, type_hint);
    } else if (pattern.kind == Pattern_Range) {
        elab_range_pattern(ctx, pattern as *RangePattern, type_hint);
    } else if (pattern.kind == Pattern_Or) {
        elab_or_pattern(ctx, pattern as *OrPattern, type_hint);
    } else {
        unreachable("elab_pattern_infer");
    }
    assert(pattern.type, "elab_pattern_infer");
}

//==============================================================================
//== Expressions

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type);

func elab_expr_expect(ctx: *ElabCtx, expr: **Expr, expected: *Type) {
    elab_expr_infer(ctx, *expr, type_hint: expected);
    check_expr_type(expr, expected);
}

func elab_expr_bool(ctx: *ElabCtx, expr: **Expr) {
    elab_expr_expect(ctx, expr, mk_bool_type());
}

func elab_expr_int(ctx: *ElabCtx, expr: **Expr, type_hint: *Type) {
    elab_expr_infer(ctx, *expr, type_hint);
    check_expr_type_int(expr);
}

func elab_ident_expr(ctx: *ElabCtx, expr: *IdentExpr) {
    var name = expr.name;

    var sym = lookup(ctx, name);
    if (!sym) {
        die_at(&expr.pos, "Unknown symbol");
    }

    var type: *Type;
    var const_val: *ConstValue = null;
    if (sym.kind == Sym_Local) {
        type = (sym as *LocalSym).type;
    } else if (sym.kind == Sym_Global) {
        type = (sym as *GlobalSym).type;
    } else if (sym.kind == Sym_Const) {
        var sym = sym as *ConstSym;
        type = sym.value.type;
        const_val = sym.value;
    } else {
        die_at(&expr.pos, "Expected a variable or constant");
    }

    expr.sym = sym;
    expr.type = type;
    expr.const_value = const_val;
}

func elab_literal_expr(ctx: *ElabCtx, expr: *LiteralExpr, type_hint: *Type) {
    var literal = expr.literal;
    expr.const_value = elab_literal(ctx, literal, type_hint);
    expr.type = expr.const_value.type;
}

func elab_array_expr(ctx: *ElabCtx, expr: *ArrayExpr, type_hint: *Type) {
    var elem_type_hint: *Type = null;
    if (type_hint && type_hint.kind == Type_Arr) {
        elem_type_hint = (type_hint as *ArrType).elem;
    }

    var elems = expr.elems;

    var elem_type: *Type = null;
    var elem_count = list_len(elems);

    for (var i = 0; i < elem_count; i += 1) {
        var elem: *Expr = list_get(elems, i);
        elab_expr_infer(ctx, elem, elem_type_hint);
        if (i == 0) {
            elem_type = elem.type;
        } else {
            var prev_expr: *Expr = list_get(elems, i - 1);
            check_expr_type(&elem, elem_type);
            list_set(elems, i, elem);
            list_set(elems, i - 1, prev_expr);
        }
    }

    if (!elem_type) {
        die_at(&expr.pos, "Empty array");
    }

    if (!is_sized(elem_type)) {
        die_at(&expr.pos, "Array element type is not sized");
    }

    expr.type = mk_array_type(elem_type, elem_count);
}

func elab_call_expr(ctx: *ElabCtx, expr: *CallExpr) {
    var callee = expr.callee;
    var args = expr.args;

    if (callee.kind != Expr_Ident) {
        die_at(&callee.pos, "Expected function name");
    }
    var sym = lookup(ctx, (callee as *IdentExpr).name);
    if (!sym) {
        die_at(&callee.pos, "Unknown function");
    }
    if (sym.kind != Sym_Func) {
        die_at(&callee.pos, "Expected a function");
    }
    var sym = sym as *FuncSym;

    var param_count = list_len(sym.params);
    var arg_count = list_len(args);

    var is_initialized: *Bool = calloc(param_count, sizeof(*Bool));
    var seen_named_arg = false;

    for (var i = 0; i < arg_count; i += 1) {
        var arg: *CallArg = list_get(args, i);
        if (arg.label) {
            var param_index = find_param_by_name(sym, arg.label);
            if (param_index == -1) {
                die_at(&arg.expr.pos, "Unknown parameter '%s'", arg.label);
            } else if (is_initialized[param_index]) {
                die_at(&arg.expr.pos, "Parameter '%s' is already initialized", arg.label);
            }
            var param: *FuncParam = list_get(sym.params, param_index);
            elab_expr_expect(ctx, &arg.expr, param.type);

            is_initialized[param_index] = true;
            arg.positional_index = param_index;
            seen_named_arg = true;
        } else if (seen_named_arg) {
            die_at(&arg.expr.pos, "Positional argument cannot follow a named argument");
        } else if (i >= param_count) {
            if (!sym.is_variadic) {
                die_at(&arg.expr.pos, "Too many arguments provided");
            }
            elab_expr_infer(ctx, arg.expr, type_hint: null);
            if (!is_sized(arg.expr.type)) {
                die_at(&arg.expr.pos, "Cannot pass an unsized type as a variadic argument");
            }
            arg.positional_index = i;
        } else {
            var param: *FuncParam = list_get(sym.params, i);
            elab_expr_expect(ctx, &arg.expr, param.type);

            is_initialized[i] = true;
            arg.positional_index = i;
        }
    }

    for (var i = 0; i < param_count; i += 1) {
        var param: *FuncParam = list_get(sym.params, i);
        if (!is_initialized[i] && !param.default_value) {
            var param: *FuncParam = list_get(sym.params, i);
            die_at(&expr.pos, "Parameter '%s' is not initialized", param.name);
        }
    }

    expr.resolved_callee = sym;
    expr.type = sym.return_type;
}

func elab_index_expr(ctx: *ElabCtx, expr: *IndexExpr) {
    var indexee = expr.indexee;
    var index = expr.index;

    elab_expr_infer(ctx, indexee, type_hint: null);
    elab_expr_infer(ctx, index, type_hint: null);

    var indexee_type = indexee.type;
    if (indexee_type.kind != Type_Arr && indexee_type.kind != Type_Ptr) {
        die_at(&indexee.pos, "Expression is not indexable");
    }

    var elem_type = indexee_type.kind == Type_Arr
    ? (indexee_type as *ArrType).elem
    : (indexee_type as *PtrType).pointee;

    check_expr_type_int(&index);
    expr.type = elem_type;
    expr.index = index;
}

func elab_member_expr(ctx: *ElabCtx, expr: *MemberExpr) {
    var left = expr.left;
    var field_name = expr.name;

    elab_expr_infer(ctx, left, type_hint: null);

    var left_type = left.type;
    if (left_type.kind == Type_Ptr) {
        left_type = (left_type as *PtrType).pointee;
    }
    if (left_type.kind != Type_Record) {
        die_at(&left.pos, "Expected a record");
    }
    var left_type = left_type as *RecordType;

    var record_sym = left_type.sym;
    var field_index = find_record_field_by_name(record_sym, field_name);
    if (field_index == -1) {
        die_at(&expr.pos, "Unknown field");
    }

    var field: *RecordField = list_get(record_sym.fields, field_index);
    expr.resolved_field = field_index;
    expr.type = field.type;
}

func elab_sizeof_expr(ctx: *ElabCtx, expr: *SizeofExpr) {
    var type = eval_type(ctx, expr.type_expr);
    var size = type_size(type);
    if (size == -1) {
        die_at(&expr.pos, "Size of type cannot be determined");
    }
    expr.size = size;
    expr.type = mk_int_type(8);
    expr.const_value = mk_int_const_value(size, expr.type);
}

func elab_unary_expr(ctx: *ElabCtx, expr: *UnaryExpr, type_hint: *Type) {
    var op = expr.op;
    var right = expr.right;

    if (op == Tok_Minus || op == Tok_Tilde) {
        elab_expr_infer(ctx, right, type_hint);
        check_expr_type_int(&right);
        expr.type = right.type;
        expr.right = right;
    } else if (op == Tok_Bang) {
        elab_expr_bool(ctx, &right);
        expr.type = mk_bool_type();
        expr.right = right;
    } else if (op == Tok_Star) {
        var right_type_hint: *Type = mk_ptr_type(type_hint);
        elab_expr_infer(ctx, right, type_hint: right_type_hint);
        var pointee_type = right.type;
        if (pointee_type.kind != Type_Ptr) {
            die_at(&right.pos, "Expected a pointer");
        }
        expr.type = (pointee_type as *PtrType).pointee;
    } else if (op == Tok_Amp) {
        var right_type_hint: *Type = null;
        if (right_type_hint && type_hint.kind == Type_Ptr) {
            right_type_hint = (type_hint as *PtrType).pointee;
        }
        elab_expr_infer(ctx, right, right_type_hint);
        expr.type = mk_ptr_type(right.type);
    } else {
        unreachable("elab_unary_expr");
    }
    if (right.const_value) {
        expr.const_value = const_value_unop(op, right.const_value);
    }
}

func elab_binary_expr(ctx: *ElabCtx, expr: *BinaryExpr, type_hint: *Type) {
    var op = expr.op;
    var left = expr.left;
    var right = expr.right;

    if (op == Tok_Eq || op == Tok_AmpEq || op == Tok_BarEq || op == Tok_CaretEq || op == Tok_LtLtEq || op == Tok_GtGtEq || op == Tok_PlusEq || op == Tok_MinusEq || op == Tok_StarEq || op == Tok_SlashEq || op == Tok_PercentEq) {
        if (!is_lvalue(left)) {
            die_at(&left.pos, "L-value expected");
        }
        elab_expr_infer(ctx, left, type_hint: null);
        if (op != Tok_Eq) {
            if (expr.left.type.kind != Type_Int) {
                die_at(&left.pos, "Left operand is not an integer expression");
            }
        }
        elab_expr_expect(ctx, &right, left.type);
        if (!is_sized(left.type)) {
            die_at(&left.pos, "Cannot assign to an unsized type");
        }
        expr.type = mk_void_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_AmpAmp || op == Tok_BarBar) {
        elab_expr_bool(ctx, &left);
        elab_expr_bool(ctx, &right);
        expr.type = mk_bool_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_EqEq || op == Tok_BangEq || op == Tok_Lt || op == Tok_LtEq || op == Tok_Gt || op == Tok_GtEq) {
        elab_expr_infer(ctx, left, type_hint: null);
        elab_expr_infer(ctx, right, type_hint: left.type);
        unify_expr_types(&left, &right);
        if (!is_scalar(left.type)) {
            die_at(&left.pos, "Operands type is not comparable");
        }
        expr.type = mk_bool_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_Amp || op == Tok_Bar || op == Tok_Caret || op == Tok_LtLt || op == Tok_GtGt || op == Tok_Plus || op == Tok_Minus || op == Tok_Star || op == Tok_Slash || op == Tok_Percent) {
        elab_expr_int(ctx, &left, type_hint);
        elab_expr_int(ctx, &right, left.type);
        unify_expr_types(&left, &right);
        expr.type = left.type;
        expr.left = left;
        expr.right = right;
    } else {
        unreachable("elab_binary_expr");
    }
    if (left.const_value && right.const_value) {
        expr.const_value = const_value_binop(op, left.const_value, right.const_value);
    }
}

func elab_ternary_expr(ctx: *ElabCtx, expr: *TernaryExpr, type_hint: *Type) {
    var cond = expr.cond;
    var then_expr = expr.then_expr;
    var else_expr = expr.else_expr;

    elab_expr_bool(ctx, &cond);
    elab_expr_infer(ctx, then_expr, type_hint: type_hint);
    elab_expr_infer(ctx, else_expr, type_hint: then_expr.type);

    unify_expr_types(&then_expr, &else_expr);
    expr.type = then_expr.type;
    expr.cond = cond;
    expr.then_expr = then_expr;
    expr.else_expr = else_expr;
    if (cond.const_value) {
        expr.const_value = const_value_ternop(cond.const_value, then_expr.const_value, else_expr.const_value);
    }
}

// `x is <pattern>`
func elab_is_expr(ctx: *ElabCtx, expr: *IsExpr) {
    var left = expr.left;
    var pattern = expr.pattern;

    elab_expr_infer(ctx, left, type_hint: null);
    elab_pattern_infer(ctx, pattern, left.type);

    expr.type = mk_bool_type();
}

func elab_cast_expr(ctx: *ElabCtx, expr: *CastExpr) {
    var subexpr = expr.expr;
    elab_expr_infer(ctx, subexpr, type_hint: null);

    var source_type = subexpr.type;
    var target_type = eval_type(ctx, expr.type_expr);

    if (!type_convertible(source_type, target_type)) {
        die_at(&expr.pos, "Invalid cast");
    }

    expr.type = target_type;

    if (subexpr.const_value) {
        expr.const_value = const_value_cast(subexpr.const_value, target_type);
    }
}

func elab_record_expr(ctx: *ElabCtx, expr: *RecordExpr, type_hint: *Type) {
    var sym = lookup(ctx, expr.name);
    if (!sym) {
        die_at(&expr.pos, "Unknown record type");
    }
    if (sym.kind != Sym_Record) {
        die_at(&expr.pos, "Expected a record type");
    }
    var sym = sym as *RecordSym;
    if (!sym.is_defined) {
        die_at(&expr.pos, "Record has incomplete type");
    }

    var fields = sym.fields;
    var n_fields = list_len(fields);

    var initializers = expr.fields;
    var n_initializers = list_len(initializers);

    var is_initialized: *Bool = calloc(n_fields, sizeof(*Bool));

    for (var i = 0; i < n_initializers; i += 1) {
        var initializer: *FieldInitializer = list_get(initializers, i);
        var field_name = initializer.name;
        var field_index = find_record_field_by_name(sym, field_name);
        if (field_index == -1) {
            die_at(&initializer.pos, "Unknown field");
        }
        var field: *RecordField = list_get(fields, field_index);

        if (is_initialized[field_index]) {
            die_at(&initializer.pos, "Field is already initialized");
        }
        is_initialized[field_index] = true;
        elab_expr_expect(ctx, &initializer.expr, field.type);
    }

    for (var i = 0; i < n_fields; i += 1) {
        var field: *RecordField = list_get(fields, i);
        is_initialized[i] = is_initialized[i] || field.default_value;
    }

    if (!sym.is_union) {
        for (var i = 0; i < n_fields; i += 1) {
            if (!is_initialized[i]) {
                var field: *RecordField = list_get(fields, i);
                die_at(&expr.pos, "Field '%s' is not initialized.", field.name);
            }
        }
    } else {
        if (n_initializers == 0) {
            die_at(&expr.pos, "No field is initialized.");
        } else if (n_initializers > 1) {
            die_at(&expr.pos, "Only one field can be initialized in a union");
        }
    }

    free(is_initialized);

    expr.type = mk_record_type(sym);
}

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr, type_hint: *Type) {
    if (expr.kind == Expr_Ident) {
        elab_ident_expr(ctx, expr as *IdentExpr);
    } else if (expr.kind == Expr_Literal) {
        elab_literal_expr(ctx, expr as *LiteralExpr, type_hint);
    } else if (expr.kind == Expr_Array) {
        elab_array_expr(ctx, expr as *ArrayExpr, type_hint);
    } else if (expr.kind == Expr_Call) {
        elab_call_expr(ctx, expr as *CallExpr);
    } else if (expr.kind == Expr_Index) {
        elab_index_expr(ctx, expr as *IndexExpr);
    } else if (expr.kind == Expr_Member) {
        elab_member_expr(ctx, expr as *MemberExpr);
    } else if (expr.kind == Expr_Sizeof) {
        elab_sizeof_expr(ctx, expr as *SizeofExpr);
    } else if (expr.kind == Expr_Unary) {
        elab_unary_expr(ctx, expr as *UnaryExpr, type_hint);
    } else if (expr.kind == Expr_Binary) {
        elab_binary_expr(ctx, expr as *BinaryExpr, type_hint);
    } else if (expr.kind == Expr_Ternary) {
        elab_ternary_expr(ctx, expr as *TernaryExpr, type_hint);
    } else if (expr.kind == Expr_Is) {
        elab_is_expr(ctx, expr as *IsExpr);
    } else if (expr.kind == Expr_Cast) {
        elab_cast_expr(ctx, expr as *CastExpr);
    } else if (expr.kind == Expr_Record) {
        elab_record_expr(ctx, expr as *RecordExpr, type_hint);
    } else {
        unreachable("elab_expr_infer");
    }
    assert(expr.type, "elab_expr_infer");
}

//==============================================================================
//== Statements

func elab_stmt(ctx: *ElabCtx, stmt: *Stmt);
func seed_const_decl(ctx: *ElabCtx, decl: *ConstDecl);
func elab_const_decl(ctx: *ElabCtx, decl: *ConstDecl);

func elab_stmt_with_scope(ctx: *ElabCtx, stmt: *Stmt) {
    enter_scope(ctx);
    elab_stmt(ctx, stmt);
    exit_scope(ctx);
}

func elab_block_stmt(ctx: *ElabCtx, stmt: *BlockStmt) {
    enter_scope(ctx);
    for (var i = 0; i < list_len(stmt.stmts); i += 1) {
        var stmt = list_get(stmt.stmts, i);
        elab_stmt(ctx, stmt);
    }
    exit_scope(ctx);
}

func elab_const_stmt(ctx: *ElabCtx, stmt: *ConstStmt) {
    var decl = stmt.decl;
    seed_const_decl(ctx, decl);
    elab_const_decl(ctx, decl);
}

func elab_local_stmt(ctx: *ElabCtx, stmt: *LocalStmt) {
    var name = stmt.name;
    var typeExpr = stmt.type;
    var init = stmt.init;

    var type: *Type = typeExpr ? eval_type(ctx, typeExpr) : null;
    if (init) {
        if (!type) {
            elab_expr_infer(ctx, init, type_hint: null);
            type = init.type;
        } else {
            elab_expr_expect(ctx, &init, type);
            stmt.init = init;
        }
    } else {
        if (!type) {
            die_at(&stmt.pos, "Type required when no initializer is provided");
        }
    }

    if (!is_sized(type)) {
        die_at(&stmt.pos, "Variable must have a size.");
    }

    var sym = define_local(ctx, &stmt.pos, name, type);
    stmt.sym = sym;
}

func elab_if_stmt(ctx: *ElabCtx, stmt: *IfStmt) {
    var cond = stmt.cond;
    var then_stmt = stmt.then_stmt;
    var else_stmt = stmt.else_stmt;

    elab_expr_bool(ctx, &cond);
    stmt.cond = cond;

    elab_stmt_with_scope(ctx, then_stmt);
    if (else_stmt) {
        elab_stmt_with_scope(ctx, else_stmt);
    }
}

func elab_match_case(ctx: *ElabCtx, match_case: *MatchCase, scrutinee_type: *Type) {
    var pattern = match_case.pattern;
    var guard = match_case.guard;
    var body = match_case.body;

    enter_scope(ctx);
    elab_pattern_expect(ctx, &pattern, scrutinee_type);
    if (guard) {
        elab_expr_bool(ctx, &guard);
    }
    elab_stmt_with_scope(ctx, body);
    exit_scope(ctx);

    match_case.guard = guard;
}

func elab_match_stmt(ctx: *ElabCtx, stmt: *MatchStmt) {
    var scrutinee = stmt.scrutinee;
    var match_cases = stmt.cases;

    elab_expr_infer(ctx, scrutinee, type_hint: null);

    for (var i = 0; i < list_len(match_cases); i += 1) {
        var match_case: *MatchCase = list_get(match_cases, i);
        elab_match_case(ctx, match_case, scrutinee.type);
    }
}

func elab_while_stmt(ctx: *ElabCtx, stmt: *WhileStmt) {
    var cond = stmt.cond;
    var body = stmt.body;

    elab_expr_bool(ctx, &cond);
    stmt.cond = cond;

    ctx.loop_depth += 1;
    elab_stmt_with_scope(ctx, body);
    ctx.loop_depth -= 1;
}

func elab_for_stmt(ctx: *ElabCtx, stmt: *ForStmt) {
    var init = stmt.init;
    var cond = stmt.cond;
    var step = stmt.step;
    var body = stmt.body;

    enter_scope(ctx);

    if (init) {
        elab_stmt(ctx, init);
    }
    if (cond) {
        elab_expr_bool(ctx, &cond);
        stmt.cond = cond;
    }
    if (step) {
        elab_expr_infer(ctx, step, type_hint: null);
    }

    ctx.loop_depth += 1;
    elab_stmt_with_scope(ctx, body);
    ctx.loop_depth -= 1;

    exit_scope(ctx);
}

func elab_return_stmt(ctx: *ElabCtx, stmt: *ReturnStmt) {
    var return_expr = stmt.expr;

    var return_type = ctx.current_func.return_type;
    if (return_expr) {
        elab_expr_expect(ctx, &return_expr, return_type);
        stmt.expr = return_expr;
    } else if (return_type.kind != Type_Void) {
        die_at(&stmt.pos, "Missing return value");
    }
}

func elab_break_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (!ctx.loop_depth) {
        die_at(&stmt.pos, "Break statement outside of loop");
    }
}

func elab_continue_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (!ctx.loop_depth) {
        die_at(&stmt.pos, "Continue statement outside of loop");
    }
}

func elab_expr_stmt(ctx: *ElabCtx, stmt: *ExprStmt) {
    var expr = stmt.expr;
    elab_expr_infer(ctx, expr, type_hint: null);
}

func elab_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (stmt.kind == Stmt_Block) {
        elab_block_stmt(ctx, stmt as *BlockStmt);
    } else if (stmt.kind == Stmt_Const) {
        elab_const_stmt(ctx, stmt as *ConstStmt);
    } else if (stmt.kind == Stmt_Local) {
        elab_local_stmt(ctx, stmt as *LocalStmt);
    } else if (stmt.kind == Stmt_If) {
        elab_if_stmt(ctx, stmt as *IfStmt);
    } else if (stmt.kind == Stmt_Match) {
        elab_match_stmt(ctx, stmt as *MatchStmt);
    } else if (stmt.kind == Stmt_While) {
        elab_while_stmt(ctx, stmt as *WhileStmt);
    } else if (stmt.kind == Stmt_For) {
        elab_for_stmt(ctx, stmt as *ForStmt);
    } else if (stmt.kind == Stmt_Return) {
        elab_return_stmt(ctx, stmt as *ReturnStmt);
    } else if (stmt.kind == Stmt_Break) {
        elab_break_stmt(ctx, stmt);
    } else if (stmt.kind == Stmt_Continue) {
        elab_continue_stmt(ctx, stmt);
    } else if (stmt.kind == Stmt_Expr) {
        elab_expr_stmt(ctx, stmt as *ExprStmt);
    } else {
        unreachable("elab_stmt");
    }
}

//==============================================================================
//== Top-level declarations

func seed_enum_member(ctx: *ElabCtx, decl: *EnumMember) {
    decl.sym = declare_const(ctx, &decl.pos, decl.name);
}

func elab_enum_member(ctx: *ElabCtx, decl: *EnumMember, type: *Type, next_value: Int32): Int32 {
    var value = next_value;
    if (decl.value) {
        value = const_eval_int32(ctx, decl.value);
    }

    var const_value = mk_int_const_value(value, type);
    define_const(ctx, &decl.pos, decl.sym, const_value);
    return value;
}

func seed_enum_decl(ctx: *ElabCtx, decl: *EnumDecl) {
    if (decl.name) {
        decl.sym = declare_enum(ctx, &decl.pos, decl.name);
    }
    var member_decls = decl.members;
    for (var i = 0; i < list_len(member_decls); i += 1) {
        seed_enum_member(ctx, list_get(member_decls, i));
    }
}

func elab_enum_decl(ctx: *ElabCtx, decl: *EnumDecl) {
    if (decl.name) {
        define_enum(ctx, &decl.pos, decl.sym, size: 4);
    }

    var type: *Type;
    if (decl.name) {
        type = mk_enum_type(decl.sym);
    } else {
        type = mk_int_type(4);
    }

    var next_value: Int32 = 0;
    var member_decls = decl.members;
    for (var i = 0; i < list_len(member_decls); i += 1) {
        var member_decl: *EnumMember = list_get(member_decls, i);
        var value = elab_enum_member(ctx, member_decl, type, next_value);
        next_value = value + 1;
    }
}

func add_field_to_record(ctx: *ElabCtx, sym: *RecordSym, field_decl: *RecordFieldDecl) {
    var field_name = field_decl.name;
    var field_type = eval_type(ctx, field_decl.type);

    var existing_index = find_record_field_by_name(sym, field_name);
    if (existing_index != -1) {
        die_at(&field_decl.pos, "Duplicate field");
    }

    var default_value: *ConstValue = null;
    if (field_decl.default_value) {
        default_value = const_eval_expect(ctx, field_decl.default_value, field_type);
    }

    var field_size = type_size(field_type);
    var field_align = type_align(field_type);
    var field_offset = sym.is_union
    ? 0
    : align_up(sym.unpadded_size, field_align);

    var field: *RecordField = calloc(1, sizeof(RecordField));
    *field = RecordField {
        name: field_name,
        type: field_type,
        default_value,
        offset: field_offset,
    };

    list_push(sym.fields, field);
    if (sym.is_union) {
        sym.unpadded_size = int_max(sym.unpadded_size, field_size);
    } else {
        sym.unpadded_size = field_offset + field_size;
    }
    sym.align = int_max(sym.align, field_align);
}

func add_default_value_to_field(ctx: *ElabCtx, sym: *RecordSym, field_decl: *RecordFieldDecl) {
    var field_index = find_record_field_by_name(sym, field_decl.name);
    if (field_index == -1) {
        die_at(&field_decl.pos, "No existing field to add default value to");
    }

    var field: *RecordField = list_get(sym.fields, field_index);
    if (field.default_value) {
        die_at(&field_decl.pos, "Field already has a default value");
    }

    field.default_value = const_eval_expect(ctx, field_decl.default_value, field.type);
}

func elab_record_field_decl(ctx: *ElabCtx, field_decl: *RecordFieldDecl, sym: *RecordSym) {
    if (!field_decl.type && field_decl.default_value) {
        add_default_value_to_field(ctx, sym, field_decl);
    } else if (field_decl.type) {
        add_field_to_record(ctx, sym, field_decl);
    } else {
        die_at(&field_decl.pos, "Field type missing");
    }
}

func elab_record_base(ctx: *ElabCtx, base: *TypeExpr, record_sym: *RecordSym) {
    var base_type = eval_type(ctx, base);
    if (base_type.kind != Type_Record) {
        die_at(&base.pos, "Expected a record type");
    }
    var baseSym = (base_type as *RecordType).sym;
    if (!baseSym.is_defined) {
        die_at(&base.pos, "Base has incomplete type");
    }
    if (baseSym == record_sym) {
        die_at(&base.pos, "Record cannot inherit from itself");
    }
    var base_fields = baseSym.fields;
    if (baseSym.is_union != record_sym.is_union && list_len(base_fields) != 1) {
        die_at(&base.pos, "Base type must be the same kind of record or have exactly one field");
    }
    var fields = list_new_with_cap(list_len(base_fields));
    for (var i = 0; i < list_len(base_fields); i += 1) {
        var field: *RecordField = list_get(base_fields, i);
        var copy: *RecordField = calloc(1, sizeof(RecordField));
        *copy = *field;
        list_push(fields, copy);
    }

    *record_sym = RecordSym {
        kind: Sym_Record,
        is_union: record_sym.is_union,
        name: record_sym.name,
        is_defined: record_sym.is_defined,
        base: baseSym,
        fields: fields,
        unpadded_size: baseSym.unpadded_size,
        align: baseSym.align,
    };
}

func seed_record_decl(ctx: *ElabCtx, decl: *RecordDecl) {
    decl.sym = declare_record(ctx, &decl.pos, decl.is_union, decl.name);
}

func elab_record_decl(ctx: *ElabCtx, decl: *RecordDecl) {
    var sym = decl.sym;
    var base = decl.base;

    if (base) {
        elab_record_base(ctx, base, sym);
    }

    if (decl.fields) {
        if (!sym.fields) {
            sym.fields = list_new();
        }
        for (var i = 0; i < list_len(decl.fields); i += 1) {
            elab_record_field_decl(ctx, list_get(decl.fields, i), sym);
        }
        if (list_len(sym.fields) == 0) {
            die_at(&decl.pos, "Empty record");
        }
    }

    if (base || decl.fields) {
        define_record(ctx, &decl.pos, sym);
    }
}

func string_list_contains(list: *List, value: *Char): Bool {
    for (var i = 0; i < list_len(list); i += 1) {
        var item: *Char = list_get(list, i);
        if (str_eq(item, value)) {
            return true;
        }
    }
    return false;
}

func ensure_unique_params(ctx: *ElabCtx, decl: *FuncDecl) {
    var seen = list_new();
    for (var i = 0; i < list_len(decl.params); i += 1) {
        var param_decl: *FuncParamDecl = list_get(decl.params, i);
        if (string_list_contains(seen, param_decl.name)) {
            die_at(&param_decl.pos, "Duplicate parameter name");
        }
        list_push(seen, param_decl.name);
    }
    if (decl.rest_param && decl.rest_param.name) {
        if (string_list_contains(seen, decl.rest_param.name)) {
            die_at(&decl.rest_param.pos, "Duplicate parameter name");
        }
    }
}

func elab_param(ctx: *ElabCtx, param_decl: *FuncParamDecl): *FuncParam {
    var name = param_decl.name;
    var type = eval_type(ctx, param_decl.type);

    if (!is_sized(type)) {
        die_at(&param_decl.pos, "Parameter has unsized type");
    }

    var default_value: *ConstValue = null;
    if (param_decl.default_value) {
        default_value = const_eval_expect(ctx, param_decl.default_value, type);
    }

    var result: *FuncParam = calloc(1, sizeof(FuncParam));
    *result = FuncParam { name, type, default_value };
    return result;
}

func check_default_params_order(param_decls: *List, rest_param: *RestParamDecl) {
    var seen_default = false;
    var n_params = list_len(param_decls);
    for (var i = 0; i < n_params; i += 1) {
        var param_decl: *FuncParamDecl = list_get(param_decls, i);
        if (!param_decl.default_value && seen_default) {
            die_at(&param_decl.pos, "Non-default parameter follows default parameter");
        }
        seen_default = seen_default || param_decl.default_value;
    }
    if (rest_param && seen_default) {
        die_at(&rest_param.pos, "Variadic parameter cannot follow default parameters");
    }
}

func verify_main_signature(decl: *FuncDecl, sym: *FuncSym) {
    var param_decls = decl.params;
    var params = sym.params;
    var n_params = list_len(param_decls);
    var is_variadic = sym.is_variadic;
    var return_type = sym.return_type;

    if (!type_eq(return_type, mk_int_type(4))) {
        die_at(&decl.pos, "Return type of 'main' must be 'Int32'");
    }

    for (var i = 0; i < n_params; i += 1) {
        var param_decl: *FuncParamDecl = list_get(param_decls, i);
        var param: *FuncParam = list_get(params, i);
        if (i == 0) {
            if (!type_eq(param.type, mk_int_type(4))) {
                die_at(&param_decl.pos, "The arg count parameter of 'main' must have type 'Int32'");
            }
        } else if (i == 1) {
            if (!type_eq(param.type, mk_ptr_type(mk_ptr_type(mk_int_type(1))))) {
                die_at(&param_decl.pos, "The arg vector parameter of 'main' must have type '**Char'");
            }
        } else {
            die_at(&param_decl.pos, "The 'main' function can only have parameters 'argc: Int32' and 'argv: **Char'");
        }
    }

    if (is_variadic) {
        die_at(&decl.pos, "The 'main' function cannot be variadic");
    }
}

func seed_func_decl(ctx: *ElabCtx, decl: *FuncDecl) {
    var n_params = list_len(decl.params);
    var params = list_new();
    for (var i = 0; i < n_params; i += 1) {
        var param_decl = list_get(decl.params, i);
        var param = elab_param(ctx, param_decl);
        list_push(params, param);
    }

    check_default_params_order(decl.params, decl.rest_param);

    var return_type = decl.return_type
        ? eval_type(ctx, decl.return_type)
        : mk_void_type();

    if (return_type.kind != Type_Void && return_type.kind != Type_Never && !is_sized(return_type)) {
        die_at(&decl.pos, "Function return type must have known size");
    }

    decl.sym = declare_func(ctx, &decl.pos, decl.name, params, decl.rest_param, return_type);

    if (str_eq(decl.name, "main")) {
        verify_main_signature(decl, decl.sym);
    }

    ensure_unique_params(ctx, decl);
}

func elab_func_decl(ctx: *ElabCtx, decl: *FuncDecl) {
    if (!decl.body) {
        return;
    }

    var sym = decl.sym;

    enter_scope(ctx);
    ctx.current_func = sym;

    define_params(ctx, decl.params, sym.params);

    if (decl.rest_param) {
        define_local(ctx, &decl.rest_param.pos, decl.rest_param.name, mk_rest_param_type());
    }

    elab_stmt(ctx, decl.body);

    ctx.current_func = null;
    exit_scope(ctx);

    define_func(ctx, &decl.pos, sym, decl.body);
}

func seed_const_decl(ctx: *ElabCtx, decl: *ConstDecl) {
    decl.sym = declare_const(ctx, &decl.pos, decl.name);
}

func elab_const_decl(ctx: *ElabCtx, decl: *ConstDecl) {
    var sym = decl.sym;
    var value_expr = decl.value;
    var type: *Type = null;
    if (decl.type) {
        type = eval_type(ctx, decl.type);
        if (!is_scalar(type)) {
            die_at(&decl.type.pos, "Constant must have a scalar type");
        }
    }
    var value: *ConstValue;
    if (type) {
        value = const_eval_expect(ctx, value_expr, type);
    } else {
        value = const_eval_infer(ctx, value_expr, type_hint: null);
    }
    define_const(ctx, &decl.pos, sym, value);
}

func seed_global_decl(ctx: *ElabCtx, decl: *GlobalDecl) {
    var type = eval_type(ctx, decl.type);
    if (!is_sized(type)) {
        die_at(&decl.pos, "Global variable must have known size");
    }

    decl.sym = declare_global(ctx, &decl.pos, decl.name, type);
}

func elab_global_decl(ctx: *ElabCtx, decl: *GlobalDecl) {
    var sym = decl.sym;

    if (!decl.is_extern) {
        define_global(ctx, &decl.pos, sym);
    }
}

func seed_decl(ctx: *ElabCtx, decl: *Decl) {
    if (decl.kind == Decl_Record) {
        seed_record_decl(ctx, decl as *RecordDecl);
    } else if (decl.kind == Decl_Enum) {
        seed_enum_decl(ctx, decl as *EnumDecl);
    } else if (decl.kind == Decl_Const) {
        seed_const_decl(ctx, decl as *ConstDecl);
    } else if (decl.kind == Decl_Func) {
        seed_func_decl(ctx, decl as *FuncDecl);
    } else if (decl.kind == Decl_Global) {
        seed_global_decl(ctx, decl as *GlobalDecl);
    } else {
        unreachable("seed_decl");
    }
}

func elab_decl(ctx: *ElabCtx, decl: *Decl) {
    if (decl.kind == Decl_Record) {
        elab_record_decl(ctx, decl as *RecordDecl);
    } else if (decl.kind == Decl_Enum) {
        elab_enum_decl(ctx, decl as *EnumDecl);
    } else if (decl.kind == Decl_Const) {
        elab_const_decl(ctx, decl as *ConstDecl);
    } else if (decl.kind == Decl_Func) {
        elab_func_decl(ctx, decl as *FuncDecl);
    } else if (decl.kind == Decl_Global) {
        elab_global_decl(ctx, decl as *GlobalDecl);
    } else {
        unreachable("elab_decl");
    }
}

func elab(ast: *Ast): *List { // *List<*Sym>
    var ctx: *ElabCtx = calloc(1, sizeof(ElabCtx));
    *ctx = ElabCtx {
        syms: list_new(),
        scope: scope_new(null),
        current_func: null,
        loop_depth: 0,
        or_pattern_depth: 0,
    };

    for (var pass = 0; pass < 4; pass += 1) {
        for (var i = 0; i < list_len(ast.decls); i += 1) {
            var decl: *Decl = list_get(ast.decls, i);
            if (decl.kind == Decl_Record || decl.kind == Decl_Enum || decl.kind == Decl_Const) {
                if (pass == 0) {
                    seed_decl(ctx, decl);
                } else if (pass == 1) {
                    elab_decl(ctx, decl);
                }
            } else if (decl.kind == Decl_Func || decl.kind == Decl_Global) {
                if (pass == 2) {
                    seed_decl(ctx, decl);
                } else if (pass == 3) {
                    elab_decl(ctx, decl);
                }
            } else {
                unreachable("elab");
            }
        }
    }

    return ctx.syms;
}
