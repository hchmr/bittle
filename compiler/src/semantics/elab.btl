module elab;

import "../support/libc";
import "../support/utils";
import "../syntax/ast";
import "../syntax/tok";
import "const_value";
import "core";
import "sym";
import "type";

//==============================================================================
//== Scope

struct ScopeEntry {
    name: *Char,
    sym_index: Int,
}

struct Scope {
    entries: *mut List, // List<ScopeEntry>
    parent: *mut Scope,
}

func scope_new(parent: *mut Scope): *mut Scope {
    return box(sizeof(Scope), &Scope {
        entries: list_new(),
        parent: parent
    }) as *mut Scope;
}

func scope_drop(scope: *mut Scope) {
    free(scope.entries);
    free(scope);
}

func scope_lookup(scope: *mut Scope, name: *Char, max_depth: Int): Int {
    if (scope == null || max_depth == 0) {
        return -1;
    }
    for (var i = list_len(scope.entries) - 1; i >= 0; i -= 1) {
        var entry = list_get(scope.entries, i) as *mut ScopeEntry;
        if (str_eq(entry.name, name)) {
            return entry.sym_index;
        }
    }
    return scope_lookup(scope.parent, name, max_depth - 1);
}

//==============================================================================
//== Context

struct ElabCtx {
    imports: *mut List, // List<Module>
    syms: *mut List, // List<Sym>
    scope: *mut Scope,
    module_name: *Char,
    current_func: *mut FuncSym,
    loop_depth: Int,
    or_pattern_depth: Int,
}

func enter_scope(ctx: *mut ElabCtx) {
    ctx.scope = scope_new(ctx.scope);
}

func exit_scope(ctx: *mut ElabCtx) {
    var scope = ctx.scope;
    ctx.scope = scope.parent;
    scope_drop(scope);
}

//==============================================================================
//== Symbol declaration & lookup

func lookup_in_module_scope(ctx: *mut ElabCtx, name: *Char): *mut Sym {
    var sym_index = scope_lookup(ctx.scope, name, -1);
    if (sym_index == -1) {
        return null;
    }
    return list_get(ctx.syms, sym_index) as *mut Sym;
}

func lookup_in_imports(ctx: *mut ElabCtx, name: *Char, result: *mut *mut Sym): Int {
    var last_found: *mut Sym = null;
    var n_found = 0;
    for (var i = 0; i < list_len(ctx.imports); i += 1) {
        var mod = list_get(ctx.imports, i) as *Module;
        for (var j = 0; j < list_len(mod.syms); j += 1) {
            var sym = list_get(mod.syms, j) as *mut Sym;
            if (str_eq(sym.name, name)) {
                last_found = sym;
                n_found += 1;
                break;
            }
        }
    }
    if (n_found == 1) {
        *result = last_found;
    }
    return n_found;
}

func lookup(ctx: *mut ElabCtx, pos: *Pos, name: *Char): *mut Sym {
    var sym = lookup_in_module_scope(ctx, name);
    if (sym) {
        return sym;
    }
    match (lookup_in_imports(ctx, name, &sym)) {
        case 1: {
            return sym;
        }
        case 0: {
            die_at(pos, "Unknown symbol: %s", name);
        }
        case _: {
            die_at(pos, "Ambiguous symbol: %s", name);
        }
    }
}

func try_get_existing(ctx: *mut ElabCtx, name: *Char): *mut Sym {
    var sym_index = scope_lookup(ctx.scope, name, 1);
    if (sym_index == -1) {
        return null;
    }
    return list_get(ctx.syms, sym_index) as *mut Sym;
}

func add_sym(ctx: *mut ElabCtx, sym: *mut Sym) {
    var entry = box(sizeof(ScopeEntry), &ScopeEntry {
        name: sym.name,
        sym_index: list_len(ctx.syms)
    }) as *mut ScopeEntry;
    list_push(ctx.syms, sym);
    list_push(ctx.scope.entries, entry);
}

func declare_enum(ctx: *mut ElabCtx, pos: *Pos, name: *Char): *mut EnumSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Enum) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        return existing as *mut EnumSym;
    }

    var sym = box(sizeof(EnumSym), &EnumSym {
        name,
        is_defined: false,
        size: -1,
    }) as *mut Sym;
    add_sym(ctx, sym);
    return sym as *mut EnumSym;
}

func define_enum(ctx: *mut ElabCtx, pos: *Pos, sym: *mut EnumSym, size: Int) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }
    sym.size = size;
    sym.is_defined = true;
}

func declare_record(
    ctx: *mut ElabCtx,
    pos: *Pos,
    is_union: Bool,
    name: *Char,
): *mut RecordSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Record) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        return existing as *mut RecordSym;
    }

    var sym = box(sizeof(RecordSym), &RecordSym {
        name,
        is_defined: false,
        is_union,
        base: null,
        fields: null,
    }) as *mut Sym;
    add_sym(ctx, sym);
    return sym as *mut RecordSym;
}

func define_record(ctx: *mut ElabCtx, pos: *Pos, sym: *mut RecordSym) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }

    sym.is_defined = true;
}

func declare_const(ctx: *mut ElabCtx, pos: *Pos, name: *Char): *mut ConstSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Const) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        return existing as *mut ConstSym;
    }

    var sym = box(sizeof(ConstSym), &ConstSym {
        name,
        is_defined: false,
        value: null,
    }) as *mut Sym;
    add_sym(ctx, sym);
    return sym as *mut ConstSym;
}

func define_const(ctx: *mut ElabCtx, pos: *Pos, sym: *mut ConstSym, value: *ConstValue) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }
    sym.is_defined = true;
    sym.value = value;
}

func params_eq(xs: *mut List, ys: *mut List): Bool {
    if (list_len(xs) != list_len(ys)) {
        return false;
    }
    for (var i = 0; i < list_len(xs); i += 1) {
        var param1 = list_get(xs, i) as *mut FuncParam;
        var param2 = list_get(ys, i) as *mut FuncParam;
        if (!str_eq(param1.name, param2.name)) {
            return false;
        }
        if (!type_eq(param1.type, param2.type)) {
            return false;
        }
    }
    return true;
}

func declare_func(
    ctx: *mut ElabCtx,
    pos: *Pos,
    name: *Char,
    params: *mut List,
    rest_param: *mut RestParamDecl,
    return_type: *Type
): *mut FuncSym {
    var is_variadic = !!rest_param;

    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Func) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        var existing = existing as *mut FuncSym;
        if (!params_eq(existing.params, params)) {
            die_at(pos, "Symbol redeclared with different parameters");
        }
        if (is_variadic != existing.is_variadic) {
            die_at(pos, "Symbol redeclared with different variadicity");
        }
        if (
            is_variadic
            && !(
                !rest_param.name && !existing.rest_param_name
                || rest_param.name && existing.rest_param_name && str_eq(rest_param.name, existing.rest_param_name)
            )
        ) {
            die_at(pos, "Symbol redeclared with different rest parameter");
        }
        if (!type_eq(existing.return_type, return_type)) {
            die_at(pos, "Symbol redeclared with different return type");
        }
        return existing;
    }

    var sym = box(sizeof(FuncSym), &FuncSym {
        name,
        is_defined: false,
        params,
        return_type,
        is_variadic,
        rest_param_name: rest_param ? rest_param.name : null,
        locals: list_new(),
        temps: list_new(),
        body: null
    }) as *mut Sym;
    add_sym(ctx, sym);
    return sym as *mut FuncSym;
}

func define_func(ctx: *mut ElabCtx, pos: *Pos, sym: *mut FuncSym, body: *mut Stmt) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }
    sym.is_defined = true;
    sym.body = body;
}

func declare_global(ctx: *mut ElabCtx, pos: *Pos, name: *Char, type: *Type): *mut GlobalSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Global) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        var existing = existing as *mut GlobalSym;
        if (!type_eq(existing.type, type)) {
            die_at(pos, "Symbol redeclared with different type");
        }
        return existing;
    }

    var sym = box(sizeof(GlobalSym), &GlobalSym {
        name,
        type,
        is_defined: false,
    }) as *mut Sym;
    add_sym(ctx, sym);
    return sym as *mut GlobalSym;
}

func define_global(ctx: *mut ElabCtx, pos: *Pos, sym: *mut GlobalSym) {
    if (sym.is_defined) {
        die_at(pos, "Symbol is already defined");
    }
    sym.is_defined = true;
}

func define_local(ctx: *mut ElabCtx, pos: *Pos, name: *Char, type: *Type): *mut LocalSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        if (existing.kind != Sym_Local) {
            die_at(pos, "Another symbol with the same name already exists");
        } else {
            // Shadowing an existing local variable is allowed
        }
    }

    var slot_id = list_len(ctx.current_func.locals);

    var sym = box(sizeof(LocalSym), &LocalSym {
        name,
        is_defined: true,
        type,
        slot_id,
        is_indirect: false,
    }) as *mut Sym;
    add_sym(ctx, sym);
    list_push(ctx.current_func.locals, sym);

    return sym as *mut LocalSym;
}

func define_params(ctx: *mut ElabCtx, param_decls: *mut List, params: *mut List) {
    for (var i = 0; i < list_len(params); i += 1) {
        var param_decl = list_get(param_decls, i) as *mut FuncParamDecl;
        var param = list_get(params, i) as *mut FuncParam;
        define_local(ctx, &param_decl.pos, param.name, param.type);
    }
}

//==============================================================================
//== Type checking

func report_type_mismatch(pos: *Pos, expected: *Type, actual: *Type) {
    die_at(pos, "Type mismatch. Expected '%s', got '%s'", pretty_type(expected), pretty_type(actual));
}

func try_coerce_expr_with_cast(e: *mut Expr, target: *Type, out: *mut *mut Expr): Bool {
    if (!type_implicitly_castable(e.type, target)) {
        return false;
    }

    var const_value: *ConstValue = null;
    if (e.const_value) {
        const_value = const_value_cast(e.const_value, target);
    }

    var cast = box(sizeof(CastExpr), &CastExpr {
        pos: e.pos,
        type: target,
        const_value,
        expr: e,
        type_expr: null
    }) as *mut Expr;
    *out = cast;
    return true;
}

/*
    Desugar
        x: MyUnion = 123
    to
        x: MyUnion = MyUnion { field: 123 }
*/
func try_coerce_expr_to_union(e: *mut Expr, target: *Type, out: *mut *mut Expr): Bool {
    if (target.kind != Type_Record) {
        return false;
    }

    var target = target as *RecordType;
    if (!target.sym.is_union) {
        return false;
    }

    var sym = target.sym;

    var field_index = find_record_field_by_type(sym, e.type);
    if (field_index == -1) {
        return false;
    }

    var field = list_get(sym.fields, field_index) as *mut RecordField;

    var field_init = box(sizeof(FieldInitializer), &FieldInitializer {
        pos: e.pos,
        name: field.name,
        expr: e
    }) as *mut FieldInitializer;

    var field_inits = list_new();
    list_push(field_inits, field_init);

    var record_expr = box(sizeof(RecordExpr), &RecordExpr {
        pos: e.pos,
        type: target,
        const_value: null,
        name: sym.name,
        fields: field_inits,
    }) as *mut Expr;
    *out = record_expr;
    return true;
}

func try_coerce_expr(e: *mut Expr, target: *Type, out: *mut *mut Expr): Bool {
    return type_eq(e.type, target)
        || try_coerce_expr_with_cast(e, target, out)
        || try_coerce_expr_to_union(e, target, out);
}

func try_coerce_expr_to_int(e: *mut Expr, out: *mut *mut Expr): Bool {
    var target_type: *Type = null;
    for (var size = 1; size <= 8; size *= 2) {
        target_type = mk_int_type(size);
        if (try_coerce_expr_with_cast(e, target_type, out)) {
            return true;
        }
    }
    return false;
}

func check_expr_type(e: *mut *mut Expr, expected: *Type) {
    try_coerce_expr(*e, expected, e);
    if (!type_eq((*e).type, expected)) {
        report_type_mismatch(&(*e).pos, expected, (*e).type);
    }
}

func check_expr_type_int(e: *mut *mut Expr) {
    if (!try_coerce_expr_to_int(*e, e)) {
        die_at(&(*e).pos, "Integer expression expected");
    }
}

func check_expr_type_bool(e: *mut *mut Expr) {
    check_expr_type(e, mk_bool_type());
}

func unify_expr_types_with_coersion(e1: *mut *mut Expr, e2: *mut *mut Expr) {
    try_coerce_expr(*e2, (*e1).type, e2);
    try_coerce_expr(*e1, (*e2).type, e1);
    check_expr_type(e2, (*e1).type);
}

func check_pattern_type(p: *mut Pattern, expected: *Type) {
    if (!type_eq(p.type, expected)) {
        report_type_mismatch(&p.pos, expected, p.type);
    }
}

func check_pattern_type_int(p: *mut Pattern) {
    if (p.type.kind != Type_Int) {
        die_at(&(*p).pos, "Integer pattern expected");
    }
}

//==============================================================================
//== Types

func eval_type(ctx: *mut ElabCtx, type_expr: *mut TypeExpr): *Type {
    match (type_expr.kind) {
        case TypeExpr_Named: {
            var name = (type_expr as *NamedTypeExpr).name;
            if (str_eq(name, "Void")) {
                return mk_void_type();
            } else if (str_eq(name, "Bool")) {
                return mk_bool_type();
            } else if (str_eq(name, "Char") || str_eq(name, "Int8")) {
                return mk_int_type(1);
            } else if (str_eq(name, "Int16")) {
                return mk_int_type(2);
            } else if (str_eq(name, "Int32")) {
                return mk_int_type(4);
            } else if (str_eq(name, "Int") || str_eq(name, "Int64")) {
                return mk_int_type(8);
            } else {
                var sym = lookup(ctx, &type_expr.pos, name);
                match (sym.kind) {
                    case Sym_Enum: {
                        return mk_enum_type(sym as *mut EnumSym);
                    }
                    case Sym_Record: {
                        return mk_record_type(sym as *mut RecordSym);
                    }
                    case _: {
                        die_at(&type_expr.pos, "Expected a type");
                    }
                }
            }
        }
        case TypeExpr_Ptr: {
            var type_expr = type_expr as *mut PtrTypeExpr;
            var pointee = eval_type(ctx, type_expr.pointee);
            return mk_ptr_type(pointee, is_mut: type_expr.is_mut);
        }
        case TypeExpr_Arr: {
            var type_expr = type_expr as *mut ArrTypeExpr;
            var elem = eval_type(ctx, type_expr.elem);
            var size = const_eval_int64(ctx, type_expr.size);
            return mk_array_type(elem, size);
        }
        case TypeExpr_Never: {
            return mk_never_type();
        }
        case TypeExpr_Typeof: {
            var type_expr = type_expr as *TypeofTypeExpr;
            elab_expr_infer(ctx, type_expr.expr, type_hint: null);
            return type_expr.expr.type;
        }
        case TypeExpr_RestParam: {
            return mk_rest_param_type();
        }
        case other @ _: {
            unreachable_enum_case("eval_type", other);
        }
    }
}

func const_eval_infer(ctx: *mut ElabCtx, expr: *mut Expr, type_hint: *Type): *ConstValue {
    elab_expr_infer(ctx, expr, type_hint);
    if (!expr.const_value) {
        die_at(&expr.pos, "Expected a constant expression");
    }
    return expr.const_value;
}

func const_eval_expect(ctx: *mut ElabCtx, expr: *mut Expr, expected: *Type): *ConstValue {
    elab_expr_expect(ctx, &expr, expected);
    if (!expr.const_value) {
        die_at(&expr.pos, "Expected a constant expression");
    }
    return expr.const_value;
}

func const_eval_int64(ctx: *mut ElabCtx, expr: *mut Expr): Int {
    return (const_eval_expect(ctx, expr, mk_int_type(8)) as *IntConstValue).int;
}

func const_eval_int32(ctx: *mut ElabCtx, expr: *mut Expr): Int32 {
    return (const_eval_expect(ctx, expr, mk_int_type(4)) as *IntConstValue).int as Int32;
}

//==============================================================================
//== Literals

func elab_literal(ctx: *mut ElabCtx, literal: *Literal, type_hint: *Type): *ConstValue {
    match (literal.kind) {
        case Literal_Null: {
            var type = type_hint && type_hint.kind == Type_Ptr ? type_hint : mk_ptr_type(mk_void_type(), is_mut: true);
            return mk_null_const_value(type);
        }
        case Literal_Bool: {
            var literal = literal as *BoolLiteral;
            return mk_bool_const_value(literal.value);
        }
        case Literal_Int: {
            var literal = literal as *IntLiteral;
            var type = type_hint && type_hint.kind == Type_Int ? type_hint : mk_int_type(8);
            return mk_int_const_value(literal.value, type);
        }
        case Literal_Char: {
            var literal = literal as *CharLiteral;
            return mk_int_const_value(literal.value, mk_int_type(1));
        }
        case Literal_String: {
            var literal = literal as *StringLiteral;
            return mk_string_const_value(literal.value);
        }
        case other @ _: {
            unreachable_enum_case("elab_literal", other);
        }
    }
}

//==============================================================================
//== Patterns

func elab_pattern_expect(ctx: *mut ElabCtx, pattern: *mut Pattern, expected: *Type) {
    elab_pattern_infer(ctx, pattern, expected);
    check_pattern_type(pattern, expected);
}

func elab_grouped_pattern(ctx: *mut ElabCtx, pattern: *mut GroupedPattern, type_hint: *Type) {
    elab_pattern_infer(ctx, pattern.pattern, type_hint);
    pattern.type = pattern.pattern.type;
}

func elab_literal_pattern(ctx: *mut ElabCtx, pattern: *mut LiteralPattern, type_hint: *Type) {
    var literal = pattern.literal;
    pattern.value = elab_literal(ctx, literal, type_hint);
    pattern.type = pattern.value.type;
}

func elab_name_pattern(ctx: *mut ElabCtx, pattern: *mut NamePattern, type_hint: *Type) {
    var name = pattern.name;

    var sym = lookup(ctx, &pattern.pos, name);
    if (sym.kind != Sym_Const) {
        die_at(&pattern.pos, "Expected a constant");
    }

    pattern.sym = sym as *mut ConstSym;
    pattern.type = pattern.sym.value.type;
}

func elab_wildcard_pattern(ctx: *mut ElabCtx, pattern: *mut WildcardPattern, type_hint: *Type) {
    pattern.type = type_hint;
}

func elab_var_pattern(ctx: *mut ElabCtx, pattern: *mut VarPattern, type_hint: *Type) {
    var name = pattern.name;

    elab_pattern_infer(ctx, pattern.pattern, type_hint);

    if (ctx.or_pattern_depth > 0) {
        die_at(&pattern.pos, "Variable pattern not allowed in 'or' pattern");
    }

    var sym = define_local(ctx, &pattern.pos, name, type_hint);

    pattern.sym = sym;
    pattern.type = sym.type;
}

func elab_range_pattern(ctx: *mut ElabCtx, pattern: *mut RangePattern, type_hint: *Type) {
    if (!pattern.lower && !pattern.upper) {
        die_at(&pattern.pos, "Range pattern must have at least one bound");
    }

    var lower_bound = pattern.lower ? const_eval_infer(ctx, pattern.lower, type_hint) : null;
    var upper_bound = pattern.upper ? const_eval_infer(ctx, pattern.upper, type_hint) : null;

    var lower_type = lower_bound ? lower_bound.type : upper_bound.type;
    var upper_type = upper_bound ? upper_bound.type : lower_bound.type;
    if (!type_eq(lower_type, upper_type)) {
        report_type_mismatch(&pattern.pos, lower_type, upper_type);
    }

    var type = lower_bound ? lower_bound.type : upper_bound.type;
    if (type.kind != Type_Int) {
        die_at(&pattern.pos, "Integer range pattern expected");
    }

    pattern.lower_value = lower_bound;
    pattern.upper_value = upper_bound;
    pattern.type = type;
}

func elab_or_pattern(ctx: *mut ElabCtx, pattern: *mut OrPattern, type_hint: *Type) {
    ctx.or_pattern_depth += 1;

    var patterns = pattern.patterns;

    var first_pattern = list_get(patterns, 0) as *mut Pattern;
    elab_pattern_infer(ctx, first_pattern, type_hint);

    for (var i = 1; i < list_len(patterns); i += 1) {
        var next_pattern = list_get(patterns, i) as *mut Pattern;
        elab_pattern_expect(ctx, next_pattern, first_pattern.type);
    }

    pattern.type = first_pattern.type;

    ctx.or_pattern_depth -= 1;
}

func elab_pattern_infer(ctx: *mut ElabCtx, pattern: *mut Pattern, type_hint: *Type) {
    match (pattern.kind) {
        case Pattern_Grouped: {
            elab_grouped_pattern(ctx, pattern as *mut GroupedPattern, type_hint);
        }
        case Pattern_Literal: {
            elab_literal_pattern(ctx, pattern as *mut LiteralPattern, type_hint);
        }
        case Pattern_Name: {
            elab_name_pattern(ctx, pattern as *mut NamePattern, type_hint);
        }
        case Pattern_Wildcard: {
            elab_wildcard_pattern(ctx, pattern as *mut WildcardPattern, type_hint);
        }
        case Pattern_Var: {
            elab_var_pattern(ctx, pattern as *mut VarPattern, type_hint);
        }
        case Pattern_Range: {
            elab_range_pattern(ctx, pattern as *mut RangePattern, type_hint);
        }
        case Pattern_Or: {
            elab_or_pattern(ctx, pattern as *mut OrPattern, type_hint);
        }
        case other @ _: {
            unreachable_enum_case("elab_pattern_infer", other);
        }
    }
    assert(pattern.type, "elab_pattern_infer");
}

//==============================================================================
//== Expressions

func elab_expr_expect(ctx: *mut ElabCtx, expr: *mut *mut Expr, expected: *Type) {
    elab_expr_infer(ctx, *expr, type_hint: expected);
    check_expr_type(expr, expected);
}

func elab_expr_bool(ctx: *mut ElabCtx, expr: *mut *mut Expr) {
    elab_expr_expect(ctx, expr, mk_bool_type());
}

func elab_expr_int(ctx: *mut ElabCtx, expr: *mut *mut Expr, type_hint: *Type) {
    elab_expr_infer(ctx, *expr, type_hint);
    check_expr_type_int(expr);
}

func elab_ident_expr(ctx: *mut ElabCtx, expr: *mut IdentExpr) {
    var sym = lookup(ctx, &expr.pos, expr.name);
    var type: *Type;
    var const_val: *ConstValue = null;
    match (sym.kind) {
        case Sym_Local: {
            type = (sym as *mut LocalSym).type;
        }
        case Sym_Global: {
            type = (sym as *mut GlobalSym).type;
        }
        case Sym_Const: {
            var sym = sym as *mut ConstSym;
            type = sym.value.type;
            const_val = sym.value;
        }
        case _: {
            die_at(&expr.pos, "Expected a variable or constant");
        }
    }

    expr.sym = sym;
    expr.type = type;
    expr.const_value = const_val;
}

func elab_literal_expr(ctx: *mut ElabCtx, expr: *mut LiteralExpr, type_hint: *Type) {
    var literal = expr.literal;
    expr.const_value = elab_literal(ctx, literal, type_hint);
    expr.type = expr.const_value.type;
}

func elab_array_expr(ctx: *mut ElabCtx, expr: *mut ArrayExpr, type_hint: *Type) {
    var elem_type_hint: *Type = null;
    if (type_hint && type_hint.kind == Type_Arr) {
        elem_type_hint = (type_hint as *ArrType).elem;
    }

    var elems = expr.elems;

    var elem_type: *Type = null;
    var elem_count = list_len(elems);

    for (var i = 0; i < elem_count; i += 1) {
        var elem = list_get(elems, i) as *mut Expr;
        elab_expr_infer(ctx, elem, elem_type_hint);
        if (i == 0) {
            elem_type = elem.type;
        } else {
            var prev_expr = list_get(elems, i - 1) as *mut Expr;
            check_expr_type(&elem, elem_type);
            list_set(elems, i, elem);
            list_set(elems, i - 1, prev_expr);
        }
    }

    if (!elem_type) {
        die_at(&expr.pos, "Empty array");
    }

    if (!is_sized(elem_type)) {
        die_at(&expr.pos, "Array element type is not sized");
    }

    expr.type = mk_array_type(elem_type, elem_count);
}

func elab_call_expr(ctx: *mut ElabCtx, expr: *mut CallExpr) {
    var callee = expr.callee;
    var args = expr.args;

    if (callee.kind != Expr_Ident) {
        die_at(&callee.pos, "Expected function name");
    }
    var sym = lookup(ctx, &(callee as *IdentExpr).pos, (callee as *IdentExpr).name);
    if (sym.kind != Sym_Func) {
        die_at(&callee.pos, "Expected a function");
    }
    var sym = sym as *mut FuncSym;

    var param_count = list_len(sym.params);
    var arg_count = list_len(args);

    var is_initialized = calloc(param_count, sizeof(*Bool)) as *mut Bool;
    var seen_named_arg = false;

    for (var i = 0; i < arg_count; i += 1) {
        var arg = list_get(args, i) as *mut CallArg;
        if (arg.label) {
            var param_index = find_param_by_name(sym, arg.label);
            if (param_index == -1) {
                die_at(&arg.expr.pos, "Unknown parameter '%s'", arg.label);
            } else if (is_initialized[param_index]) {
                die_at(&arg.expr.pos, "Parameter '%s' is already initialized", arg.label);
            }
            var param = list_get(sym.params, param_index) as *mut FuncParam;
            elab_expr_expect(ctx, &arg.expr, param.type);

            is_initialized[param_index] = true;
            arg.positional_index = param_index;
            seen_named_arg = true;
        } else if (seen_named_arg) {
            die_at(&arg.expr.pos, "Positional argument cannot follow a named argument");
        } else if (i >= param_count) {
            if (!sym.is_variadic) {
                die_at(&arg.expr.pos, "Too many arguments provided");
            }
            elab_expr_infer(ctx, arg.expr, type_hint: null);
            if (!is_sized(arg.expr.type)) {
                die_at(&arg.expr.pos, "Cannot pass an unsized type as a variadic argument");
            }
            arg.positional_index = i;
        } else {
            var param = list_get(sym.params, i) as *mut FuncParam;
            elab_expr_expect(ctx, &arg.expr, param.type);

            is_initialized[i] = true;
            arg.positional_index = i;
        }
    }

    for (var i = 0; i < param_count; i += 1) {
        var param = list_get(sym.params, i) as *mut FuncParam;
        if (!is_initialized[i] && !param.default_value) {
            var param = list_get(sym.params, i) as *mut FuncParam;
            die_at(&expr.pos, "Parameter '%s' is not initialized", param.name);
        }
    }

    expr.resolved_callee = sym;
    expr.type = sym.return_type;
}

func elab_index_expr(ctx: *mut ElabCtx, expr: *mut IndexExpr) {
    var indexee = expr.indexee;
    var index = expr.index;

    elab_expr_infer(ctx, indexee, type_hint: null);
    elab_expr_infer(ctx, index, type_hint: null);

    var indexee_type = indexee.type;
    if (indexee_type.kind != Type_Arr && indexee_type.kind != Type_Ptr) {
        die_at(&indexee.pos, "Expression is not indexable");
    }

    var elem_type = indexee_type.kind == Type_Arr
    ? (indexee_type as *ArrType).elem
    : (indexee_type as *PtrType).pointee;

    check_expr_type_int(&index);
    expr.type = elem_type;
    expr.index = index;
}

func elab_member_expr(ctx: *mut ElabCtx, expr: *mut MemberExpr) {
    var left = expr.left;
    var field_name = expr.name;

    elab_expr_infer(ctx, left, type_hint: null);

    var left_type = left.type;
    if (left_type.kind == Type_Ptr) {
        left_type = (left_type as *PtrType).pointee;
    }
    if (left_type.kind != Type_Record) {
        die_at(&left.pos, "Expected a record");
    }
    var left_type = left_type as *RecordType;

    var record_sym = left_type.sym;
    var field_index = find_record_field_by_name(record_sym, field_name);
    if (field_index == -1) {
        die_at(&expr.pos, "Unknown field");
    }

    var field = list_get(record_sym.fields, field_index) as *mut RecordField;
    expr.resolved_field = field;
    expr.type = field.type;
}

func elab_sizeof_expr(ctx: *mut ElabCtx, expr: *mut SizeofExpr) {
    var type = eval_type(ctx, expr.type_expr);
    var size = type_size(type);
    if (size == -1) {
        die_at(&expr.pos, "Size of type cannot be determined");
    }
    expr.size = size;
    expr.type = mk_int_type(8);
    expr.const_value = mk_int_const_value(size, expr.type);
}

func elab_unary_expr(ctx: *mut ElabCtx, expr: *mut UnaryExpr, type_hint: *Type) {
    var op = expr.op;
    var right = expr.right;

    match (op) {
        case Tok_Minus | Tok_Tilde: {
            elab_expr_infer(ctx, right, type_hint);
            check_expr_type_int(&right);
            expr.type = right.type;
            expr.right = right;
        }
        case Tok_Bang: {
            elab_expr_bool(ctx, &right);
            expr.type = mk_bool_type();
            expr.right = right;
        }
        case Tok_Star: {
            var right_type_hint = mk_ptr_type(type_hint, is_mut: true);
            elab_expr_infer(ctx, right, type_hint: right_type_hint);
            var pointee_type = right.type;
            if (pointee_type.kind != Type_Ptr) {
                die_at(&right.pos, "Expected a pointer");
            }
            expr.type = (pointee_type as *PtrType).pointee;
        }
        case Tok_Amp: {
            var right_type_hint: *Type = null;
            if (right_type_hint && type_hint.kind == Type_Ptr) {
                right_type_hint = (type_hint as *PtrType).pointee;
            }
            elab_expr_infer(ctx, right, right_type_hint);
            var is_mut = is_mutable_lvalue(right);
            expr.type = mk_ptr_type(right.type, is_mut);
        }
        case other @ _: {
            unreachable_enum_case("elab_unary_expr", other);
        }
    }
    if (right.const_value) {
        expr.const_value = const_value_unop(op, right.const_value);
    }
}

func elab_binary_expr(ctx: *mut ElabCtx, expr: *mut BinaryExpr, type_hint: *Type) {
    var op = expr.op;
    var left = expr.left;
    var right = expr.right;

    match (op) {
        case Tok_Eq | Tok_AmpEq | Tok_BarEq | Tok_CaretEq | Tok_LtLtEq | Tok_GtGtEq | Tok_PlusEq | Tok_MinusEq | Tok_StarEq | Tok_SlashEq | Tok_PercentEq: {
            elab_expr_infer(ctx, left, type_hint: null);
            if (op != Tok_Eq) {
                if (expr.left.type.kind != Type_Int) {
                    die_at(&left.pos, "Left operand is not an integer expression");
                }
            }
            elab_expr_expect(ctx, &right, left.type);
            if (!is_lvalue(left)) {
                die_at(&left.pos, "L-value expected");
            }
            if (!is_sized(left.type)) {
                die_at(&left.pos, "Cannot assign to an unsized type");
            }
            if (!is_lvalue(left)) {
                die_at(&left.pos, "L-value expected");
            }
            if (!is_mutable_lvalue(left)) {
                die_at(&left.pos, "Target is not mutable");
            }
            expr.type = mk_void_type();
            expr.left = left;
            expr.right = right;
        }
        case Tok_AmpAmp | Tok_BarBar: {
            elab_expr_bool(ctx, &left);
            elab_expr_bool(ctx, &right);
            expr.type = mk_bool_type();
            expr.left = left;
            expr.right = right;
        }
        case Tok_EqEq | Tok_BangEq | Tok_Lt | Tok_LtEq | Tok_Gt | Tok_GtEq: {
            elab_expr_infer(ctx, left, type_hint: null);
            elab_expr_infer(ctx, right, type_hint: left.type);
            unify_expr_types_with_coersion(&left, &right);
            if (!is_scalar(left.type)) {
                die_at(&left.pos, "Operands type is not comparable");
            }
            expr.type = mk_bool_type();
            expr.left = left;
            expr.right = right;
        }
        case Tok_Amp | Tok_Bar | Tok_Caret | Tok_LtLt | Tok_GtGt | Tok_Plus | Tok_Minus | Tok_Star | Tok_Slash | Tok_Percent: {
            elab_expr_int(ctx, &left, type_hint);
            elab_expr_int(ctx, &right, left.type);
            unify_expr_types_with_coersion(&left, &right);
            expr.type = left.type;
            expr.left = left;
            expr.right = right;
        }
        case other @ _: {
            unreachable_enum_case("elab_binary_expr", other);
        }
    }
    if (left.const_value && right.const_value) {
        expr.const_value = const_value_binop(op, left.const_value, right.const_value);
    }
}

func elab_ternary_expr(ctx: *mut ElabCtx, expr: *mut TernaryExpr, type_hint: *Type) {
    var cond = expr.cond;
    var then_expr = expr.then_expr;
    var else_expr = expr.else_expr;

    elab_expr_bool(ctx, &cond);
    elab_expr_infer(ctx, then_expr, type_hint: type_hint);
    elab_expr_infer(ctx, else_expr, type_hint: then_expr.type);

    unify_expr_types_with_coersion(&then_expr, &else_expr);
    expr.type = then_expr.type;
    expr.cond = cond;
    expr.then_expr = then_expr;
    expr.else_expr = else_expr;
    if (cond.const_value) {
        expr.const_value = const_value_ternop(cond.const_value, then_expr.const_value, else_expr.const_value);
    }
}

// `x is <pattern>`
func elab_is_expr(ctx: *mut ElabCtx, expr: *mut IsExpr) {
    var left = expr.left;
    var pattern = expr.pattern;

    elab_expr_infer(ctx, left, type_hint: null);
    elab_pattern_expect(ctx, pattern, left.type);

    expr.type = mk_bool_type();
}

func elab_cast_expr(ctx: *mut ElabCtx, expr: *mut CastExpr) {
    var subexpr = expr.expr;
    elab_expr_infer(ctx, subexpr, type_hint: null);

    var source_type = subexpr.type;
    var target_type = eval_type(ctx, expr.type_expr);

    if (!type_castable(source_type, target_type)) {
        die_at(&expr.pos, "Invalid cast. Cannot cast from '%s' to '%s'", pretty_type(source_type), pretty_type(target_type));
    }

    expr.type = target_type;

    if (subexpr.const_value) {
        expr.const_value = const_value_cast(subexpr.const_value, target_type);
    }
}

func elab_record_expr(ctx: *mut ElabCtx, expr: *mut RecordExpr, type_hint: *Type) {
    var sym = lookup(ctx, &expr.pos, expr.name);
    if (sym.kind != Sym_Record) {
        die_at(&expr.pos, "Expected a record type");
    }
    var sym = sym as *mut RecordSym;
    if (!sym.is_defined) {
        die_at(&expr.pos, "Record has incomplete type");
    }

    var fields = sym.fields;
    var n_fields = list_len(fields);

    var initializers = expr.fields;
    var n_initializers = list_len(initializers);

    var is_initialized = calloc(n_fields, sizeof(*Bool)) as *mut Bool;

    for (var i = 0; i < n_initializers; i += 1) {
        var initializer = list_get(initializers, i) as *mut FieldInitializer;
        var field_name = initializer.name;
        var field_index = find_record_field_by_name(sym, field_name);
        if (field_index == -1) {
            die_at(&initializer.pos, "Unknown field");
        }
        var field = list_get(fields, field_index) as *mut RecordField;

        if (is_initialized[field_index]) {
            die_at(&initializer.pos, "Field is already initialized");
        }
        is_initialized[field_index] = true;
        elab_expr_expect(ctx, &initializer.expr, field.type);
    }

    for (var i = 0; i < n_fields; i += 1) {
        var field = list_get(fields, i) as *mut RecordField;
        is_initialized[i] = is_initialized[i] || field.default_value;
    }

    if (!sym.is_union) {
        for (var i = 0; i < n_fields; i += 1) {
            if (!is_initialized[i]) {
                var field = list_get(fields, i) as *mut RecordField;
                die_at(&expr.pos, "Field '%s' is not initialized.", field.name);
            }
        }
    } else {
        if (n_initializers == 0) {
            die_at(&expr.pos, "No field is initialized.");
        } else if (n_initializers > 1) {
            die_at(&expr.pos, "Only one field can be initialized in a union");
        }
    }

    free(is_initialized);

    expr.type = mk_record_type(sym);
}

func elab_expr_infer(ctx: *mut ElabCtx, expr: *mut Expr, type_hint: *Type) {
    match (expr.kind) {
        case Expr_Ident: {
            elab_ident_expr(ctx, expr as *mut IdentExpr);
        }
        case Expr_Literal: {
            elab_literal_expr(ctx, expr as *mut LiteralExpr, type_hint);
        }
        case Expr_Array: {
            elab_array_expr(ctx, expr as *mut ArrayExpr, type_hint);
        }
        case Expr_Call: {
            elab_call_expr(ctx, expr as *mut CallExpr);
        }
        case Expr_Index: {
            elab_index_expr(ctx, expr as *mut IndexExpr);
        }
        case Expr_Member: {
            elab_member_expr(ctx, expr as *mut MemberExpr);
        }
        case Expr_Sizeof: {
            elab_sizeof_expr(ctx, expr as *mut SizeofExpr);
        }
        case Expr_Unary: {
            elab_unary_expr(ctx, expr as *mut UnaryExpr, type_hint);
        }
        case Expr_Binary: {
            elab_binary_expr(ctx, expr as *mut BinaryExpr, type_hint);
        }
        case Expr_Ternary: {
            elab_ternary_expr(ctx, expr as *mut TernaryExpr, type_hint);
        }
        case Expr_Is: {
            elab_is_expr(ctx, expr as *mut IsExpr);
        }
        case Expr_Cast: {
            elab_cast_expr(ctx, expr as *mut CastExpr);
        }
        case Expr_Record: {
            elab_record_expr(ctx, expr as *mut RecordExpr, type_hint);
        }
        case other @ _: {
            unreachable_enum_case("elab_expr_infer", other);
        }
    }
    assert(expr.type, "elab_expr_infer");
}

//==============================================================================
//== Statements

func elab_stmt_with_scope(ctx: *mut ElabCtx, stmt: *mut Stmt) {
    enter_scope(ctx);
    elab_stmt(ctx, stmt);
    exit_scope(ctx);
}

func elab_block_stmt(ctx: *mut ElabCtx, stmt: *mut BlockStmt) {
    enter_scope(ctx);
    for (var i = 0; i < list_len(stmt.stmts); i += 1) {
        var stmt = list_get(stmt.stmts, i) as *mut Stmt;
        elab_stmt(ctx, stmt);
    }
    exit_scope(ctx);
}

func elab_const_stmt(ctx: *mut ElabCtx, stmt: *mut ConstStmt) {
    var decl = stmt.decl;
    seed_const_decl(ctx, decl);
    elab_const_decl(ctx, decl);
}

func elab_local_stmt(ctx: *mut ElabCtx, stmt: *mut LocalStmt) {
    var name = stmt.name;
    var typeExpr = stmt.type;
    var init = stmt.init;

    var type = typeExpr ? eval_type(ctx, typeExpr) : null;
    if (init) {
        if (!type) {
            elab_expr_infer(ctx, init, type_hint: null);
            type = init.type;
        } else {
            elab_expr_expect(ctx, &init, type);
            stmt.init = init;
        }
    } else {
        if (!type) {
            die_at(&stmt.pos, "Type required when no initializer is provided");
        }
    }

    if (!is_sized(type)) {
        die_at(&stmt.pos, "Variable must have a size.");
    }

    var sym = define_local(ctx, &stmt.pos, name, type);
    stmt.sym = sym;
}

func elab_if_stmt(ctx: *mut ElabCtx, stmt: *mut IfStmt) {
    var cond = stmt.cond;
    var then_stmt = stmt.then_stmt;
    var else_stmt = stmt.else_stmt;

    elab_expr_bool(ctx, &cond);
    stmt.cond = cond;

    elab_stmt_with_scope(ctx, then_stmt);
    if (else_stmt) {
        elab_stmt_with_scope(ctx, else_stmt);
    }
}

func elab_match_case(ctx: *mut ElabCtx, match_case: *mut MatchCase, scrutinee_type: *Type) {
    var pattern = match_case.pattern;
    var guard = match_case.guard;
    var body = match_case.body;

    enter_scope(ctx);
    elab_pattern_expect(ctx, pattern, scrutinee_type);
    if (guard) {
        elab_expr_bool(ctx, &guard);
    }
    elab_stmt_with_scope(ctx, body);
    exit_scope(ctx);

    match_case.guard = guard;
}

func elab_match_stmt(ctx: *mut ElabCtx, stmt: *mut MatchStmt) {
    var scrutinee = stmt.scrutinee;
    var match_cases = stmt.cases;

    elab_expr_infer(ctx, scrutinee, type_hint: null);

    for (var i = 0; i < list_len(match_cases); i += 1) {
        var match_case = list_get(match_cases, i) as *mut MatchCase;
        elab_match_case(ctx, match_case, scrutinee.type);
    }
}

func elab_while_stmt(ctx: *mut ElabCtx, stmt: *mut WhileStmt) {
    var cond = stmt.cond;
    var body = stmt.body;

    elab_expr_bool(ctx, &cond);
    stmt.cond = cond;

    ctx.loop_depth += 1;
    elab_stmt_with_scope(ctx, body);
    ctx.loop_depth -= 1;
}

func elab_for_stmt(ctx: *mut ElabCtx, stmt: *mut ForStmt) {
    var init = stmt.init;
    var cond = stmt.cond;
    var step = stmt.step;
    var body = stmt.body;

    enter_scope(ctx);

    if (init) {
        elab_stmt(ctx, init);
    }
    if (cond) {
        elab_expr_bool(ctx, &cond);
        stmt.cond = cond;
    }
    if (step) {
        elab_expr_infer(ctx, step, type_hint: null);
    }

    ctx.loop_depth += 1;
    elab_stmt_with_scope(ctx, body);
    ctx.loop_depth -= 1;

    exit_scope(ctx);
}

func elab_return_stmt(ctx: *mut ElabCtx, stmt: *mut ReturnStmt) {
    var return_expr = stmt.expr;

    var return_type = ctx.current_func.return_type;
    if (return_expr) {
        elab_expr_expect(ctx, &return_expr, return_type);
        stmt.expr = return_expr;
    } else if (return_type.kind != Type_Void) {
        die_at(&stmt.pos, "Missing return value");
    }
}

func elab_break_stmt(ctx: *mut ElabCtx, stmt: *mut BreakStmt) {
    if (!ctx.loop_depth) {
        die_at(&stmt.pos, "Break statement outside of loop");
    }
}

func elab_continue_stmt(ctx: *mut ElabCtx, stmt: *mut ContinueStmt) {
    if (!ctx.loop_depth) {
        die_at(&stmt.pos, "Continue statement outside of loop");
    }
}

func elab_expr_stmt(ctx: *mut ElabCtx, stmt: *mut ExprStmt) {
    var expr = stmt.expr;
    elab_expr_infer(ctx, expr, type_hint: null);
}

func elab_stmt(ctx: *mut ElabCtx, stmt: *mut Stmt) {
    match (stmt.kind) {
        case Stmt_Block: {
            elab_block_stmt(ctx, stmt as *mut BlockStmt);
        }
        case Stmt_Const: {
            elab_const_stmt(ctx, stmt as *mut ConstStmt);
        }
        case Stmt_Local: {
            elab_local_stmt(ctx, stmt as *mut LocalStmt);
        }
        case Stmt_If: {
            elab_if_stmt(ctx, stmt as *mut IfStmt);
        }
        case Stmt_Match: {
            elab_match_stmt(ctx, stmt as *mut MatchStmt);
        }
        case Stmt_While: {
            elab_while_stmt(ctx, stmt as *mut WhileStmt);
        }
        case Stmt_For: {
            elab_for_stmt(ctx, stmt as *mut ForStmt);
        }
        case Stmt_Return: {
            elab_return_stmt(ctx, stmt as *mut ReturnStmt);
        }
        case Stmt_Break: {
            elab_break_stmt(ctx, stmt as *mut BreakStmt);
        }
        case Stmt_Continue: {
            elab_continue_stmt(ctx, stmt as *mut ContinueStmt);
        }
        case Stmt_Expr: {
            elab_expr_stmt(ctx, stmt as *mut ExprStmt);
        }
        case other @ _: {
            unreachable_enum_case("elab_stmt", other);
        }
    }
}

//==============================================================================
//== Top-level declarations

func seed_enum_member(ctx: *mut ElabCtx, decl: *mut EnumMember) {
    decl.sym = declare_const(ctx, &decl.pos, decl.name);
}

func elab_enum_member(ctx: *mut ElabCtx, decl: *mut EnumMember, type: *Type, next_value: Int32): Int32 {
    var value = next_value;
    if (decl.value) {
        value = const_eval_int32(ctx, decl.value);
    }

    var const_value = mk_int_const_value(value, type);
    define_const(ctx, &decl.pos, decl.sym, const_value);
    return value;
}

func seed_enum_decl(ctx: *mut ElabCtx, decl: *mut EnumDecl) {
    if (decl.name) {
        decl.sym = declare_enum(ctx, &decl.pos, decl.name);
    }
    var member_decls = decl.members;
    for (var i = 0; i < list_len(member_decls); i += 1) {
        var member_decl = list_get(member_decls, i) as *mut EnumMember;
        seed_enum_member(ctx, member_decl);
    }
}

func elab_enum_decl(ctx: *mut ElabCtx, decl: *mut EnumDecl) {
    if (decl.name) {
        define_enum(ctx, &decl.pos, decl.sym, size: 4);
    }

    var type: *Type;
    if (decl.name) {
        type = mk_enum_type(decl.sym);
    } else {
        type = mk_int_type(4);
    }

    var next_value: Int32 = 0;
    var member_decls = decl.members;
    for (var i = 0; i < list_len(member_decls); i += 1) {
        var member_decl = list_get(member_decls, i) as *mut EnumMember;
        var value = elab_enum_member(ctx, member_decl, type, next_value);
        next_value = value + 1;
    }
}

func add_field_to_record(ctx: *mut ElabCtx, sym: *mut RecordSym, field_decl: *mut RecordFieldDecl) {
    var field_name = field_decl.name;
    var field_type = eval_type(ctx, field_decl.type);

    var existing_index = find_record_field_by_name(sym, field_name);
    if (existing_index != -1) {
        die_at(&field_decl.pos, "Duplicate field");
    }

    var default_value: *ConstValue = null;
    if (field_decl.default_value) {
        default_value = const_eval_expect(ctx, field_decl.default_value, field_type);
    }

    var field = box(sizeof(RecordField), &RecordField {
        name: field_name,
        type: field_type,
        default_value,
    }) as *mut RecordField;

    list_push(sym.fields, field);
}

func add_default_value_to_field(ctx: *mut ElabCtx, sym: *mut RecordSym, field_decl: *mut RecordFieldDecl) {
    var field_index = find_record_field_by_name(sym, field_decl.name);
    if (field_index == -1) {
        die_at(&field_decl.pos, "No existing field to add default value to");
    }

    var field = list_get(sym.fields, field_index) as *mut RecordField;
    if (field.default_value) {
        die_at(&field_decl.pos, "Field already has a default value");
    }

    field.default_value = const_eval_expect(ctx, field_decl.default_value, field.type);
}

func elab_record_field_decl(ctx: *mut ElabCtx, field_decl: *mut RecordFieldDecl, sym: *mut RecordSym) {
    if (!field_decl.type && field_decl.default_value) {
        add_default_value_to_field(ctx, sym, field_decl);
    } else if (field_decl.type) {
        add_field_to_record(ctx, sym, field_decl);
    } else {
        die_at(&field_decl.pos, "Field type missing");
    }
}

func elab_record_base(ctx: *mut ElabCtx, base: *mut TypeExpr, record_sym: *mut RecordSym) {
    var base_type = eval_type(ctx, base);
    if (base_type.kind != Type_Record) {
        die_at(&base.pos, "Expected a record type");
    }
    var baseSym = (base_type as *RecordType).sym;
    if (!baseSym.is_defined) {
        die_at(&base.pos, "Base has incomplete type");
    }
    if (baseSym == record_sym) {
        die_at(&base.pos, "Record cannot inherit from itself");
    }
    var base_fields = baseSym.fields;
    var fields = list_new_with_cap(list_len(base_fields));
    for (var i = 0; i < list_len(base_fields); i += 1) {
        var field = list_get(base_fields, i) as *mut RecordField;
        var copy = box(sizeof(RecordField), field) as *mut RecordField;
        list_push(fields, copy);
    }

    *record_sym = RecordSym {
        is_union: record_sym.is_union,
        name: record_sym.name,
        is_defined: record_sym.is_defined,
        base: baseSym,
        fields: fields,
    };
}

func seed_record_decl(ctx: *mut ElabCtx, decl: *mut RecordDecl) {
    decl.sym = declare_record(ctx, &decl.pos, decl.is_union, decl.name);
}

func elab_record_decl(ctx: *mut ElabCtx, decl: *mut RecordDecl) {
    var sym = decl.sym;
    var base = decl.base;

    if (base) {
        elab_record_base(ctx, base, sym);
    }

    if (decl.fields) {
        if (!sym.fields) {
            sym.fields = list_new();
        }
        for (var i = 0; i < list_len(decl.fields); i += 1) {
            var field_decl = list_get(decl.fields, i) as *mut RecordFieldDecl;
            elab_record_field_decl(ctx, field_decl, sym);
        }
        if (list_len(sym.fields) == 0) {
            die_at(&decl.pos, "Empty record");
        }
    }

    if (base || decl.fields) {
        define_record(ctx, &decl.pos, sym);
    }
}

func ensure_unique_params(ctx: *mut ElabCtx, decl: *mut FuncDecl) {
    var seen = list_new();
    for (var i = 0; i < list_len(decl.params); i += 1) {
        var param_decl = list_get(decl.params, i) as *mut FuncParamDecl;
        if (string_list_contains(seen, param_decl.name)) {
            die_at(&param_decl.pos, "Duplicate parameter name");
        }
        list_push(seen, param_decl.name);
    }
    if (decl.rest_param && decl.rest_param.name) {
        if (string_list_contains(seen, decl.rest_param.name)) {
            die_at(&decl.rest_param.pos, "Duplicate parameter name");
        }
    }
}

func elab_param(ctx: *mut ElabCtx, param_decl: *mut FuncParamDecl): *mut FuncParam {
    var name = param_decl.name;
    var type = eval_type(ctx, param_decl.type);

    if (!is_sized(type)) {
        die_at(&param_decl.pos, "Parameter has unsized type");
    }

    var default_value: *ConstValue = null;
    if (param_decl.default_value) {
        default_value = const_eval_expect(ctx, param_decl.default_value, type);
    }

    return box(sizeof(FuncParam), &FuncParam {
        name,
        type,
        default_value
    }) as *mut FuncParam;
}

func check_default_params_order(param_decls: *mut List, rest_param: *mut RestParamDecl) {
    var seen_default = false;
    var n_params = list_len(param_decls);
    for (var i = 0; i < n_params; i += 1) {
        var param_decl = list_get(param_decls, i) as *mut FuncParamDecl;
        if (!param_decl.default_value && seen_default) {
            die_at(&param_decl.pos, "Non-default parameter follows default parameter");
        }
        seen_default = seen_default || param_decl.default_value;
    }
}

func verify_main_signature(decl: *mut FuncDecl, sym: *mut FuncSym) {
    var param_decls = decl.params;
    var params = sym.params;
    var n_params = list_len(param_decls);
    var is_variadic = sym.is_variadic;
    var return_type = sym.return_type;

    if (!type_eq(return_type, mk_int_type(4))) {
        die_at(&decl.pos, "Return type of 'main' must be 'Int32'");
    }

    for (var i = 0; i < n_params; i += 1) {
        var param_decl = list_get(param_decls, i) as *mut FuncParamDecl;
        var param = list_get(params, i) as *mut FuncParam;
        match (i) {
            case 0: {
                if (!type_eq(param.type, mk_int_type(4))) {
                    die_at(&param_decl.pos, "The arg count parameter of 'main' must have type 'Int32'");
                }
            }
            case 1: {
                if (!type_eq(param.type, mk_ptr_type(mk_ptr_type(mk_int_type(1), is_mut: false), is_mut: false))) {
                    die_at(&param_decl.pos, "The arg vector parameter of 'main' must have type '**Char'");
                }
            }
            case _: {
                die_at(&param_decl.pos, "The 'main' function can only have parameters 'argc: Int32' and 'argv: **Char'");
            }
        }
    }

    if (is_variadic) {
        die_at(&decl.pos, "The 'main' function cannot be variadic");
    }
}

func seed_func_decl(ctx: *mut ElabCtx, decl: *mut FuncDecl) {
    var n_params = list_len(decl.params);
    var params = list_new();
    for (var i = 0; i < n_params; i += 1) {
        var param_decl = list_get(decl.params, i) as *mut FuncParamDecl;
        var param = elab_param(ctx, param_decl);
        list_push(params, param);
    }

    check_default_params_order(decl.params, decl.rest_param);

    var return_type = decl.return_type
        ? eval_type(ctx, decl.return_type)
        : mk_void_type();

    if (return_type.kind != Type_Void && return_type.kind != Type_Never && !is_sized(return_type)) {
        die_at(&decl.pos, "Function return type must have known size");
    }

    decl.sym = declare_func(ctx, &decl.pos, decl.name, params, decl.rest_param, return_type);

    if (str_eq(decl.name, "main")) {
        verify_main_signature(decl, decl.sym);
    }

    ensure_unique_params(ctx, decl);
}

func elab_func_decl(ctx: *mut ElabCtx, decl: *mut FuncDecl) {
    if (!decl.body) {
        return;
    }

    var sym = decl.sym;

    enter_scope(ctx);
    ctx.current_func = sym;

    define_params(ctx, decl.params, sym.params);

    if (decl.rest_param) {
        define_local(ctx, &decl.rest_param.pos, decl.rest_param.name, mk_rest_param_type());
    }

    elab_stmt(ctx, decl.body);

    ctx.current_func = null;
    exit_scope(ctx);

    define_func(ctx, &decl.pos, sym, decl.body);
}

func seed_const_decl(ctx: *mut ElabCtx, decl: *mut ConstDecl) {
    decl.sym = declare_const(ctx, &decl.pos, decl.name);
}

func elab_const_decl(ctx: *mut ElabCtx, decl: *mut ConstDecl) {
    var sym = decl.sym;
    var value_expr = decl.value;
    var type: *Type = null;
    if (decl.type) {
        type = eval_type(ctx, decl.type);
        if (!is_scalar(type)) {
            die_at(&decl.type.pos, "Constant must have a scalar type");
        }
    }
    var value: *ConstValue;
    if (type) {
        value = const_eval_expect(ctx, value_expr, type);
    } else {
        value = const_eval_infer(ctx, value_expr, type_hint: null);
    }
    define_const(ctx, &decl.pos, sym, value);
}

func seed_global_decl(ctx: *mut ElabCtx, decl: *mut GlobalDecl) {
    var type = eval_type(ctx, decl.type);
    if (!is_sized(type)) {
        die_at(&decl.pos, "Global variable must have known size");
    }

    decl.sym = declare_global(ctx, &decl.pos, decl.name, type);
}

func elab_global_decl(ctx: *mut ElabCtx, decl: *mut GlobalDecl) {
    var sym = decl.sym;

    if (!decl.is_extern) {
        define_global(ctx, &decl.pos, sym);
    }
}

func seed_decl(ctx: *mut ElabCtx, decl: *mut Decl) {
    match (decl.kind) {
        case Decl_ModuleName | Decl_Import: {
            // Skip
        }
        case Decl_Record: {
            seed_record_decl(ctx, decl as *mut RecordDecl);
        }
        case Decl_Enum: {
            seed_enum_decl(ctx, decl as *mut EnumDecl);
        }
        case Decl_Const: {
            seed_const_decl(ctx, decl as *mut ConstDecl);
        }
        case Decl_Func: {
            seed_func_decl(ctx, decl as *mut FuncDecl);
        }
        case Decl_Global: {
            seed_global_decl(ctx, decl as *mut GlobalDecl);
        }
        case other @ _: {
            unreachable_enum_case("seed_decl", other);
        }
    }
}

func handle_invalid_module_name_declaration(ctx: *mut ElabCtx, decl: *mut ModuleNameDecl) {
    die_at(&decl.pos, "Module name can only be declared at the beginning of the file");
}

func elab_import_decl(ctx: *mut ElabCtx, decl: *mut ImportDecl) {
    var n_imports = list_len(ctx.imports);
    for (var i = 0; i < n_imports; i += 1) {
        var existing = list_get(ctx.imports, i) as *Module;
        if (existing == decl.resolved_mod) {
            return;
        }
    }
    list_push(ctx.imports, decl.resolved_mod);
}

func elab_decl(ctx: *mut ElabCtx, decl: *mut Decl) {
    match (decl.kind) {
        case Decl_ModuleName: {
            handle_invalid_module_name_declaration(ctx, decl as *mut ModuleNameDecl);
        }
        case Decl_Import: {
            elab_import_decl(ctx, decl as *mut ImportDecl);
        }
        case Decl_Record: {
            elab_record_decl(ctx, decl as *mut RecordDecl);
        }
        case Decl_Enum: {
            elab_enum_decl(ctx, decl as *mut EnumDecl);
        }
        case Decl_Const: {
            elab_const_decl(ctx, decl as *mut ConstDecl);
        }
        case Decl_Func: {
            elab_func_decl(ctx, decl as *mut FuncDecl);
        }
        case Decl_Global: {
            elab_global_decl(ctx, decl as *mut GlobalDecl);
        }
        case other @ _: {
            unreachable_enum_case("elab_decl", other);
        }
    }
}

func handle_module_name(ctx: *mut ElabCtx, ast: *mut Ast) {
    if (list_len(ast.decls) == 0) {
        return;
    }
    var decl = list_get(ast.decls, 0) as *Decl;
    if (!(decl.kind is Decl_ModuleName)) {
        return;
    }
    var decl = decl as *ModuleNameDecl;

    var name = decl.name;
    var expected_name = get_stem(ast.file);
    if (!str_eq(name, expected_name)) {
        die_at(&decl.pos, "Module name '%s' does not match file name '%s'", name, expected_name);
    }

    ctx.module_name = name;
}

func elab(ast: *mut Ast): *mut List {
    var ctx = box(sizeof(ElabCtx), &ElabCtx {
        imports: list_new(),
        syms: list_new(),
        scope: scope_new(null),
        module_name: null,
        current_func: null,
        loop_depth: 0,
        or_pattern_depth: 0,
    }) as *mut ElabCtx;

    handle_module_name(ctx, ast);

    for (var pass = 0; pass < 5; pass += 1) {
        for (var i = 0; i < list_len(ast.decls); i += 1) {
            var decl = list_get(ast.decls, i) as *mut Decl;
            if (i == 0 && ctx.module_name) {
                continue;
            }
            match (pass) {
                case 0 if decl.kind is (Decl_ModuleName | Decl_Import): {
                    elab_decl(ctx, decl);
                }
                case 1 if decl.kind is (Decl_Record | Decl_Enum | Decl_Const): {
                    seed_decl(ctx, decl);
                }
                case 2 if decl.kind is (Decl_Record | Decl_Enum | Decl_Const): {
                    elab_decl(ctx, decl);
                }
                case 3 if decl.kind is (Decl_Func | Decl_Global): {
                    seed_decl(ctx, decl);
                }
                case 4 if decl.kind is (Decl_Func | Decl_Global): {
                    elab_decl(ctx, decl);
                }
            }
        }
    }

    return ctx.syms;
}
