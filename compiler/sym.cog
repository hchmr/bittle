include "cog.cogs";

func mk_sym(kind: Int, name: *Char): *Sym {
    var sym: *Sym = calloc(1, sizeof(Sym));
    sym.kind = kind;
    sym.name = name;
    return sym;
}

func enter_scope(env: *(*Env)) {
    var new_env = calloc(1, sizeof(Env)) as *Env;
    new_env.parent = *env;
    new_env.current_func = new_env.parent.current_func;
    new_env.current_loop = new_env.parent.current_loop;
    *env = new_env;
}

func leave_scope(env: *(*Env)) {
    var old_env = *env;
    *env = old_env.parent;
}

func find_sym_scoped(env: *Env, name: *Char): *Sym {
    var i = env.sym_count;
    while (i > 0) {
        i -= 1;
        if (str_eq(env.syms[i].name, name))
            return env.syms[i];
    }
    return null;
}

func find_sym(env: *Env, name: *Char): *Sym {
    while (env) {
        var sym = find_sym_scoped(env, name);
        if (sym)
            return sym;
        env = env.parent;
    }
}

func func_eq(a: *Sym, b: *Sym): Bool {
    if (!str_eq(a.name, b.name))
        return false;
    if (a.param_count != b.param_count)
        return false;
    if (a.is_variadic != b.is_variadic)
        return false;
    if (!type_eq(a.type, b.type))
        return false;
    var i = 0;
    while (i < a.param_count) {
        if (!type_eq(a.params[i].type, b.params[i].type))
            return false;
        i += 1;
    }
    return true;
}

func decl_compat(existing: *Sym, new: *Sym): Bool {
    if (existing.kind != new.kind)
        return false;
    if (!str_eq(existing.name, new.name))
        return false;

    if (existing.kind == Sym_Type) {
        if (type_eq(existing.type, new.type))
            return !(existing.is_defined && new.is_defined);
    } else if (existing.kind == Sym_Func) {
        if (func_eq(existing, new))
            return !(existing.is_defined && new.is_defined);
    } else if (existing.kind == Sym_Global) {
        if (type_eq(existing.type, new.type))
            return !(existing.is_defined && new.is_defined);
    }
    return false;
}

func sym_merge(existing: *Sym, new: *Sym) {
    if (!existing.is_defined) {
        *existing = *new;
    }
}

func add_sym(env: *Env, sym: *Sym, pos: *Pos) {
    var existing = find_sym_scoped(env, sym.name);

    if (existing) {
        if (decl_compat(existing, sym)) {
            sym_merge(existing, sym);
        } else {
            error_at(pos);
            fprintf(stderr, "Symbol '%s' already defined.\n", sym.name);
            exit(1);
        }
    } else {
        env.sym_count += 1;
        env.syms = realloc(env.syms, env.sym_count * sizeof(Sym));
        env.syms[env.sym_count - 1] = sym;
    }
}

func add_local(env: *Env, name: *Char, type: *Type, pos: *Pos): *Sym {
    var func_ = env.current_func;
    func_.locals_size = align_up(func_.locals_size + type_size(type), type_align(type));
    if (func_.locals_size > FRAME_LOCALS_SIZE_MAX) {
        error_at(pos);
        fprintf(stderr, "Maximum local size exceeded.\n");
        exit(1);
    }

    var sym = mk_sym(Sym_Local, name);
    sym.type = type;
    sym.offset = func_.locals_size;

    add_sym(env, sym, pos);
    return sym;
}

func add_global(env: *Env, is_defined: Bool, name: *Char, type: *Type, pos: *Pos) {
    var sym = mk_sym(Sym_Global, name);
    sym.is_defined = is_defined;
    sym.type = type;
    add_sym(env, sym, pos);
}

func add_const(env: *Env, name: *Char, value: Int, pos: *Pos) {
    var sym = mk_sym(Sym_Const, name);
    sym.type = mk_int_type(4);
    sym.value = value;
    add_sym(env, sym, pos);
}

func declare_struct(env: *Env, name: *Char, pos: *Pos) {
    var existing = find_sym(env, name);
    var sym = mk_sym(Sym_Type, name);
    sym.type = existing ? existing.type : mk_struct_type(name);
    add_sym(env, sym, pos);
}

func define_struct(env: *Env, name: *Char, fields: *Type, pos: *Pos) {
    var sym = mk_sym(Sym_Type, name);
    sym.is_defined = true;
    sym.type = find_sym(env, name).type;
    add_sym(env, sym, pos);
    *sym.type = *fields;
}
