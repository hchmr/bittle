include "bittle.btls";

const FRAME_SIZE_MAX = 4096;
const FRAME_TEMP_SIZE = 128;
const FRAME_LOCALS_SIZE_MAX = FRAME_SIZE_MAX - FRAME_TEMP_SIZE;

func hir_is_lvalue(e: *HirExpr): Bool {
    return e.kind == HirExpr_Var
        || e.kind == HirExpr_Temp
        || e.kind == HirExpr_Member
        || e.kind == HirExpr_Index
        || e.kind == HirExpr_Deref;
}

func is_int_or_enum(t: *Type, max_size: Int): Bool {
    if (t.kind == Type_Int) {
        return (t as *IntType).size <= max_size;
    } else if (t.kind == Type_Enum) {
        return (t as *EnumType).sym.size <= max_size;
    } else {
        return false;
    }
}

struct Slot {
    offset: Int,
    name: *Char,
}

struct CodegenCtx {
    frame_size: Int,
    label_count: Int,
    temp_size: Int,
    current_func: *FuncSym,
    current_loop: Int,
    slots: *Slot,
    n_slots: Int,
}

func next_label(ctx: *CodegenCtx): Int {
    ctx.label_count += 1;
    return ctx.label_count;
}

func strx(type: *Type): *Char {
    if (type_size(type) == 1)
        return "strb w";
    if (type_size(type) == 2)
        return "strh w";
    if (type_size(type) == 4)
        return "str w";
    if (type_size(type) == 8)
        return "str x";
    unreachable("strx");
}

func ldrx(type: *Type): *Char {
    if (type.kind == Type_Bool)
        return "ldrb w";
    if (is_int_or_enum(type, max_size: 1))
        return "ldrsb x";
    if (is_int_or_enum(type, max_size: 2))
        return "ldrsh x";
    if (is_int_or_enum(type, max_size: 4))
        return "ldrsw x";
    if (type_size(type) == 8)
        return "ldr x";
    pretty_type(stderr, type); // TODO
    unreachable("ldrx");
}

func emit_push(ctx: *CodegenCtx, reg: Int) {
    if (ctx.temp_size + 8 >= FRAME_TEMP_SIZE) {
        fprintf(stderr, "Ran out of space for temporaries while compiling expression.\n");
        exit(1);
    }
    ctx.temp_size += 8;
    printf("  str x%d, [sp, #%d] // push\n", reg, FRAME_TEMP_SIZE - ctx.temp_size);
}

func emit_pop(ctx: *CodegenCtx, reg: Int) {
    printf("  ldr x%d, [sp, #%d] // pop\n", reg, FRAME_TEMP_SIZE - ctx.temp_size);
    ctx.temp_size -= 8;
}

func get_slot_sp_offset(ctx: *CodegenCtx, type: *Type, slot_index: Int): Int {
    var slot = &ctx.slots[slot_index];
    return ctx.frame_size - slot.offset - type_size(type);
}

func print_slot_name(ctx: *CodegenCtx, slot_index: Int) {
    if (ctx.slots[slot_index].name) {
        printf("%s", ctx.slots[slot_index].name);
    } else {
        printf("$slot%d", slot_index);
    }
}

func emit_slot_store(ctx: *CodegenCtx, type: *Type, slot_index: Int, reg: Int) {
    var sp_offset = get_slot_sp_offset(ctx, type, slot_index);
    printf("  %s%d, [sp, #%d] // ", strx(type), reg, sp_offset);
    print_slot_name(ctx, slot_index);
    printf("\n");
}

func emit_slot_addr(ctx: *CodegenCtx, type: *Type, slot_index: Int, reg: Int) {
    var sp_offset = get_slot_sp_offset(ctx, type, slot_index);
    printf("  add x%d, sp, #%d // &", reg, sp_offset);
    print_slot_name(ctx, slot_index);
    printf("\n");
}

func emit_sign_extend(ctx: *CodegenCtx, source: *Type, t0: Int, t1: Int) {
    assert(is_scalar(source), "emit_sign_extend: source should be a scalar.");
    if (is_int_or_enum(source, max_size: 4)) {
        var source = source as *IntType;
        var suffix = "_bh_w"[source.size];
        printf("  sxt%c x%d, w%d\n", suffix, t0, t1);
    } else {
        if (t0 != t1) {
            printf("  mov x%d, x%d\n", t0, t1);
        }
    }
}

func compute_frame_layout(ctx: *CodegenCtx) {
    var sym = ctx.current_func;
    var n_locals = list_len(sym.locals);
    var n_temps = list_len(sym.temps);

    var n_slots = n_locals + n_temps;
    var slots: *Slot = calloc(n_slots, sizeof(Slot));

    var size = 0;
    for (var i = 0; i < n_locals; i += 1) {
        var local_sym: *LocalSym = list_get(sym.locals, i);
        var type = local_sym.type;


        var offset = align_up(size, type_align(type));
        slots[local_sym.slot_index] = Slot(offset, name: local_sym.name);

        size = offset + type_size(type);
    }

    for (var i = 0; i < n_temps; i += 1) {
        var temp: *HirTemp = list_get(sym.temps, i);
        var type = temp.type;


        var offset = align_up(size, type_align(type));
        slots[temp.slot_index] = Slot(offset, name: null);

        size = offset + type_size(type);
    }

    size = align_up(size, 16) + FRAME_TEMP_SIZE;

    if (size > FRAME_SIZE_MAX) {
        error_at(&sym.body.pos);
        fprintf(stderr, "Frame size of function %s exceeds the maximum allowed size.\n", sym.name);
        exit(1);
    }

    ctx.frame_size = size;
    ctx.n_slots = n_slots;
    ctx.slots = slots;
}

func emit_expr(ctx: *CodegenCtx, e: *HirExpr, t0: Int);

func emit_expr_lvalue(ctx: *CodegenCtx, e: *HirExpr, t0: Int);

func emit_operands(ctx: *CodegenCtx, e1: *HirExpr, e2: *HirExpr, t0: Int, t1: Int) {
    emit_expr(ctx, e1, t0);
    emit_push(ctx, t0);
    emit_expr(ctx, e2, t1);
    emit_pop(ctx, t0);
}

func emit_operands_lvalue(ctx: *CodegenCtx, dst: *HirExpr, src: *HirExpr, t0: Int, t1: Int) {
    emit_expr_lvalue(ctx, dst, t0);
    emit_push(ctx, t0);
    emit_expr(ctx, src, t1);
    emit_pop(ctx, t0);
}

func emit_expr_binary(ctx: *CodegenCtx, op: *Char, e1: *HirExpr, e2: *HirExpr, t0: Int) {
    emit_operands(ctx, e1, e2, 0, 1);
    printf("  %s x%d, x%d, x%d\n", op, t0, 0, 1);
}

func emit_expr_cmp(ctx: *CodegenCtx, op: *Char, e1: *HirExpr, e2: *HirExpr, t0: Int) {
    emit_operands(ctx, e1, e2, 0, 1);
    printf("  cmp x%d, x%d\n", 0, 1);
    printf("  cset x%d, %s\n", t0, op);
}

func emit_expr_lvalue(ctx: *CodegenCtx, e: *HirExpr, t0: Int) {
    if (e.kind == HirExpr_Var && (e as *HirVarExpr).sym.kind == Sym_Local) {
        var e = e as *HirVarExpr;
        var sym = e.sym as *LocalSym;
        emit_slot_addr(ctx, sym.type, sym.slot_index, t0);
    } else if (e.kind == HirExpr_Var && (e as *HirVarExpr).sym.kind == Sym_Global) {
        var e = e as *HirVarExpr;
        var sym = e.sym as *GlobalSym;
        if (sym.is_defined) {
            printf("  adrp x%d, %s\n", t0, sym.name);
            printf("  add x%d, x%d, :lo12:%s // &%s\n", t0, t0, sym.name, sym.name);
        } else {
            printf("  adrp x%d, :got:%s\n", t0, sym.name);
            printf("  ldr x%d, [x%d, :got_lo12:%s] // &%s\n", t0, t0, sym.name, sym.name);
        }
    } else if (e.kind == HirExpr_Temp) {
        var e = e as *HirTempExpr;
        var temp = e.temp;
        emit_slot_addr(ctx, temp.type, temp.slot_index, t0);
    } else if (e.kind == HirExpr_Member) {
        var e = e as *HirMemberExpr;
        var fields = (e.left.type as *StructType).sym.fields;
        var field: *StructField = list_get(fields, e.field_index);
        emit_expr_lvalue(ctx, e.left, t0);
        printf("  add x%d, x%d, #%d // &%s\n", t0, t0, field.offset, e.name);
    } else if (e.kind == HirExpr_Deref) {
        var e = e as *HirDerefExpr;
        emit_expr(ctx, e.expr, t0);
    } else if (e.kind == HirExpr_Index) {
        var e = e as *HirIndexExpr;
        if (e.indexee.type.kind == Type_Ptr) {
            emit_operands(ctx, e.indexee, e.index, 0, 1);
        } else if (e.indexee.type.kind == Type_Arr) {
            emit_operands_lvalue(ctx, e.indexee, e.index, 0, 1);
        } else {
            unreachable("emit_expr_lvalue: indexee should be a pointer or an array.");
        }
        var elem_size = type_size(e.type);
        printf("  add x%d, x0, x1, lsl #%d // &_[_]\n", t0, ilog2(elem_size));
    } else {
        unreachable("emit_expr_lvalue");
    }
}

func emit_seq_expr(ctx: *CodegenCtx, e: *HirSeqExpr, t0: Int) {
    var first = e.first;
    var second = e.second;
    emit_expr(ctx, first, 0);
    emit_expr(ctx, second, t0);
}

func emit_int_expr(ctx: *CodegenCtx, e: *HirIntExpr, t0: Int) {
    var int_val = e.value;
    printf("  mov x%d, #%d\n", t0, int_val);
}

func emit_str_expr(ctx: *CodegenCtx, e: *HirStrExpr, t0: Int) {
    var str_val = e.value;
    var label = next_label(ctx);
    printf("  .text\n");
    printf("  .section .rodata\n");
    printf("  .align 3\n");
    printf(".str.%d:\n", label);
    printf("  .string \"");
    var i = 0;
    while (str_val[i] != '\0') {
        if (!is_print(str_val[i]) || str_val[i] == '\"' || str_val[i] == '\\') {
            printf("\\%03o", str_val[i]);
        } else {
            printf("%c", str_val[i]);
        }
        i += 1;
    }
    printf("\"\n");
    printf("  .text\n");
    printf("  adrp x%d, .str.%d\n", t0, label);
    printf("  add x%d, x%d, :lo12:.str.%d\n", t0, t0, label);
}

func emit_cond_expr(ctx: *CodegenCtx, e: *HirCondExpr, t0: Int) {
    var cond = e.cond;
    var then_expr = e.then_expr;
    var else_expr = e.else_expr;

    var label = next_label(ctx);
    printf(".L%d.if:\n", label);
    emit_expr(ctx, cond, 0);
    printf("  cbz x0, .L%d.else\n", label);
    printf(".L%d.then:\n", label);
    emit_expr(ctx, then_expr, t0);
    printf("  b .L%d.end\n", label);
    printf(".L%d.else:\n", label);
    emit_expr(ctx, else_expr, t0);
    printf(".L%d.end:\n", label);
}

func emit_loop_expr(ctx: *CodegenCtx, e: *HirLoopExpr, t0: Int) {
    var cond = e.cond;
    var body = e.body;
    var step = e.step;

    var label = next_label(ctx);
    var outer_loop = ctx.current_loop;
    ctx.current_loop = label;
    printf(".L%d.while:\n", label);
    emit_expr(ctx, cond, 0);
    printf("  cbz x0, .L%d.done\n", label);
    printf(".L%d.do:\n", label);
    emit_expr(ctx, body, 0);
    printf(".L%d.step:\n", label);
    emit_expr(ctx, step, 0);
    printf("  b .L%d.while\n", label);
    printf(".L%d.done:\n", label);
    ctx.current_loop = outer_loop;
}

func emit_jump_expr(ctx: *CodegenCtx, e: *HirJumpExpr, t0: Int) {
    var is_break = e.is_break;
    if (is_break) {
        printf("  b .L%d.done\n", ctx.current_loop);
    } else {
        printf("  b .L%d.step\n", ctx.current_loop);
    }
}

func emit_return_expr(ctx: *CodegenCtx, e: *HirReturnExpr, t0: Int) {
    var subexpr = e.expr;
    if (subexpr) {
        emit_expr(ctx, subexpr, 0);
    }
    printf("  b .L.%s.ret\n", ctx.current_func.name);
}

func emit_binary_op_expr(ctx: *CodegenCtx, e: *HirBinaryOpExpr, t0: Int) {
    var op = e.op;
    var e1 = e.left;
    var e2 = e.right;
    var type = e.type;

    if (op == HirOp_Or) {
        emit_expr_binary(ctx, "orr", e1, e2, t0);
    } else if (op == HirOp_Xor) {
        emit_expr_binary(ctx, "eor", e1, e2, t0);
    } else if (op == HirOp_And) {
        emit_expr_binary(ctx, "and", e1, e2, t0);
    } else if (op == HirOp_Shl) {
        emit_expr_binary(ctx, "lsl", e1, e2, t0);
    } else if (op == HirOp_Shr) {
        emit_expr_binary(ctx, "lsr", e1, e2, t0);
    } else if (op == HirOp_Eq) {
        emit_expr_cmp(ctx, "eq", e1, e2, t0);
    } else if (op == HirOp_Ne) {
        emit_expr_cmp(ctx, "ne", e1, e2, t0);
    } else if (op == HirOp_Lt) {
        emit_expr_cmp(ctx, "lt", e1, e2, t0);
    } else if (op == HirOp_Le) {
        emit_expr_cmp(ctx, "le", e1, e2, t0);
    } else if (op == HirOp_Gt) {
        emit_expr_cmp(ctx, "gt", e1, e2, t0);
    } else if (op == HirOp_Ge) {
        emit_expr_cmp(ctx, "ge", e1, e2, t0);
    } else if (op == HirOp_Add) {
        emit_expr_binary(ctx, "add", e1, e2, t0);
    } else if (op == HirOp_Sub) {
        emit_expr_binary(ctx, "sub", e1, e2, t0);
    } else if (op == HirOp_Mul) {
        emit_expr_binary(ctx, "mul", e1, e2, t0);
    } else if (op == HirOp_Div) {
        emit_expr_binary(ctx, "sdiv", e1, e2, t0);
    } else if (op == HirOp_Rem) {
        emit_operands(ctx, e1, e2, 1, 2);
        printf("  sdiv x%d, x%d, x%d\n", 0, 1, 2);
        printf("  msub x%d, x%d, x%d, x%d\n", t0, 0, 2, 1);
    } else {
        unreachable("emit_binary_op_expr");
    }
}

func emit_call_expr(ctx: *CodegenCtx, e: *HirCallExpr, t0: Int) {
    var sym = e.callee;
    var param_count = list_len((sym as *FuncSym).params);
    var args = e.args;
    var arg_count = list_len(args);
    var type = e.type;

    var i = 0;
    while (i < arg_count) {
        var arg = list_get(args, i);
        emit_expr(ctx, arg, 0);
        emit_push(ctx, 0);
        i += 1;
    }
    while (i > 0) {
        i -= 1;
        emit_pop(ctx, i);
    }
    printf("  bl %s\n", sym.name);
    if (type.kind != Type_Void && type.kind != Type_Never) {
        emit_sign_extend(ctx, type, t0, 0);
    }
}

func emit_addr_expr(ctx: *CodegenCtx, e: *HirAddrExpr, t0: Int) {
    var subexpr = e.expr;
    emit_expr_lvalue(ctx, subexpr, t0);
}

func emit_assign_expr(ctx: *CodegenCtx, e: *HirAssignExpr, t0: Int) {
    var dst = e.dst;
    var src = e.src;
    if (is_scalar(dst.type)) {
        emit_operands_lvalue(ctx, dst, src, 0, 1);
        printf("  %s1, [x0]\n", strx(dst.type));
    } else {
        emit_expr_lvalue(ctx, dst, 0);
        emit_push(ctx, 0);
        emit_expr_lvalue(ctx, src, 1);
        emit_pop(ctx, 0);
        printf("  mov x2, #%d\n", type_size(dst.type));
        printf("  bl memcpy\n");
    }
}

func emit_cast_expr(ctx: *CodegenCtx, e: *HirCastExpr, t0: Int) {
    var subexpr = e.expr;
    var target = e.type;
    var source = subexpr.type;
    emit_expr(ctx, subexpr, t0);
    if (source.kind == Type_Never) {
        printf("  // cast of !\n", t0);
        return;
    }
    assert(is_scalar(target) && is_scalar(source), "emit_expr: <cast> should have scalar types.");
    if (target.kind == Type_Bool) {
        printf("  cmp x%d, #0\n", t0);
        printf("  cset w%d, ne\n", t0);
    } else if (type_size(target) < type_size(source)) {
        emit_sign_extend(ctx, target, t0, t0);
    } else {
        // no-op
    }
}

func emit_expr(ctx: *CodegenCtx, e: *HirExpr, t0: Int) {
    if (hir_is_lvalue(e)) {
        emit_expr_lvalue(ctx, e, t0);
        printf("  %s%d, [x%d]\n", ldrx(e.type), t0, t0);
    } else if (e.kind == HirExpr_Skip) {
        // nop
    } else if (e.kind == HirExpr_Seq) {
        emit_seq_expr(ctx, e as *HirSeqExpr, t0);
    } else if (e.kind == HirExpr_Int) {
        emit_int_expr(ctx, e as *HirIntExpr, t0);
    } else if (e.kind == HirExpr_Str) {
        emit_str_expr(ctx, e as *HirStrExpr, t0);
    } else if (e.kind == HirExpr_Cond) {
        emit_cond_expr(ctx, e as *HirCondExpr, t0);
    } else if (e.kind == HirExpr_Loop) {
        emit_loop_expr(ctx, e as *HirLoopExpr, t0);
    } else if (e.kind == HirExpr_Jump) {
        emit_jump_expr(ctx, e as *HirJumpExpr, t0);
    } else if (e.kind == HirExpr_Return) {
        emit_return_expr(ctx, e as *HirReturnExpr, t0);
    } else if (e.kind == HirExpr_BinaryOp) {
        emit_binary_op_expr(ctx, e as *HirBinaryOpExpr, t0);
    } else if (e.kind == HirExpr_Call) {
        emit_call_expr(ctx, e as *HirCallExpr, t0);
    } else if (e.kind == HirExpr_Addr) {
        emit_addr_expr(ctx, e as *HirAddrExpr, t0);
    } else if (e.kind == HirExpr_Assign) {
        emit_assign_expr(ctx, e as *HirAssignExpr, t0);
    } else if (e.kind == HirExpr_Cast) {
        emit_cast_expr(ctx, e as *HirCastExpr, t0);
    } else {
        unreachable("emit_expr");
    }
}

func emit_func(ctx: *CodegenCtx, sym: *FuncSym) {
    var params = sym.params;
    var locals = sym.locals;
    var body = sym.body;

    var hir_body = hir_lower(sym, body);

    ctx.current_func = sym;
    compute_frame_layout(ctx);

    printf("  .text\n");
    printf("  .align 2\n");
    printf("  .global %s\n", sym.name);
    printf("%s:\n", sym.name);
    printf("  stp x29, x30, [sp, #-16]!\n");
    printf("  mov x29, sp\n");
    printf("  sub sp, sp, #%d\n", ctx.frame_size);
    var i = 0;
    for (var i = 0; i < list_len(params); i += 1) {
        var param: *FuncParam = list_get(params, i);
        var local: *LocalSym = list_get(locals, i);
        emit_slot_store(ctx, param.type, local.slot_index, i);
    }
    emit_expr(ctx, hir_body, 0);
    printf(".L.%s.ret:\n", sym.name);
    printf("  add sp, sp, #%d\n", ctx.frame_size);
    printf("  ldp x29, x30, [sp], #16\n");
    printf("  ret\n");
}

func emit_global(ctx: *CodegenCtx, sym: *GlobalSym) {
    var type = sym.type;
    printf("  .global %s\n", sym.name);
    printf("  .bss\n");
    printf(".align %d\n", type_align(type));
    printf("%s:\n", sym.name);
    printf("  .zero %d\n", type_size(type));
}

func emit_sym(ctx: *CodegenCtx, sym: *Sym) {
    if (!sym_is_defined(sym)) {
        return;
    }
    if (sym.kind == Sym_Func) {
        emit_func(ctx, sym as *FuncSym);
    } else if (sym.kind == Sym_Global) {
        emit_global(ctx, sym as *GlobalSym);
    }
}

func emit_program(syms: *List) {
    var ctx = calloc(1, sizeof(CodegenCtx)) as *CodegenCtx;
    *ctx = CodegenCtx(
        frame_size: 0,
        label_count: 0,
        temp_size: 0,
        current_func: null,
        current_loop: 0,
        slots: null,
        n_slots: 0,
    );

    for (var i = 0; i < list_len(syms); i += 1) {
        var sym = list_get(syms, i);
        emit_sym(ctx, sym);
    }
}
