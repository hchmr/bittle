// stdio
extern struct File;
extern var stdin: *File;
extern var stdout: *File;
extern var stderr: *File;

extern func printf(fmt: *Char, ...): Int32;
extern func fprintf(file: *File, fmt: *Char, ...): Int32;
extern func sprintf(buf: *Char, fmt: *Char, ...): Int32;
extern func getchar(): Int32;

// stdlib
extern func exit(status: Int32);
extern func calloc(count: Int, size: Int): *Void;
extern func realloc(ptr: *Void, size: Int): *Void;
extern func atoi(s: *Char): Int;

// string
extern func strlen(s: *Char): Int;
extern func strcmp(a: *Char, b: *Char): Int32;

//= Misc

struct Pos {
    line: Int,
    col: Int,
}

func error_at(pos: *Pos) {
    fprintf(stderr, "%d:%d: Error: ", pos.line, pos.col);
}

func str_eq(a: *Char, b: *Char): Bool {
    return strcmp(a, b) == 0;
}

func align_up(size: Int , align: Int): Int {
    return (size + align - 1) / align * align;
}

func assert(cond: Bool, because: *Char) {
    if (!cond) {
        fprintf(stderr, "Assertion failed: %s\n", because);
        exit(1);
    }
}

func ilog2(n: Int): Int {
    var i = 0;
    while (n > 1) {
        n = n / 2;
        i += 1;
    }
    return i;
}

func int_min(a: Int, b: Int): Int {
    return a > b ? b : a;
}

func sb_push(buf_p: *(*Char), c: Char): Void {
    var len = *buf_p ? strlen(*buf_p) : 0;
    *buf_p = realloc(*buf_p, len + 2);
    (*buf_p)[len] = c;
    (*buf_p)[len + 1] = '\0';
}

//= Codegen Constants

const FRAME_LOCALS_SIZE = 128;
const FRAME_TEMP_SIZE = 512;
const FRAME_ARGS_SIZE = 64;
const FRAME_SIZE = FRAME_LOCALS_SIZE + FRAME_TEMP_SIZE + FRAME_ARGS_SIZE;

//= Type System

enum {
    Type_Void,
    Type_Bool,
    Type_Int,
    Type_Ptr,
    Type_Arr,
    Type_Struct,
}

struct Type {
    kind: Int,
    // Int
    size: Int,
    // Ptr, Array
    base: *Type,
    // Array
    len: Int,
    name: *Char,
    field_names: *(*Char),
    field_types: *(*Type),
    field_offsets: *Int,
    field_count: Int,
    unpadded_size: Int,
}

func mk_type(kind: Int): *Type {
    var type: *Type = calloc(1, sizeof(Type));
    type.kind = kind;
    return type;
}

func mk_void_type(): *Type {
    return mk_type(Type_Void);
}

func mk_bool_type(): *Type {
    return mk_type(Type_Bool);
}

func mk_int_type(size: Int): *Type {
    var type = mk_type(Type_Int);
    type.size = size;
    return type;
}

func mk_ptr_type(base: *Type): *Type {
    var type = mk_type(Type_Ptr);
    type.base = base;
    return type;
}

func mk_array_type(base: *Type, len: Int): *Type {
    var type = mk_type(Type_Arr);
    type.base = base;
    type.len = len;
    return type;
}

func mk_struct_type(name: *Char): *Type {
    var type = mk_type(Type_Struct);
    type.name = name;
    return type;
}

func type_align(type: *Type): Int {
    if (type.kind == Type_Void)
        return 1;
    if (type.kind == Type_Bool)
        return 1;
    if (type.kind == Type_Int)
        return type.size;
    if (type.kind == Type_Ptr)
        return 8;
    if (type.kind == Type_Arr)
        return type_align(type.base);
    if (type.kind == Type_Struct)
        return 8; // Maximum possible alignment.
    assert(false, "type_align: Unreachable.");
}

func type_size(type: *Type): Int {
    if (type.kind == Type_Void)
        return -1;
    if (type.kind == Type_Bool)
        return 1;
    if (type.kind == Type_Int)
        return type.size;
    if (type.kind == Type_Ptr)
        return 8;
    if (type.kind == Type_Arr)
        return type.len * align_up(type_size(type.base), type_align(type.base));
    if (type.kind == Type_Struct)
        return type.field_count == 0 ? -1 : align_up(type.unpadded_size, type_align(type));
    assert(false, "type_size: Unreachable.");
}

func type_eq(t1: *Type, t2: *Type): Bool {
    if (t1.kind != t2.kind)
        return false;
    if (t1.kind == Type_Int)
        return t1.size == t2.size;
    if (t1.kind == Type_Ptr)
        return type_eq(t1.base, t2.base);
    if (t1.kind == Type_Arr)
        return t1.len == t2.len && type_eq(t1.base, t2.base);
    if (t1.kind == Type_Struct)
        return t1 == t2;
    return true;
}

func is_scalar(type: *Type): Bool {
    return type.kind == Type_Bool || type.kind == Type_Int || type.kind == Type_Ptr;
}

func type_le(t1: *Type, t2: *Type): Bool {
    if (is_scalar(t1) && t2.kind == Type_Bool)
        return true;
    if (t1.kind == Type_Int && t2.kind == Type_Int)
        return t1.size <= t2.size;
    if (t1.kind == Type_Ptr && t2.kind == Type_Ptr)
        return t1.base.kind == Type_Void;
    return false;
}

func add_field(type: *Type, field_name: *Char, field_type: *Type) {
    assert(type.kind == Type_Struct, "add_field: type should be a struct.");
    var i = type.field_count;
    type.field_count += 1;
    type.field_names = realloc(type.field_names, type.field_count * sizeof(*Char));
    type.field_types = realloc(type.field_types, type.field_count * sizeof(*Type));
    type.field_offsets = realloc(type.field_offsets, type.field_count * sizeof(Int));
    type.field_names[i] = field_name;
    type.field_types[i] = field_type;
    type.field_offsets[i] = align_up(type.unpadded_size, type_align(field_type));
    type.unpadded_size = type.field_offsets[i] + type_size(field_type);
}

func find_field(type: *Type, name: *Char): Int {
    assert(type.kind == Type_Struct, "find_field: type should be a struct.");
    var i = 0;
    while (i < type.field_count) {
        if (str_eq(type.field_names[i], name)) {
            return i;
        }
        i += 1;
    }
    return -1;
}

func print_type(file: *File, type: *Type) {
    if (type.kind == Type_Void) {
        fprintf(file, "Void");
    } else if (type.kind == Type_Bool) {
        fprintf(file, "Bool");
    } else if (type.kind == Type_Int) {
        fprintf(file, "Int%d", type.size * 8);
    } else if (type.kind == Type_Ptr) {
        fprintf(file, "*");
        print_type(file, type.base);
    } else if (type.kind == Type_Arr) {
        fprintf(file, "[");
        print_type(file, type.base);
        fprintf(file, "; %d]", type.len);
    } else if (type.kind == Type_Struct) {
        fprintf(file, "%s", type.name);
    } else {
        assert(false, "print_type: Unreachable.");
    }
}

//= Symbols

const MAX_SCOPES = 16;
const MAX_PARAMS = 8;

enum {
    Sym_Type,
    Sym_Func,
    Sym_Global,
    Sym_Local,
    Sym_Const,
}

struct Sym {
    kind: Int,
    name: *Char,
    // Type, Function, Global, Local
    type: *Type,
    // Local variable
    offset: Int,
    // Function, Global
    is_extern: Bool,
    // Global
    value: Int,
    // Function
    param_names: [*Char; MAX_PARAMS + 1],
    param_types: [*Type; MAX_PARAMS + 1],
    param_count: Int,
    defined: Bool,
    is_variadic: Bool,
    locals_size: Int
}

var syms: *(*Sym);
var sym_count: Int;
var first_sym: [Int; MAX_SCOPES];
var scope_depth: Int;
var current_func: *Sym;
var current_loop: Int;

func mk_sym(kind: Int, name: *Char): *Sym {
    var sym: *Sym = calloc(1, sizeof(Sym));
    sym.kind = kind;
    sym.name = name;
    return sym;
}

func enter_scope() {
    if (scope_depth == MAX_SCOPES) {
        fprintf(stderr, "Maximum scope depth exceeded.\n");
        exit(1);
    }
    scope_depth += 1;
    first_sym[scope_depth] = sym_count;
}

func leave_scope() {
    assert(scope_depth > 0, "leave_scope: there should be a scope to pop.");
    sym_count = first_sym[scope_depth];
    scope_depth -= 1;
}

func func_eq(a: *Sym, b: *Sym): Bool {
    if (a.param_count != b.param_count)
        return false;
    if (a.is_variadic != b.is_variadic)
        return false;
    if (!type_eq(a.type, b.type))
        return false;
    var i = 0;
    while (i < a.param_count) {
        if (!type_eq(a.param_types[i], b.param_types[i]))
            return false;
        i += 1;
    }
    return true;
}

func find_sym(name: *Char, depth: Int): *Sym {
    var i = sym_count - 1;
    while (i >= first_sym[depth]) {
        if (str_eq(syms[i].name, name)) {
            return syms[i];
        }
        i -= 1;
    }
    return null;
}

func add_sym(sym: *Sym, pos: *Pos) {
    var existing = find_sym(sym.name, scope_depth);
    if (existing && !(sym.kind == Sym_Func && existing.kind == Sym_Func && !existing.defined && func_eq(sym, existing))) {
        error_at(pos);
        fprintf(stderr, "Symbol '%s' already defined.\n", sym.name);
        exit(1);
    }
    sym_count += 1;
    syms = realloc(syms, sym_count * sizeof(Sym));
    syms[sym_count - 1] = sym;
}

func add_local(name: *Char, type: *Type, pos: *Pos): *Sym {
    current_func.locals_size = align_up(current_func.locals_size + type_size(type), type_align(type));
    if (current_func.locals_size > FRAME_LOCALS_SIZE) {
        error_at(pos);
        fprintf(stderr, "Maximum local size exceeded.\n");
        exit(1);
    }

    var sym = mk_sym(Sym_Local, name);
    sym.type = type;
    sym.offset = current_func.locals_size;

    add_sym(sym, pos);
    return sym;
}

func add_global(is_extern: Bool, name: *Char, type: *Type, pos: *Pos) {
    var sym = mk_sym(Sym_Global, name);
    sym.is_extern = is_extern;
    sym.type = type;
    add_sym(sym, pos);
}

func add_const(name: *Char, value: Int, pos: *Pos) {
    var sym = mk_sym(Sym_Const, name);
    sym.type = mk_int_type(4);
    sym.value = value;
    add_sym(sym, pos);
}

//= Abstract Syntax Tree

struct Expr {
    kind: *Char,
    type: *Type,
    pos: Pos,
    // Null, Bool, Int
    int_val: Int,
    // Str
    str_val: *Char,
    // Var, Call
    sym: *Sym,
    // Call, Unary, Binary, Etc.
    args: [*Expr; MAX_PARAMS + 1],
    arg_count: Int,
    // Field
    field_index: Int,
}

func mk_expr(kind: *Char, type: *Type, pos: *Pos): *Expr {
    var expr: *Expr = calloc(1, sizeof(Expr));
    expr.kind = kind;
    expr.type = type;
    expr.pos = *pos;
    return expr;
}

func mk_expr_3(kind: *Char, e1: *Expr, e2: *Expr, e3: *Expr, type: *Type): *Expr {
    var expr = mk_expr(kind, type, &e1.pos);
    expr.args[0] = e1;
    expr.args[1] = e2;
    expr.args[2] = e3;
    expr.arg_count = 3;
    return expr;
}

func mk_expr_2(kind: *Char, e1: *Expr, e2: *Expr, type: *Type): *Expr {
    var expr = mk_expr_3(kind, e1, e2, null, type);
    expr.arg_count = 2;
    return expr;
}

func mk_expr_1(kind: *Char, e1: *Expr, type: *Type): *Expr {
    var expr = mk_expr_2(kind, e1, null, type);
    expr.arg_count = 1;
    return expr;
}

func mk_cast_expr(expr: *Expr, type: *Type): *Expr {
    var cast = mk_expr("<cast>", type, &expr.pos);
    cast.args[0] = expr;
    return cast;
}

func is_lvalue(expr: *Expr): Bool {
    return str_eq(expr.kind, "<var>") || str_eq(expr.kind, "*_") || str_eq(expr.kind, "_._") || str_eq(expr.kind, "_[_]");
}

func print_expr(file: *File, expr: *Expr) {
    if (!expr) {
        fprintf(file, "<null>");
    } else if (str_eq(expr.kind, "<int>")) {
        fprintf(file, "%d", expr.int_val);
    } else if (str_eq(expr.kind, "<str>")) {
        fprintf(file, "\"%s\"", expr.str_val);
    } else if (str_eq(expr.kind, "<var>")) {
        fprintf(file, "%s", expr.sym.name);
    } else if (str_eq(expr.kind, "_(_)")) {
        fprintf(file, "(%s", expr.sym.name);
        var i = 0;
        while (i < expr.arg_count) {
            fprintf(file, " ");
            print_expr(file, expr.args[i]);
            i += 1;
        }
        fprintf(file, ")");
    } else if (str_eq(expr.kind, "_._")) {
        var lhs = expr.args[0];
        var field_name = lhs.type.field_names[expr.field_index];
        fprintf(file, "(.%s ", field_name);
        print_expr(file, lhs);
        fprintf(file, ")");
    } else {
        fprintf(file, "(%s ", expr.kind);
        var i = 0;
        while (i < expr.arg_count) {
            print_expr(file, expr.args[i]);
            if (i < expr.arg_count - 1) {
                fprintf(file, " ");
            }
            i += 1;
        }
        fprintf(file, ")");
    }
}

//= Constant Folding

func const_eval(e: *Expr): Int {
    if (str_eq(e.kind, "<int>")) {
        return e.int_val;
    } else if (str_eq(e.kind, "-_")) {
        return -const_eval(e.args[0]);
    } else if (str_eq(e.kind, "_+_")) {
        return const_eval(e.args[0]) + const_eval(e.args[1]);
    } else if (str_eq(e.kind, "_-_")) {
        return const_eval(e.args[0]) - const_eval(e.args[1]);
    } else {
        error_at(&e.pos);
        fprintf(stderr, "Failed to evaluate constant expression.\n", e.kind);
        exit(1);
    }
}

//= Type Checking

func copy_expr(expr: *Expr): *Expr {
    var copy = mk_expr(expr.kind, expr.type, &expr.pos);
    *copy = *expr;
    return copy;
}

func try_coerce(expr: *Expr, target: *Type) {
    if (type_eq(expr.type, target))
        return;
    if (type_le(expr.type, target)) {
        *expr = *mk_cast_expr(copy_expr(expr), target);
    } else if (str_eq(expr.kind, "<int>") && target.kind == Type_Int) {
        var size = ilog2(expr.int_val) + 1;
        if (size < target.size) {
            expr.type = target;
        }
    }
}

func check_type(e: *Expr, expected: *Type) {
    try_coerce(e, expected);
    if (expected.kind == Type_Ptr && expected.base.kind == Type_Void && e.type.kind == Type_Ptr)
        return;
    if (!type_eq(e.type, expected)) {
        error_at(&e.pos);
        fprintf(stderr, "Type mismatch: ");
        print_type(stderr, e.type);
        fprintf(stderr, " != ");
        print_type(stderr, expected);
        fprintf(stderr, ".\n");
        exit(1);
    }
}

func check_type_int(e: *Expr) {
    if (e.type.kind != Type_Int) {
        error_at(&e.pos);
        fprintf(stderr, "Integer type expected.\n");
        exit(1);
    }
}

func check_type_bool(e: *Expr) {
    check_type(e, mk_bool_type());
}

func unify_types(e1: *Expr, e2: *Expr) {
    try_coerce(e2, e1.type);
    try_coerce(e1, e2.type);
    check_type(e2, e1.type);
}

//= Characters

var chr: Char;
var chr_pos: Pos;

func next_char() {
    if (chr_pos.line == 0) {
        chr_pos.line = 1;
    }
    if (chr == '\n') {
        chr_pos.line += 1;
        chr_pos.col = 1;
    } else {
        chr_pos.col += 1;
    }
    chr = getchar() as Char;
}

func is_space(c: Char): Bool {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}

func is_print(c: Char): Bool {
    return c >= 32 as Char && c <= 126 as Char;
}

func is_digit(c: Char): Bool {
    return c >= '0' && c <= '9';
}

func is_alpha(c: Char): Bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

func is_operator(c: Char): Bool {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '=' || c == '!' || c == '<' || c == '>' ||
           c == '&' || c == '|' || c == '.';
}

//= Tokens

enum {
    Tok_Eof,
    Tok_Int,
    Tok_Chr,
    Tok_Str,
    Tok_Wrd,
    Tok_Sym,
}

var tok: Int;
var tok_pos: Pos;
var lexeme: *Char;

func scan_char() {
    var c: Char;
    if (chr == '\\') {
        next_char();
        if (chr == '0') {
            c = '\0';
        } else if (chr == 'n') {
            c = '\n';
        } else if (chr == 'r') {
            c = '\r';
        } else if (chr == 't') {
            c = '\t';
        } else if (chr == '\\') {
            c = '\\';
        } else if (chr == '\'') {
            c = '\'';
        } else if (chr == '\"') {
            c = '\"';
        } else {
            error_at(&chr_pos);
            fprintf(stderr, "Invalid escape sequence.\n");
            exit(1);
        }
    } else if (is_print(chr)) {
        c = chr;
    } else {
        error_at(&chr_pos);
        fprintf(stderr, "Illegal character.\n");
        exit(1);
    }
    sb_push(&lexeme, c);
    next_char();
}

func next_tok() {
    tok_pos = chr_pos;
    lexeme = null;
    if (chr == -1) {
        tok = Tok_Eof;
    } else if (is_space(chr)) {
        next_char();
        return next_tok();
    } else if (is_digit(chr)) {
        while (is_digit(chr)) {
            sb_push(&lexeme, chr);
            next_char();
        }
        tok = Tok_Int;
    } else if (chr == '\'') {
        next_char();
        if (chr == '\'') {
            error_at(&chr_pos);
            fprintf(stderr, "Empty character.\n");
            exit(1);
        }
        scan_char();
        if (chr != '\'') {
            error_at(&chr_pos);
            fprintf(stderr, "Expected closing quote.\n");
            exit(1);
        }
        next_char();
        tok = Tok_Chr;
    } else if (chr == '\"') {
        next_char();
        while (chr != -1 && chr != '\"') {
            scan_char();
        }
        if (chr != '\"') {
            error_at(&chr_pos);
            fprintf(stderr, "Expected closing quote.\n");
            exit(1);
        }
        next_char();
        tok = Tok_Str;
    } else if (is_alpha(chr) || chr == '_') {
        while (is_alpha(chr) || is_digit(chr) || chr == '_') {
            sb_push(&lexeme, chr);
            next_char();
        }
        tok = Tok_Wrd;
    } else if (is_operator(chr)) {
        while (is_operator(chr)) {
            sb_push(&lexeme, chr);
            next_char();
            if (str_eq(lexeme, "//")) {
                while (chr != '\n' && chr != -1) {
                    next_char();
                }
                return next_tok();
            }
        }
        tok = Tok_Sym;
    } else {
        sb_push(&lexeme, chr);
        next_char();
        tok = Tok_Sym;
    }
    sb_push(&lexeme, '\0');
}

//= Parsing

func at(str: *Char): Bool {
    return (tok == Tok_Sym || tok == Tok_Wrd) && str_eq(lexeme, str);
}

func eat(str: *Char): Bool {
    if (!at(str))
        return false;
    next_tok();
    return true;
}

func expect(str: *Char) {
    if (!eat(str)) {
        error_at(&tok_pos);
        fprintf(stderr, "'%s' expected.\n", str);
        exit(1);
    }
}

func p_lexeme(): *Char {
    var prev_lexeme = lexeme;
    next_tok();
    return prev_lexeme;
}

func p_ident(): *Char {
    if (tok != Tok_Wrd) {
        error_at(&tok_pos);
        fprintf(stderr, "Identifier expected.\n");
        exit(1);
    }
    return p_lexeme();
}

func p_comma(end: *Char) {
    if (!eat(",") && !at(end)) {
        error_at(&tok_pos);
        fprintf(stderr, "',' or '%s' expected.\n", end);
        exit(1);
    }
}

//= Codegen

var label_count: Int;
var temp_size: Int;

func next_label(): Int {
    label_count += 1;
    return label_count;
}

func strx(type: *Type): *Char {
    if (type_size(type) == 1)
        return "strb w";
    if (type_size(type) == 2)
        return "strh w";
    if (type_size(type) == 4)
        return "str w";
    if (type_size(type) == 8)
        return "str x";
    assert(false, "strx: Unreachable.");
}

func ldrx(type: *Type): *Char {
    if (type.kind == Type_Bool)
        return "ldrb w";
    if (type.kind == Type_Int && type.size == 1)
        return "ldrsb x";
    if (type.kind == Type_Int && type.size == 2)
        return "ldrsh x";
    if (type.kind == Type_Int && type.size == 4)
        return "ldrsw x";
    if (type_size(type) == 8)
        return "ldr x";
    assert(false, "ldrx: Unreachable.");
}

func emit_push(reg: Int) {
    temp_size += 8;
    printf("  str x%d, [fp, #%d] // push\n", reg, -FRAME_LOCALS_SIZE - temp_size);
}

func emit_pop(reg: Int) {
    printf("  ldr x%d, [fp, #%d] // pop\n", reg, -FRAME_LOCALS_SIZE - temp_size);
    temp_size -= 8;
}

func emit_sign_extend(source: *Type, t0: Int, t1: Int) {
    assert(is_scalar(source), "emit_sign_extend: source should be a scalar.");
    if (source.kind == Type_Int && source.size < 8) {
        var suffix = "_bh_w"[source.size];
        printf("  sxt%c x%d, w%d\n", suffix, t0, t1);
    } else {
        if (t0 != t1) {
            printf("  mov x%d, x%d\n", t0, t1);
        }
    }
}

func emit_expr(e: *Expr, t0: Int);

func emit_expr_lvalue(e: *Expr, t0: Int);

func emit_operands(e: *Expr, t0: Int, t1: Int) {
    emit_expr(e.args[0], t0);
    emit_push(t0);
    emit_expr(e.args[1], t1);
    emit_pop(t0);
}

func emit_operands_lvalue(e: *Expr, t0: Int, t1: Int) {
    emit_expr_lvalue(e.args[0], t0);
    emit_push(t0);
    emit_expr(e.args[1], t1);
    emit_pop(t0);
}

func emit_expr_binary(op: *Char, e: *Expr, t0: Int) {
    emit_operands(e, 0, 1);
    printf("  %s x%d, x%d, x%d\n", op, t0, 0, 1);
}

func emit_expr_cmp(op: *Char, e: *Expr, t0: Int) {
    emit_operands(e, 0, 1);
    printf("  cmp x%d, x%d\n", 0, 1);
    printf("  cset x%d, %s\n", t0, op);
}

func emit_expr_lvalue(e: *Expr, t0: Int) {
    if (str_eq(e.kind, "<var>") && e.sym.kind == Sym_Local) {
        var name = e.sym.name;
        printf("  add x%d, fp, #%d // &%s\n", t0, -e.sym.offset, name);
    } else if (str_eq(e.kind, "<var>") && e.sym.kind == Sym_Global) {
        var name = e.sym.name;
        if (e.sym.is_extern) {
            printf("  adrp x%d, :got:%s\n", t0, name);
            printf("  ldr x%d, [x%d, :got_lo12:%s] // &%s\n", t0, t0, name, name);
        } else {
            printf("  adrp x%d, %s\n", t0, name);
            printf("  add x%d, x%d, :lo12:%s // &%s\n", t0, t0, name, name);
        }
    } else if (str_eq(e.kind, "_._")) {
        var lhs_type = e.args[0].type;
        var field_name = lhs_type.field_names[e.field_index];
        var field_offset = lhs_type.field_offsets[e.field_index];
        emit_expr_lvalue(e.args[0], t0);
        printf("  add x%d, x%d, #%d // &%s\n", t0, t0, field_offset, field_name);
    } else if (str_eq(e.kind, "*_")) {
        emit_expr(e.args[0], t0);
    } else if (str_eq(e.kind, "_[_]")) {
        if (e.args[0].type.kind == Type_Ptr) {
            emit_operands(e, 0, 1);
        } else {
            emit_operands_lvalue(e, 0, 1);
        }
        var elem_size = type_size(e.args[0].type.base);
        printf("  add x%d, x0, x1, lsl #%d // &_[_]\n", t0, ilog2(elem_size));
    } else {
        assert(false, "emit_expr_lvalue: Unreachable.");
    }
}

func emit_expr(e: *Expr, t0: Int) {
    if (is_lvalue(e)) {
        emit_expr_lvalue(e, t0);
        printf("  %s%d, [x%d]\n", ldrx(e.type), t0, t0);
    } else if (str_eq(e.kind, "<int>")) {
        printf("  mov x%d, #%d\n", t0, e.int_val);
    } else if (str_eq(e.kind, "<str>")) {
        var label = next_label();
        printf("  .text\n");
        printf("  .section .rodata\n");
        printf("  .align 3\n");
        printf(".str.%d:\n", label);
        printf("  .string \"");
        var i = 0;
        while (e.str_val[i] != '\0') {
            if (!is_print(e.str_val[i]) || e.str_val[i] == '\"' || e.str_val[i] == '\\') {
                printf("\\%03o", e.str_val[i]);
            } else {
                printf("%c", e.str_val[i]);
            }
            i += 1;
        }
        printf("\"\n");
        printf("  .text\n");
        printf("  adrp x%d, .str.%d\n", t0, label);
        printf("  add x%d, x%d, :lo12:.str.%d\n", t0, t0, label);
    } else if (str_eq(e.kind, "_(_)")) {
        var sym = e.sym;
        var i = 0;
        while (i < e.arg_count) {
            emit_expr(e.args[i], 0);
            if (i >= MAX_PARAMS) {
                printf("  str x0, [sp, #%d]\n", 8 * (i - sym.param_count));
            } else {
                emit_push(0);
            }
            i += 1;
        }
        i = int_min(e.arg_count, MAX_PARAMS);
        while (i > 0) {
            i -= 1;
            emit_pop(i);
        }
        printf("  bl %s\n", e.sym.name);
        if (e.type.kind != Type_Void) {
            emit_sign_extend(e.type, t0, 0);
        }
    } else if (str_eq(e.kind, "&_")) {
        emit_expr_lvalue(e.args[0], t0);
    } else if (str_eq(e.kind, "!_")) {
        emit_expr(e.args[0], t0);
        printf("  eor x%d, x%d, #1\n", t0, t0);
    } else if (str_eq(e.kind, "~_")) {
        emit_expr(e.args[0], t0);
        printf("  mvn x%d, x%d\n", t0, t0);
    } else if (str_eq(e.kind, "-_")) {
        emit_expr(e.args[0], t0);
        printf("  neg x%d, x%d\n", t0, t0);
    } else if (str_eq(e.kind, "_&&_") || str_eq(e.kind, "_||_")) {
        var label = next_label();
        printf(".L%d.begin: // %s\n", label, e.kind);
        emit_expr(e.args[0], t0);
        if (str_eq(e.kind, "_&&_")) {
            printf("  cbz x%d, .L%d.end\n", t0, label);
        } else {
            printf("  cbnz x%d, .L%d.end\n", t0, label);
        }
        emit_expr(e.args[1], t0);
        printf(".L%d.end:\n", label);
    } else if (str_eq(e.kind, "_|_")) {
        emit_expr_binary("orr", e, t0);
    } else if (str_eq(e.kind, "_^_")) {
        emit_expr_binary("eor", e, t0);
    } else if (str_eq(e.kind, "_&_")) {
        emit_expr_binary("and", e, t0);
    } else if (str_eq(e.kind, "_==_")) {
        emit_expr_cmp("eq", e, t0);
    } else if (str_eq(e.kind, "_!=_")) {
        emit_expr_cmp("ne", e, t0);
    } else if (str_eq(e.kind, "_<_")) {
        emit_expr_cmp("lt", e, t0);
    } else if (str_eq(e.kind, "_<=_")) {
        emit_expr_cmp("le", e, t0);
    } else if (str_eq(e.kind, "_>_")) {
        emit_expr_cmp("gt", e, t0);
    } else if (str_eq(e.kind, "_>=_")) {
        emit_expr_cmp("ge", e, t0);
    } else if (str_eq(e.kind, "_<<_")) {
        emit_expr_binary("lsl", e, t0);
    } else if (str_eq(e.kind, "_>>_")) {
        emit_expr_binary("lsr", e, t0);
    } else if (str_eq(e.kind, "_+_")) {
        emit_expr_binary("add", e, t0);
    } else if (str_eq(e.kind, "_-_")) {
        emit_expr_binary("sub", e, t0);
    } else if (str_eq(e.kind, "_*_")) {
        emit_expr_binary("mul", e, t0);
    } else if (str_eq(e.kind, "_/_")) {
        emit_expr_binary("sdiv", e, t0);
    } else if (str_eq(e.kind, "_%_")) {
        emit_operands(e, 1, 2);
        printf("  sdiv x%d, x%d, x%d\n", 0, 1, 2);
        printf("  msub x%d, x%d, x%d, x%d\n", t0, 0, 2, 1);
    } else if (str_eq(e.kind, "_?_:_")) {
        var label = next_label();
        printf(".L%d.if:\n", label);
        emit_expr(e.args[0], 0);
        printf("  cbz x0, .L%d.else\n", label);
        printf(".L%d.then:\n", label);
        emit_expr(e.args[1], t0);
        printf("  b .L%d.end\n", label);
        printf(".L%d.else:\n", label);
        emit_expr(e.args[2], t0);
        printf(".L%d.end:\n", label);
    } else if (str_eq(e.kind, "_=_") || str_eq(e.kind, "_+=_") || str_eq(e.kind, "_-=_")) {
        var lhs = e.args[0];
        emit_operands_lvalue(e, 0, 1);
        if (str_eq(e.kind, "_+=_") || str_eq(e.kind, "_-=_")) {
            printf("  %s2, [x0]\n", ldrx(lhs.type));
            if (str_eq(e.kind, "_+=_")) {
                printf("  add x1, x2, x1\n");
            } else if (str_eq(e.kind, "_-=_")) {
                printf("  sub x1, x2, x1\n");
            } else {
                assert(false, "emit_expr: Unreachable.");
            }
        }
        printf("  %s1, [x0]\n", strx(lhs.type));
    } else if (str_eq(e.kind, "<memcpy>")) {
        emit_operands(e, 0, 1);
        printf("  mov x2, #%d\n", type_size(e.args[0].type.base));
        printf("  bl memcpy\n");
    } else if (str_eq(e.kind, "<cast>")) {
        var target = e.type;
        var source = e.args[0].type;
        assert(is_scalar(target) && is_scalar(source), "emit_expr: <cast> should have scalar types.");
        emit_expr(e.args[0], t0);
        if (target.kind == Type_Bool) {
            printf("  cmp x%d, #0\n", t0);
            printf("  cset w%d, ne\n", t0);
        } else if (type_size(target) < type_size(source)) {
            emit_sign_extend(target, t0, t0);
        } else {
            // no-op
        }
    } else {
        assert(false, "emit_expr: Unreachable.");
    }
}

//= Grammar

func p_const_expr(): Int;

func p_type(): *Type {
    if (eat("(")) {
        var type = p_type();
        expect(")");
        return type;
    } else if (eat("Void")) {
        return mk_void_type();
    } else if (eat("Bool")) {
        return mk_bool_type();
    } else if (eat("Char") || eat("Int8")) {
        return mk_int_type(1);
    } else if (eat("Int16")) {
        return mk_int_type(2);
    } else if (eat("Int32")) {
        return mk_int_type(4);
    } else if (eat("Int") || eat("Int64")) {
        return mk_int_type(8);
    } else if (eat("*")) {
        return mk_ptr_type(p_type());
    } else if (eat("[")) {
        var type = p_type();
        expect(";");
        var len = p_const_expr();
        expect("]");
        return mk_array_type(type, len);
    } else if (tok == Tok_Wrd) {
        var sym = find_sym(lexeme, 0);
        if (!sym) {
            error_at(&tok_pos);
            fprintf(stderr, "Undeclared symbol '%s'.\n", lexeme);
            exit(1);
        }
        if (sym.kind != Sym_Type) {
            error_at(&tok_pos);
            fprintf(stderr, "'%s' is not a type.\n", lexeme);
            exit(1);
        }
        next_tok();
        return sym.type;
    } else {
        error_at(&tok_pos);
        fprintf(stderr, "Type expected.\n");
        exit(1);
    }
}

enum {
    Prec_Assign,
    Prec_Cond,
    Prec_CondOr,
    Prec_CondAnd,
    Prec_BitOr,
    Prec_BitXor,
    Prec_BitAnd,
    Prec_Cmp,
    Prec_Shift,
    Prec_Add,
    Prec_Mul,
    Prec_Cast,
    Prec_Unary,
    Prec_Postfix,
}

func build_unary_expr(op: *Char, rhs: *Expr): *Expr {
    if (str_eq(op, "*_")) {
        if (rhs.type.kind != Type_Ptr) {
            error_at(&rhs.pos);
            fprintf(stderr, "Pointer type expected.\n");
            exit(1);
        }
        return mk_expr_1("*_", rhs, rhs.type.base);
    } else if (str_eq(op, "&_")) {
        if (!is_lvalue(rhs)) {
            error_at(&rhs.pos);
            fprintf(stderr, "L-value expected.\n");
            exit(1);
        }
        return mk_expr_1("&_", rhs, mk_ptr_type(rhs.type));
    } else if (str_eq(op, "!_")) {
        check_type(rhs, mk_bool_type());
        return mk_expr_1("!_", rhs, mk_bool_type());
    } else {
        check_type_int(rhs);
        return mk_expr_1(op, rhs, rhs.type);
    }
}

func build_binary_expr(lhs: *Expr, op: *Char, rhs: *Expr): *Expr {
    if (str_eq(op, "_=_") || str_eq(op, "_+=_") || str_eq(op, "_-=_")) {
        if (!is_lvalue(lhs)) {
            error_at(&lhs.pos);
            fprintf(stderr, "L-value expected.\n");
            exit(1);
        }
        if (!str_eq(op, "_=_")) {
            check_type_int(lhs);
        }
        check_type(rhs, lhs.type);
        if (!is_scalar(lhs.type)) {
            assert(is_lvalue(lhs), "build_binary_expr: lhs must be an lvalue.");
            lhs = mk_expr_1("&_", lhs, mk_ptr_type(lhs.type));
            rhs = mk_expr_1("&_", rhs, mk_ptr_type(rhs.type));
            return mk_expr_2("<memcpy>", lhs, rhs, mk_void_type());
        } else {
            return mk_expr_2(op, lhs, rhs, mk_void_type());
        }
    } else if (str_eq(op, "_||_") || str_eq(op, "_&&_")) {
        check_type_bool(lhs);
        check_type_bool(rhs);
        return mk_expr_2(op, lhs, rhs, mk_bool_type());
    }  else if (str_eq(op, "_==_") || str_eq(op, "_!=_") || str_eq(op, "_<_") || str_eq(op, "_<=_") || str_eq(op, "_>_") || str_eq(op, "_>=_")) {
        unify_types(lhs, rhs);
        if (!is_scalar(lhs.type)) {
            error_at(&lhs.pos);
            fprintf(stderr, "Type ");
            print_type(stderr, lhs.type);
            fprintf(stderr, " is not comparable.\n");
            exit(1);
        }
        return mk_expr_2(op, lhs, rhs, mk_bool_type());
    } else {
        check_type_int(lhs);
        check_type_int(rhs);
        unify_types(lhs, rhs);
        return mk_expr_2(op, lhs, rhs, lhs.type);
    }
}

func p_expr(max_prec: Int): *Expr {
    var lhs: *Expr;
    if (eat("(")) {
        lhs = p_expr(0);
        expect(")");
    } else if (eat("null")) {
        lhs = mk_expr("<int>", mk_ptr_type(mk_void_type()), &tok_pos);
    } else if (at("true") || at("false")) {
        lhs = mk_expr("<int>", mk_bool_type(), &tok_pos);
        lhs.int_val = (eat("true") || !eat("false")) as Int;
    } else if (tok == Tok_Int) {
        lhs = mk_expr("<int>", mk_int_type(8), &tok_pos);
        lhs.int_val = atoi(p_lexeme());
    } else if (tok == Tok_Chr) {
        lhs = mk_expr("<int>", mk_int_type(1), &tok_pos);
        lhs.int_val = p_lexeme()[0];
    } else if (tok == Tok_Str) {
        lhs = mk_expr("<str>", mk_ptr_type(mk_int_type(1)), &tok_pos);
        lhs.str_val = p_lexeme();
    } else if (eat("sizeof")) {
        expect("(");
        var type = p_type();
        expect(")");
        lhs = mk_expr("<int>", mk_int_type(8), &tok_pos);
        lhs.int_val = type_size(type);
    } else if (tok == Tok_Wrd) {
        var name_pos = tok_pos;
        var name = p_ident();
        var sym = find_sym(name, 0);
        if (!sym) {
            error_at(&name_pos);
            fprintf(stderr, "Undeclared symbol '%s'.\n", name);
            exit(1);
        }
        if (eat("(")) {
            if (sym.kind != Sym_Func) {
                error_at(&name_pos);
                fprintf(stderr, "Function expected.\n");
                exit(1);
            }
            lhs = mk_expr("_(_)", sym.type, &name_pos);
            lhs.sym = sym;
            while (!eat(")")) {
                var arg = p_expr(0);
                p_comma(")");
                if (lhs.arg_count == MAX_PARAMS) {
                    error_at(&arg.pos);
                    fprintf(stderr, "Too many arguments.\n");
                    exit(1);
                }
                lhs.args[lhs.arg_count] = arg;
                lhs.arg_count += 1;
            }
            if (lhs.arg_count < sym.param_count) {
                error_at(&lhs.pos);
                fprintf(stderr, "Not enough arguments provided (%d < %d).\n", lhs.arg_count, sym.param_count);
                exit(1);
            }
            if (!sym.is_variadic && lhs.arg_count > sym.param_count) {
                error_at(&lhs.pos);
                fprintf(stderr, "Too many arguments provided (%d > %d).\n", lhs.arg_count, sym.param_count);
                exit(1);
            }
            var i = 0;
            while (i < sym.param_count) {
                check_type(lhs.args[i], sym.param_types[i]);
                i += 1;
            }
            while (i < lhs.arg_count) {
                if (!is_scalar(lhs.args[i].type)) {
                    error_at(&tok_pos);
                    fprintf(stderr, "Variadic argument must be scalar.\n");
                    exit(1);
                }
                i += 1;
            }
        } else {
            if (sym.kind == Sym_Local || sym.kind == Sym_Global) {
                lhs = mk_expr("<var>", sym.type, &tok_pos);
                lhs.sym = sym;
            } else if (sym.kind == Sym_Const) {
                lhs = mk_expr("<int>", sym.type, &tok_pos);
                lhs.int_val = sym.value;
            } else {
                error_at(&tok_pos);
                fprintf(stderr, "'%s' is not a variable or constant.\n", name);
                exit(1);
            }
        }
    } else if (max_prec <= Prec_Unary && eat("*")) {
        lhs = build_unary_expr("*_", p_expr(Prec_Unary));
    } else if (max_prec <= Prec_Unary && eat("&")) {
        lhs = build_unary_expr("&_", p_expr(Prec_Unary));
    } else if (max_prec <= Prec_Unary && (eat("!"))) {
        lhs = build_unary_expr("!_", p_expr(Prec_Unary));
    } else if (max_prec <= Prec_Unary && eat("~")) {
        lhs = build_unary_expr("~_", p_expr(Prec_Unary));
    } else if (max_prec <= Prec_Unary && eat("-")) {
        lhs = build_unary_expr("-_", p_expr(Prec_Unary));
    } else {
        error_at(&tok_pos);
        fprintf(stderr, "Expression expected.\n");
        exit(1);
    }

    while (true) {
        if (max_prec <= Prec_Assign && eat("=")) {
            lhs = build_binary_expr(lhs, "_=_", p_expr(Prec_Assign + 1));
        } else if (max_prec <= Prec_Assign && eat("+=")) {
            lhs = build_binary_expr(lhs, "_+=_", p_expr(Prec_Assign + 1));
        } else if (max_prec <= Prec_Assign && eat("-=")) {
            lhs = build_binary_expr(lhs, "_-=_", p_expr(Prec_Assign + 1));
        } else if (max_prec <= Prec_Cond && eat("?")) {
            var ift = p_expr(Prec_Cond);
            expect(":");
            var iff = p_expr(Prec_Cond);
            check_type_bool(lhs);
            unify_types(ift, iff);
            lhs = mk_expr_3("_?_:_", lhs, ift, iff, ift.type);
        } else if (max_prec <= Prec_CondOr && eat("||")) {
            lhs = build_binary_expr(lhs, "_||_", p_expr(Prec_CondOr + 1));
        } else if (max_prec <= Prec_CondAnd && eat("&&")) {
            lhs = build_binary_expr(lhs, "_&&_", p_expr(Prec_CondAnd + 1));
        } else if (max_prec <= Prec_BitOr && eat("|")) {
            lhs = build_binary_expr(lhs, "_|_", p_expr(Prec_BitOr + 1));
        } else if (max_prec <= Prec_BitXor && eat("^")) {
            lhs = build_binary_expr(lhs, "_^_", p_expr(Prec_BitXor + 1));
        } else if (max_prec <= Prec_BitAnd && eat("&")) {
            lhs = build_binary_expr(lhs, "_&_", p_expr(Prec_BitAnd + 1));
        } else if (max_prec <= Prec_Cmp && eat("==")) {
            lhs = build_binary_expr(lhs, "_==_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("!=")) {
            lhs = build_binary_expr(lhs, "_!=_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("<")) {
            lhs = build_binary_expr(lhs, "_<_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("<=")) {
            lhs = build_binary_expr(lhs, "_<=_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat(">")) {
            lhs = build_binary_expr(lhs, "_>_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat(">=")) {
            lhs = build_binary_expr(lhs, "_>=_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Shift && eat("<<")) {
            lhs = build_binary_expr(lhs, "_<<_", p_expr(Prec_Shift + 1));
        } else if (max_prec <= Prec_Shift && eat(">>")) {
            lhs = build_binary_expr(lhs, "_>>_", p_expr(Prec_Shift + 1));
        } else if (max_prec <= Prec_Add && eat("+")) {
            lhs = build_binary_expr(lhs, "_+_", p_expr(Prec_Add + 1));
        } else if (max_prec <= Prec_Add && eat("-")) {
            lhs = build_binary_expr(lhs, "_-_", p_expr(Prec_Add + 1));
        } else if (max_prec <= Prec_Mul && eat("*")) {
            lhs = build_binary_expr(lhs, "_*_", p_expr(Prec_Mul + 1));
        } else if (max_prec <= Prec_Mul && eat("/")) {
            lhs = build_binary_expr(lhs, "_/_", p_expr(Prec_Mul + 1));
        } else if (max_prec <= Prec_Mul && eat("%")) {
            lhs = build_binary_expr(lhs, "_%_", p_expr(Prec_Mul + 1));
        } else if (max_prec <= Prec_Cast && eat("as")) {
            var type = p_type();
            if (!(is_scalar(type) && is_scalar(lhs.type))) {
                error_at(&tok_pos);
                fprintf(stderr, "Invalid cast type.\n");
                exit(1);
            }
            lhs = mk_cast_expr(lhs, type);
        } else if (max_prec <= Prec_Postfix && eat("[")) {
            var rhs = p_expr(0);
            expect("]");
            if (lhs.type.kind != Type_Arr && lhs.type.kind != Type_Ptr) {
                error_at(&lhs.pos);
                fprintf(stderr, "Expression is not indexable.\n");
                exit(1);
            }
            check_type_int(rhs);
            lhs = mk_expr_2("_[_]", lhs, rhs, lhs.type.base);
        } else if (max_prec <= Prec_Postfix && eat(".")) {
            var field_name = p_ident();
            if (lhs.type.kind == Type_Ptr && lhs.type.base.kind == Type_Struct) {
                lhs = mk_expr_1("*_", lhs, lhs.type.base);
            }
            if (lhs.type.kind != Type_Struct) {
                error_at(&lhs.pos);
                fprintf(stderr, "Struct type expected.\n");
                exit(1);
            }
            var field_index = find_field(lhs.type, field_name);
            if (field_index == -1) {
                error_at(&tok_pos);
                fprintf(stderr, "Unknown field '%s'.\n", field_name);
                exit(1);
            }
            var field_type = lhs.type.field_types[field_index];
            lhs = mk_expr_1("_._", lhs, field_type);
            lhs.field_index = field_index;
        } else {
            return lhs;
        }
    }
}

func p_const_expr(): Int {
    var expr = p_expr(0);
    check_type_int(expr);
    return const_eval(expr);
}

func p_stmt() {
    if (eat("{")) {
        enter_scope();
        while (!eat("}")) {
            p_stmt();
        }
        leave_scope();
    } else if (eat("var")) {
        var name_pos = tok_pos;
        var name = p_ident();
        var type: *Type = null;
        if (eat(":")) {
            type = p_type();
        }
        var init: *Expr = null;
        if (eat("=")) {
            init = p_expr(0);
        }
        expect(";");

        if (type != null) {
            if (init != null) {
                check_type(init, type);
            }
        } else {
            if (init != null) {
                type = init.type;
            } else {
                error_at(&name_pos);
                fprintf(stderr, "Type or initializer expected.\n");
                exit(1);
            }
        }
        if (type_size(type) == -1) {
            error_at(&name_pos);
            fprintf(stderr, "Variable must have a size.\n");
            exit(1);
        }

        var sym = add_local(name, type, &name_pos);

        if (init != null) {
            var dest = mk_expr("<var>", type, &name_pos);
            dest.sym = sym;
            emit_expr(build_binary_expr(dest, "_=_", init), 0);
        }
    } else if (eat("if")) {
        var label = next_label();
        printf(".L%d.if:\n", label);
        expect("(");
        var cond = p_expr(0);
        check_type_bool(cond);
        expect(")");
        emit_expr(cond, 0);
        printf("  cbz x0, .L%d.else\n", label);
        printf(".L%d.then:\n", label);
        p_stmt();
        printf("  b .L%d.end\n", label);
        printf(".L%d.else:\n", label);
        if (eat("else")) {
            p_stmt();
        }
        printf(".L%d.end:\n", label);
    } else if (eat("while")) {
        var label = next_label();
        var outer_loop = current_loop;
        current_loop = label;
        printf(".L%d.next:\n", label);
        expect("(");
        var cond = p_expr(0);
        check_type_bool(cond);
        expect(")");
        emit_expr(cond, 0);
        printf("  cbz x0, .L%d.done\n", label);
        printf(".L%d.do:\n", label);
        p_stmt();
        printf("  b .L%d.next\n", label);
        printf(".L%d.done:\n", label);
        current_loop = outer_loop;
    } else if (eat("break")) {
        expect(";");
        if (current_loop == 0) {
            error_at(&tok_pos);
            fprintf(stderr, "Break statement outside of loop.\n");
            exit(1);
        }
        printf("  b .L%d.done\n", current_loop);
    } else if (eat("continue")) {
        expect(";");
        if (current_loop == 0) {
            error_at(&tok_pos);
            fprintf(stderr, "Continue statement outside of loop.\n");
            exit(1);
        }
        printf("  b .L%d.next\n", current_loop);
    } else if (eat("return")) {
        var expr: *Expr = null;
        if (!at(";")) {
            expr = p_expr(0);
        }
        expect(";");

        if (expr) {
            check_type(expr, current_func.type);
            emit_expr(expr, 0);
        } else if (current_func.type.kind != Type_Void) {
            error_at(&tok_pos);
            fprintf(stderr, "Return value expected.\n");
            exit(1);
        }
        printf("  b .L.%s.ret\n", current_func.name);
    } else {
        var expr = p_expr(0);
        expect(";");
        emit_expr(expr, 0);
    }
}

func emit_param_store(sym: *Sym) {
    var i = 0;
    while (i < sym.param_count) {
        var sym = find_sym(sym.param_names[i], 0);
        printf("  %s%d, [fp, #%d] // %s\n", strx(sym.type), i, -sym.offset, sym.name);
        i += 1;
    }
}

func p_func(is_extern: Bool) {
    var name_pos = tok_pos;
    var name = p_ident();
    var sym = mk_sym(Sym_Func, name);
    sym.type = mk_void_type();
    sym.is_extern = is_extern;
    current_func = sym;

    enter_scope();
    add_sym(sym, &name_pos);
    expect("(");
    while (!at(")") && !at("...")) {
        var param_pos = tok_pos;
        var param_name = p_ident();
        expect(":");
        var param_type = p_type();
        p_comma(")");

        if (sym.param_count == MAX_PARAMS) {
            error_at(&tok_pos);
            fprintf(stderr, "Too many parameters.\n");
            exit(1);
        }
        if (!is_scalar(param_type)) {
            error_at(&param_pos);
            fprintf(stderr, "Parameter must be of scalar type.\n");
            exit(1);
        }
        sym.param_names[sym.param_count] = param_name;
        sym.param_types[sym.param_count] = param_type;
        sym.param_count += 1;

        add_local(param_name, param_type, &param_pos);
    }
    if (eat("...")) {
        sym.is_variadic = true;
    }
    expect(")");
    if (eat(":")) {
        sym.type = p_type();
    }
    if (!is_extern && at("{")) {
        sym.defined = true;
        printf("  .text\n");
        printf("  .align 2\n");
        printf("  .global %s\n", name);
        printf("%s:\n", name);
        printf("  stp x29, x30, [sp, #-16]!\n");
        printf("  mov x29, sp\n");
        printf("  sub sp, sp, #%d\n", FRAME_SIZE);
        emit_param_store(sym);
        p_stmt();
        printf(".L.%s.ret:\n", name);
        printf("  add sp, sp, #%d\n", FRAME_SIZE);
        printf("  ldp x29, x30, [sp], #16\n");
        printf("  ret\n");
    } else {
        expect(";");
    }
    leave_scope();
    add_sym(sym, &name_pos);
}

func p_decl() {
    var is_extern = false;
    if (eat("extern")) {
        if (!at("func") && !at("var") && !at("struct")) {
            error_at(&tok_pos);
            fprintf(stderr, "External declaration expected.\n");
            exit(1);
        }
        is_extern = true;
    }

    if (eat("func")) {
        p_func(is_extern);
    } else if (eat("var")) {
        var name = p_ident();
        expect(":");
        var type = p_type();
        expect(";");
        add_global(is_extern, name, type, &tok_pos);
        if (!is_extern) {
            printf("  .global %s\n", name);
            printf("  .bss\n");
            printf(".align %d\n", type_align(type));
            printf("%s:\n", name);
            printf("  .zero %d\n", type_size(type));
        }
    } else if (eat("const")) {
        var name = p_ident();
        expect("=");
        var value = p_const_expr();
        expect(";");
        add_const(name, value, &tok_pos);
    } else if (eat("struct")) {
        var name = p_ident();
        var sym = mk_sym(Sym_Type, name);
        sym.type = mk_struct_type(name);
        add_sym(sym, &tok_pos);
        if (!is_extern) {
            expect("{");
            while (!eat("}")) {
                var field_name = p_ident();
                expect(":");
                var field_type = p_type();
                p_comma("}");
                add_field(sym.type, field_name, field_type);
            }
        } else {
            expect(";");
        }
    } else if (eat("enum")) {
        var value = 0;
        expect("{");
        while (!eat("}")) {
            var name = p_ident();
            if (eat("=")) {
                value = p_const_expr();
            }
            p_comma("}");
            add_const(name, value, &tok_pos);
            value += 1;
        }
    } else {
        error_at(&tok_pos);
        fprintf(stderr, "Declaration expected.\n");
        exit(1);
    }
}

func main(): Int {
    next_char();
    next_tok();
    while (tok != Tok_Eof) {
        p_decl();
    }
    return 0;
}
