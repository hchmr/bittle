// stdio
extern struct File;
extern var stdin: *File;
extern var stdout: *File;
extern var stderr: *File;

extern func printf(fmt: *Char, ...): Int32;
extern func fprintf(file: *File, fmt: *Char, ...): Int32;
extern func sprintf(buf: *Char, fmt: *Char, ...): Int32;
extern func fgetc(file: *File): Int32;
extern func fopen(filename: *Char, mode: *Char): *File;

// stdlib
extern func exit(status: Int32);
extern func calloc(count: Int, size: Int): *Void;
extern func malloc(size: Int): *Void;
extern func realloc(ptr: *Void, size: Int): *Void;
extern func atoi(s: *Char): Int;

// string
extern func strlen(s: *Char): Int;
extern func strcmp(a: *Char, b: *Char): Int32;
extern func memset(p: *Void, ch: Int32, count: Int): *Void;
extern func memcpy(dest: *Void, src: *Void, count: Int): *Void;
extern func strncat(dest: *Char, src: *Char, n: Int): *Char;

//= Misc

struct Pos {
    file: *Char,
    line: Int,
    col: Int,
}

func error_at(pos: *Pos) {
    var name = pos.file ? pos.file : "<stdin>";
    fprintf(stderr, "%s:%d:%d: Error: ", name, pos.line, pos.col);
}

func str_eq(a: *Char, b: *Char): Bool {
    return strcmp(a, b) == 0;
}

func align_up(size: Int , align: Int): Int {
    return (size + align - 1) / align * align;
}

func assert(cond: Bool, because: *Char) {
    if (!cond) {
        fprintf(stderr, "Assertion failed: %s\n", because);
        exit(1);
    }
}

func ilog2(n: Int): Int {
    var i = 0;
    while (n > 1) {
        n = n / 2;
        i += 1;
    }
    return i;
}

func int_min(a: Int, b: Int): Int {
    return a > b ? b : a;
}

func sb_push(buf_p: *(*Char), c: Char): Void {
    var len = *buf_p ? strlen(*buf_p) : 0;
    *buf_p = realloc(*buf_p, len + 2);
    (*buf_p)[len] = c;
    (*buf_p)[len + 1] = '\0';
}

func get_directory(path: *Char): *Char {
    var i = strlen(path);
    while (true) {
        if (i == 0)
            return ".";
        i -= 1;
        if (path[i] == '/') {
            var dir = malloc(i + 1) as *Char;
            memcpy(dir, path, i);
            dir[i] = '\0';
            return dir;
        }
    }
}

//= Codegen Constants

const FRAME_SIZE_MAX = 4096;
const FRAME_TEMP_SIZE = 128;
const FRAME_ARGS_SIZE = 64;
const FRAME_LOCALS_SIZE_MAX = FRAME_SIZE_MAX - FRAME_ARGS_SIZE - FRAME_TEMP_SIZE;

//= Type System

enum {
    Type_Void,
    Type_Bool,
    Type_Int,
    Type_Ptr,
    Type_Arr,
    Type_Struct,
}

struct Type {
    kind: Int,
    // Int
    size: Int,
    // Ptr, Array
    base: *Type,
    // Array
    len: Int,
    name: *Char,
    field_names: *(*Char),
    field_types: *(*Type),
    field_offsets: *Int,
    field_count: Int,
    unpadded_size: Int,
}

func mk_type(kind: Int): *Type {
    var type: *Type = calloc(1, sizeof(Type));
    type.kind = kind;
    return type;
}

func mk_void_type(): *Type {
    return mk_type(Type_Void);
}

func mk_bool_type(): *Type {
    return mk_type(Type_Bool);
}

func mk_int_type(size: Int): *Type {
    var type = mk_type(Type_Int);
    type.size = size;
    return type;
}

func mk_ptr_type(base: *Type): *Type {
    var type = mk_type(Type_Ptr);
    type.base = base;
    return type;
}

func mk_array_type(base: *Type, len: Int): *Type {
    var type = mk_type(Type_Arr);
    type.base = base;
    type.len = len;
    return type;
}

func mk_struct_type(name: *Char): *Type {
    var type = mk_type(Type_Struct);
    type.name = name;
    return type;
}

func type_align(type: *Type): Int {
    if (type.kind == Type_Void)
        return 1;
    if (type.kind == Type_Bool)
        return 1;
    if (type.kind == Type_Int)
        return type.size;
    if (type.kind == Type_Ptr)
        return 8;
    if (type.kind == Type_Arr)
        return type_align(type.base);
    if (type.kind == Type_Struct)
        return 8; // Maximum possible alignment.
    assert(false, "type_align: Unreachable.");
}

func type_size(type: *Type): Int {
    if (type.kind == Type_Void)
        return -1;
    if (type.kind == Type_Bool)
        return 1;
    if (type.kind == Type_Int)
        return type.size;
    if (type.kind == Type_Ptr)
        return 8;
    if (type.kind == Type_Arr)
        return type.len * align_up(type_size(type.base), type_align(type.base));
    if (type.kind == Type_Struct)
        return type.field_count == 0 ? -1 : align_up(type.unpadded_size, type_align(type));
    assert(false, "type_size: Unreachable.");
}

func type_eq(t1: *Type, t2: *Type): Bool {
    if (t1.kind != t2.kind)
        return false;
    if (t1.kind == Type_Int)
        return t1.size == t2.size;
    if (t1.kind == Type_Ptr)
        return type_eq(t1.base, t2.base);
    if (t1.kind == Type_Arr)
        return t1.len == t2.len && type_eq(t1.base, t2.base);
    if (t1.kind == Type_Struct)
        return t1 == t2;
    return true;
}

func is_scalar(type: *Type): Bool {
    return type.kind == Type_Bool || type.kind == Type_Int || type.kind == Type_Ptr;
}

func type_le(t1: *Type, t2: *Type): Bool {
    if (is_scalar(t1) && t2.kind == Type_Bool)
        return true;
    if (t1.kind == Type_Int && t2.kind == Type_Int)
        return t1.size <= t2.size;
    if (t1.kind == Type_Ptr && t2.kind == Type_Ptr)
        return t1.base.kind == Type_Void;
    return false;
}

func find_field(type: *Type, name: *Char): Int {
    assert(type.kind == Type_Struct, "find_field: type should be a struct.");
    var i = 0;
    while (i < type.field_count) {
        if (str_eq(type.field_names[i], name)) {
            return i;
        }
        i += 1;
    }
    return -1;
}

func add_field(type: *Type, field_name: *Char, field_type: *Type, pos: *Pos) {
    assert(type.kind == Type_Struct, "add_field: type should be a struct.");

    var existing = find_field(type, field_name);
    if (existing != -1) {
        error_at(pos);
        fprintf(stderr, "Field '%s' is already defined.\n", field_name);
        exit(1);
    }

    if (type_size(field_type) == -1) {
        error_at(pos);
        fprintf(stderr, "Field '%s' has incomplete type.\n", field_name);
        exit(1);
    }

    var i = type.field_count;
    type.field_count += 1;
    type.field_names = realloc(type.field_names, type.field_count * sizeof(*Char));
    type.field_types = realloc(type.field_types, type.field_count * sizeof(*Type));
    type.field_offsets = realloc(type.field_offsets, type.field_count * sizeof(Int));
    type.field_names[i] = field_name;
    type.field_types[i] = field_type;
    type.field_offsets[i] = align_up(type.unpadded_size, type_align(field_type));
    type.unpadded_size = type.field_offsets[i] + type_size(field_type);
}

func print_type(file: *File, type: *Type) {
    if (type.kind == Type_Void) {
        fprintf(file, "Void");
    } else if (type.kind == Type_Bool) {
        fprintf(file, "Bool");
    } else if (type.kind == Type_Int) {
        fprintf(file, "Int%d", type.size * 8);
    } else if (type.kind == Type_Ptr) {
        fprintf(file, "*");
        print_type(file, type.base);
    } else if (type.kind == Type_Arr) {
        fprintf(file, "[");
        print_type(file, type.base);
        fprintf(file, "; %d]", type.len);
    } else if (type.kind == Type_Struct) {
        fprintf(file, "%s", type.name);
    } else {
        assert(false, "print_type: Unreachable.");
    }
}

//= Symbols

const MAX_PARAMS = 8;

enum {
    Sym_Type,
    Sym_Func,
    Sym_Global,
    Sym_Local,
    Sym_Const,
}

struct Sym {
    kind: Int,
    name: *Char,
    // Type, Function, Global, Local
    type: *Type,
    // Local variable
    offset: Int,
    // Function, Global, Type
    is_defined: Bool,
    // Global
    value: Int,
    // Function
    params: [*Sym; MAX_PARAMS + 1],
    param_count: Int,
    is_variadic: Bool,
    locals_size: Int,
    body: *Void, // FIXME: can't forward declare Expr
}

struct Env {
    parent: *Env,
    syms: *(*Sym),
    sym_count: Int,
    current_func: *Sym,
    current_loop: Int,
}

func mk_sym(kind: Int, name: *Char): *Sym {
    var sym: *Sym = calloc(1, sizeof(Sym));
    sym.kind = kind;
    sym.name = name;
    return sym;
}

func enter_scope(env: *(*Env)) {
    var new_env = calloc(1, sizeof(Env)) as *Env;
    new_env.parent = *env;
    new_env.current_func = new_env.parent.current_func;
    new_env.current_loop = new_env.parent.current_loop;
    *env = new_env;
}

func leave_scope(env: *(*Env)) {
    var old_env = *env;
    *env = old_env.parent;
}

func find_sym_scoped(env: *Env, name: *Char): *Sym {
    var i = env.sym_count;
    while (i > 0) {
        i -= 1;
        if (str_eq(env.syms[i].name, name))
            return env.syms[i];
    }
    return null;
}

func find_sym(env: *Env, name: *Char): *Sym {
    while (env) {
        var sym = find_sym_scoped(env, name);
        if (sym)
            return sym;
        env = env.parent;
    }
}

func func_eq(a: *Sym, b: *Sym): Bool {
    if (!str_eq(a.name, b.name))
        return false;
    if (a.param_count != b.param_count)
        return false;
    if (a.is_variadic != b.is_variadic)
        return false;
    if (!type_eq(a.type, b.type))
        return false;
    var i = 0;
    while (i < a.param_count) {
        if (!type_eq(a.params[i].type, b.params[i].type))
            return false;
        i += 1;
    }
    return true;
}

func decl_compat(existing: *Sym, new: *Sym): Bool {
    if (existing.kind != new.kind)
        return false;
    if (!str_eq(existing.name, new.name))
        return false;

    if (existing.kind == Sym_Type) {
        if (type_eq(existing.type, new.type))
            return !(existing.is_defined && new.is_defined);
    } else if (existing.kind == Sym_Func) {
        if (func_eq(existing, new))
            return !(existing.is_defined && new.is_defined);
    } else if (existing.kind == Sym_Global) {
        if (type_eq(existing.type, new.type))
            return !(existing.is_defined && new.is_defined);
    }
    return false;
}

func sym_merge(existing: *Sym, new: *Sym) {
    if (!existing.is_defined) {
        *existing = *new;
    }
}

func add_sym(env: *Env, sym: *Sym, pos: *Pos) {
    var existing = find_sym_scoped(env, sym.name);

    if (existing) {
        if (decl_compat(existing, sym)) {
            sym_merge(existing, sym);
        } else {
            error_at(pos);
            fprintf(stderr, "Symbol '%s' already defined.\n", sym.name);
            exit(1);
        }
    } else {
        env.sym_count += 1;
        env.syms = realloc(env.syms, env.sym_count * sizeof(Sym));
        env.syms[env.sym_count - 1] = sym;
    }
}

func add_local(env: *Env, name: *Char, type: *Type, pos: *Pos): *Sym {
    var func_ = env.current_func;
    func_.locals_size = align_up(func_.locals_size + type_size(type), type_align(type));
    if (func_.locals_size > FRAME_LOCALS_SIZE_MAX) {
        error_at(pos);
        fprintf(stderr, "Maximum local size exceeded.\n");
        exit(1);
    }

    var sym = mk_sym(Sym_Local, name);
    sym.type = type;
    sym.offset = func_.locals_size;

    add_sym(env, sym, pos);
    return sym;
}

func add_global(env: *Env, is_defined: Bool, name: *Char, type: *Type, pos: *Pos) {
    var sym = mk_sym(Sym_Global, name);
    sym.is_defined = is_defined;
    sym.type = type;
    add_sym(env, sym, pos);
}

func add_const(env: *Env, name: *Char, value: Int, pos: *Pos) {
    var sym = mk_sym(Sym_Const, name);
    sym.type = mk_int_type(4);
    sym.value = value;
    add_sym(env, sym, pos);
}

func declare_struct(env: *Env, name: *Char, pos: *Pos) {
    var existing = find_sym(env, name);
    var sym = mk_sym(Sym_Type, name);
    sym.type = existing ? existing.type : mk_struct_type(name);
    add_sym(env, sym, pos);
}

func define_struct(env: *Env, name: *Char, fields: *Type, pos: *Pos) {
    var sym = mk_sym(Sym_Type, name);
    sym.is_defined = true;
    sym.type = find_sym(env, name).type;
    add_sym(env, sym, pos);
    *sym.type = *fields;
}


//= Abstract Syntax Tree

struct Expr {
    kind: *Char,
    type: *Type,
    pos: Pos,
    // Null, Bool, Int
    int_val: Int,
    // Str
    str_val: *Char,
    // Var, Call
    sym: *Sym,
    // Subexpressions
    children: *(*Expr),
    child_count: Int,
    // Field
    field_index: Int,
}

func mk_expr(kind: *Char, type: *Type, pos: *Pos): *Expr {
    var expr: *Expr = calloc(1, sizeof(Expr));
    expr.kind = kind;
    expr.type = type;
    expr.pos = *pos;
    return expr;
}

func expr_add_child(expr: *Expr, child: *Expr) {
    expr.children = realloc(expr.children, (expr.child_count + 1) * sizeof(*Expr));
    expr.children[expr.child_count] = child;
    expr.child_count += 1;
}

func mk_expr_3(kind: *Char, e1: *Expr, e2: *Expr, e3: *Expr, type: *Type): *Expr {
    var expr = mk_expr(kind, type, &e1.pos);
    expr_add_child(expr, e1);
    expr_add_child(expr, e2);
    expr_add_child(expr, e3);
    return expr;
}

func mk_expr_2(kind: *Char, e1: *Expr, e2: *Expr, type: *Type): *Expr {
    var expr = mk_expr(kind, type, &e1.pos);
    expr_add_child(expr, e1);
    expr_add_child(expr, e2);
    return expr;
}

func mk_expr_1(kind: *Char, e1: *Expr, type: *Type): *Expr {
    var expr = mk_expr(kind, type, &e1.pos);
    expr_add_child(expr, e1);
    return expr;
}

func mk_cast_expr(expr: *Expr, type: *Type): *Expr {
    var cast = mk_expr("<cast>", type, &expr.pos);
    expr_add_child(cast, expr);
    return cast;
}

func is_lvalue(expr: *Expr): Bool {
    return str_eq(expr.kind, "<var>") || str_eq(expr.kind, "*_") || str_eq(expr.kind, "_._") || str_eq(expr.kind, "_[_]");
}

func print_expr(file: *File, expr: *Expr) {
    if (!expr) {
        fprintf(file, "<null>");
    } else if (str_eq(expr.kind, "<int>")) {
        fprintf(file, "%d", expr.int_val);
    } else if (str_eq(expr.kind, "<str>")) {
        fprintf(file, "\"%s\"", expr.str_val);
    } else if (str_eq(expr.kind, "<var>")) {
        fprintf(file, "%s", expr.sym.name);
    } else if (str_eq(expr.kind, "_(_)")) {
        fprintf(file, "(%s", expr.sym.name);
        var i = 0;
        while (i < expr.child_count) {
            fprintf(file, " ");
            print_expr(file, expr.children[i]);
            i += 1;
        }
        fprintf(file, ")");
    } else if (str_eq(expr.kind, "_._")) {
        var lhs = expr.children[0];
        var field_name = lhs.type.field_names[expr.field_index];
        fprintf(file, "(.%s ", field_name);
        print_expr(file, lhs);
        fprintf(file, ")");
    } else {
        fprintf(file, "(%s ", expr.kind);
        var i = 0;
        while (i < expr.child_count) {
            print_expr(file, expr.children[i]);
            if (i < expr.child_count - 1) {
                fprintf(file, " ");
            }
            i += 1;
        }
        fprintf(file, ")");
    }
}

//= Constant Folding

func const_eval(e: *Expr): Int {
    if (str_eq(e.kind, "<int>")) {
        return e.int_val;
    } else if (str_eq(e.kind, "-_")) {
        return -const_eval(e.children[0]);
    } else if (str_eq(e.kind, "_+_")) {
        return const_eval(e.children[0]) + const_eval(e.children[1]);
    } else if (str_eq(e.kind, "_-_")) {
        return const_eval(e.children[0]) - const_eval(e.children[1]);
    } else {
        error_at(&e.pos);
        fprintf(stderr, "Failed to evaluate constant expression.\n", e.kind);
        exit(1);
    }
}

//= Type Checking

func copy_expr(expr: *Expr): *Expr {
    var copy = mk_expr(expr.kind, expr.type, &expr.pos);
    *copy = *expr;
    return copy;
}

func try_coerce(expr: *Expr, target: *Type) {
    if (type_eq(expr.type, target))
        return;
    if (type_le(expr.type, target)) {
        *expr = *mk_cast_expr(copy_expr(expr), target);
    } else if (str_eq(expr.kind, "<int>") && target.kind == Type_Int) {
        var size = ilog2(expr.int_val) + 1;
        if (size < target.size) {
            expr.type = target;
        }
    }
}

func check_type(e: *Expr, expected: *Type) {
    try_coerce(e, expected);
    if (expected.kind == Type_Ptr && expected.base.kind == Type_Void && e.type.kind == Type_Ptr)
        return;
    if (!type_eq(e.type, expected)) {
        error_at(&e.pos);
        fprintf(stderr, "Type mismatch: ");
        print_type(stderr, e.type);
        fprintf(stderr, " != ");
        print_type(stderr, expected);
        fprintf(stderr, ".\n");
        exit(1);
    }
}

func check_type_int(e: *Expr) {
    if (e.type.kind != Type_Int) {
        error_at(&e.pos);
        fprintf(stderr, "Integer type expected.\n");
        exit(1);
    }
}

func check_type_bool(e: *Expr) {
    check_type(e, mk_bool_type());
}

func unify_types(e1: *Expr, e2: *Expr) {
    try_coerce(e2, e1.type);
    try_coerce(e1, e2.type);
    check_type(e2, e1.type);
}

//= Characters

func is_space(c: Char): Bool {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}

func is_print(c: Char): Bool {
    return c >= 32 as Char && c <= 126 as Char;
}

func is_digit(c: Char): Bool {
    return c >= '0' && c <= '9';
}

func is_alpha(c: Char): Bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

func is_operator(c: Char): Bool {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '=' || c == '!' || c == '<' || c == '>' ||
           c == '&' || c == '|' || c == '.';
}

//= Lexing

enum {
    Tok_Eof,
    Tok_Int,
    Tok_Chr,
    Tok_Str,
    Tok_Wrd,
    Tok_Sym,
}

struct Tok {
    kind: Int,
    pos: Pos,
    lexeme: *Char,
}

struct Lexer {
    file: *File,
    pos: Pos,
    chr: Char,
}

func lexer_init(self: *Lexer, file: *File, file_name: *Char) {
    self.file = file;
    self.pos.file = file_name;
    self.pos.line = 1;
}

func next_char(self: *Lexer) {
    if (self.chr == '\n') {
        self.pos.line += 1;
        self.pos.col = 1;
    } else {
        self.pos.col += 1;
    }
    self.chr = fgetc(self.file) as Char;
}

func scan_char(self: *Lexer, tok: *Tok) {
    var c: Char;
    if (self.chr == '\\') {
        next_char(self);
        if (self.chr == '0') {
            c = '\0';
        } else if (self.chr == 'n') {
            c = '\n';
        } else if (self.chr == 'r') {
            c = '\r';
        } else if (self.chr == 't') {
            c = '\t';
        } else if (self.chr == '\\') {
            c = '\\';
        } else if (self.chr == '\'') {
            c = '\'';
        } else if (self.chr == '\"') {
            c = '\"';
        } else {
            error_at(&self.pos);
            fprintf(stderr, "Invalid escape sequence.\n");
            exit(1);
        }
    } else if (is_print(self.chr)) {
        c = self.chr;
    } else {
        error_at(&self.pos);
        fprintf(stderr, "Illegal character.\n");
        exit(1);
    }
    sb_push(&tok.lexeme, c);
    next_char(self);
}

func scan_tok(self: *Lexer, tok: *Tok) {
    tok.pos = self.pos;
    tok.lexeme = null;
    if (self.chr == -1) {
        tok.kind = Tok_Eof;
    } else if (is_space(self.chr)) {
        next_char(self);
        return scan_tok(self, tok);
    } else if (is_digit(self.chr)) {
        while (is_digit(self.chr)) {
            sb_push(&tok.lexeme, self.chr);
            next_char(self);
        }
        tok.kind = Tok_Int;
    } else if (self.chr == '\'') {
        next_char(self);
        if (self.chr == '\'') {
            error_at(&self.pos);
            fprintf(stderr, "Empty character.\n");
            exit(1);
        }
        scan_char(self, tok);
        if (self.chr != '\'') {
            error_at(&self.pos);
            fprintf(stderr, "Expected closing quote.\n");
            exit(1);
        }
        next_char(self);
        tok.kind = Tok_Chr;
    } else if (self.chr == '\"') {
        next_char(self);
        while (self.chr != -1 && self.chr != '\"') {
            scan_char(self, tok);
        }
        if (self.chr != '\"') {
            error_at(&self.pos);
            fprintf(stderr, "Expected closing quote.\n");
            exit(1);
        }
        next_char(self);
        tok.kind = Tok_Str;
    } else if (is_alpha(self.chr) || self.chr == '_') {
        while (is_alpha(self.chr) || is_digit(self.chr) || self.chr == '_') {
            sb_push(&tok.lexeme, self.chr);
            next_char(self);
        }
        tok.kind = Tok_Wrd;
    } else if (is_operator(self.chr)) {
        while (is_operator(self.chr)) {
            sb_push(&tok.lexeme, self.chr);
            next_char(self);
            if (str_eq(tok.lexeme, "//")) {
                while (self.chr != '\n' && self.chr != -1) {
                    next_char(self);
                }
                return scan_tok(self, tok);
            }
        }
        tok.kind = Tok_Sym;
    } else {
        sb_push(&tok.lexeme, self.chr);
        next_char(self);
        tok.kind = Tok_Sym;
    }
    sb_push(&tok.lexeme, '\0');
}

//= Codegen

struct CodegenCtx {
    frame_size: Int,
    label_count: Int,
    temp_size: Int,
    current_func: *Sym,
    current_loop: Int,
}

func next_label(ctx: *CodegenCtx): Int {
    ctx.label_count += 1;
    return ctx.label_count;
}

func strx(type: *Type): *Char {
    if (type_size(type) == 1)
        return "strb w";
    if (type_size(type) == 2)
        return "strh w";
    if (type_size(type) == 4)
        return "str w";
    if (type_size(type) == 8)
        return "str x";
    assert(false, "strx: Unreachable.");
}

func ldrx(type: *Type): *Char {
    if (type.kind == Type_Bool)
        return "ldrb w";
    if (type.kind == Type_Int && type.size == 1)
        return "ldrsb x";
    if (type.kind == Type_Int && type.size == 2)
        return "ldrsh x";
    if (type.kind == Type_Int && type.size == 4)
        return "ldrsw x";
    if (type_size(type) == 8)
        return "ldr x";
    assert(false, "ldrx: Unreachable.");
}

func emit_push(ctx: *CodegenCtx, reg: Int) {
    if (ctx.temp_size + 8 >= FRAME_TEMP_SIZE) {
        fprintf(stderr, "Ran out of space for temporaries while compiling expression.\n");
        exit(1);
    }
    ctx.temp_size += 8;
    printf("  str x%d, [sp, #%d] // push\n", reg, FRAME_ARGS_SIZE + FRAME_TEMP_SIZE - ctx.temp_size);
}

func emit_pop(ctx: *CodegenCtx, reg: Int) {
    printf("  ldr x%d, [sp, #%d] // pop\n", reg, FRAME_ARGS_SIZE + FRAME_TEMP_SIZE - ctx.temp_size);
    ctx.temp_size -= 8;
}

func emit_sign_extend(ctx: *CodegenCtx, source: *Type, t0: Int, t1: Int) {
    assert(is_scalar(source), "emit_sign_extend: source should be a scalar.");
    if (source.kind == Type_Int && source.size < 8) {
        var suffix = "_bh_w"[source.size];
        printf("  sxt%c x%d, w%d\n", suffix, t0, t1);
    } else {
        if (t0 != t1) {
            printf("  mov x%d, x%d\n", t0, t1);
        }
    }
}

func emit_expr(ctx: *CodegenCtx, e: *Expr, t0: Int);

func emit_expr_lvalue(ctx: *CodegenCtx, e: *Expr, t0: Int);

func emit_operands(ctx: *CodegenCtx, e: *Expr, t0: Int, t1: Int) {
    emit_expr(ctx, e.children[0], t0);
    emit_push(ctx, t0);
    emit_expr(ctx, e.children[1], t1);
    emit_pop(ctx, t0);
}

func emit_operands_lvalue(ctx: *CodegenCtx, e: *Expr, t0: Int, t1: Int) {
    emit_expr_lvalue(ctx, e.children[0], t0);
    emit_push(ctx, t0);
    emit_expr(ctx, e.children[1], t1);
    emit_pop(ctx, t0);
}

func emit_expr_binary(ctx: *CodegenCtx, op: *Char, e: *Expr, t0: Int) {
    emit_operands(ctx, e, 0, 1);
    printf("  %s x%d, x%d, x%d\n", op, t0, 0, 1);
}

func emit_expr_cmp(ctx: *CodegenCtx, op: *Char, e: *Expr, t0: Int) {
    emit_operands(ctx, e, 0, 1);
    printf("  cmp x%d, x%d\n", 0, 1);
    printf("  cset x%d, %s\n", t0, op);
}

func emit_expr_lvalue(ctx: *CodegenCtx, e: *Expr, t0: Int) {
    if (str_eq(e.kind, "<var>") && e.sym.kind == Sym_Local) {
        var name = e.sym.name;
        printf("  add x%d, sp, #%d // &%s\n", t0, ctx.frame_size - e.sym.offset, name);
    } else if (str_eq(e.kind, "<var>") && e.sym.kind == Sym_Global) {
        var name = e.sym.name;
        if (e.sym.is_defined) {
            printf("  adrp x%d, %s\n", t0, name);
            printf("  add x%d, x%d, :lo12:%s // &%s\n", t0, t0, name, name);
        } else {
            printf("  adrp x%d, :got:%s\n", t0, name);
            printf("  ldr x%d, [x%d, :got_lo12:%s] // &%s\n", t0, t0, name, name);
        }
    } else if (str_eq(e.kind, "_._")) {
        var lhs_type = e.children[0].type;
        var field_name = lhs_type.field_names[e.field_index];
        var field_offset = lhs_type.field_offsets[e.field_index];
        emit_expr_lvalue(ctx, e.children[0], t0);
        printf("  add x%d, x%d, #%d // &%s\n", t0, t0, field_offset, field_name);
    } else if (str_eq(e.kind, "*_")) {
        emit_expr(ctx, e.children[0], t0);
    } else if (str_eq(e.kind, "_[_]")) {
        if (e.children[0].type.kind == Type_Ptr) {
            emit_operands(ctx, e, 0, 1);
        } else {
            emit_operands_lvalue(ctx, e, 0, 1);
        }
        var elem_size = type_size(e.children[0].type.base);
        printf("  add x%d, x0, x1, lsl #%d // &_[_]\n", t0, ilog2(elem_size));
    } else {
        assert(false, "emit_expr_lvalue: Unreachable.");
    }
}

func emit_expr(ctx: *CodegenCtx, e: *Expr, t0: Int) {
    if (is_lvalue(e)) {
        emit_expr_lvalue(ctx, e, t0);
        printf("  %s%d, [x%d]\n", ldrx(e.type), t0, t0);
    } else if (str_eq(e.kind, "<int>")) {
        printf("  mov x%d, #%d\n", t0, e.int_val);
    } else if (str_eq(e.kind, "<str>")) {
        var label = next_label(ctx);
        printf("  .text\n");
        printf("  .section .rodata\n");
        printf("  .align 3\n");
        printf(".str.%d:\n", label);
        printf("  .string \"");
        var i = 0;
        while (e.str_val[i] != '\0') {
            if (!is_print(e.str_val[i]) || e.str_val[i] == '\"' || e.str_val[i] == '\\') {
                printf("\\%03o", e.str_val[i]);
            } else {
                printf("%c", e.str_val[i]);
            }
            i += 1;
        }
        printf("\"\n");
        printf("  .text\n");
        printf("  adrp x%d, .str.%d\n", t0, label);
        printf("  add x%d, x%d, :lo12:.str.%d\n", t0, t0, label);
    } else if (str_eq(e.kind, "_(_)")) {
        var sym = e.sym;
        var i = 0;
        while (i < e.child_count) {
            emit_expr(ctx, e.children[i], 0);
            if (i >= MAX_PARAMS) {
                printf("  str x0, [sp, #%d]\n", 8 * (i - sym.param_count));
            } else {
                emit_push(ctx, 0);
            }
            i += 1;
        }
        i = int_min(e.child_count, MAX_PARAMS);
        while (i > 0) {
            i -= 1;
            emit_pop(ctx, i);
        }
        printf("  bl %s\n", e.sym.name);
        if (e.type.kind != Type_Void) {
            emit_sign_extend(ctx, e.type, t0, 0);
        }
    } else if (str_eq(e.kind, "&_")) {
        emit_expr_lvalue(ctx, e.children[0], t0);
    } else if (str_eq(e.kind, "!_")) {
        emit_expr(ctx, e.children[0], t0);
        printf("  eor x%d, x%d, #1\n", t0, t0);
    } else if (str_eq(e.kind, "~_")) {
        emit_expr(ctx, e.children[0], t0);
        printf("  mvn x%d, x%d\n", t0, t0);
    } else if (str_eq(e.kind, "-_")) {
        emit_expr(ctx, e.children[0], t0);
        printf("  neg x%d, x%d\n", t0, t0);
    } else if (str_eq(e.kind, "_&&_") || str_eq(e.kind, "_||_")) {
        var label = next_label(ctx);
        printf(".L%d.begin: // %s\n", label, e.kind);
        emit_expr(ctx, e.children[0], t0);
        if (str_eq(e.kind, "_&&_")) {
            printf("  cbz x%d, .L%d.end\n", t0, label);
        } else {
            printf("  cbnz x%d, .L%d.end\n", t0, label);
        }
        emit_expr(ctx, e.children[1], t0);
        printf(".L%d.end:\n", label);
    } else if (str_eq(e.kind, "_|_")) {
        emit_expr_binary(ctx, "orr", e, t0);
    } else if (str_eq(e.kind, "_^_")) {
        emit_expr_binary(ctx, "eor", e, t0);
    } else if (str_eq(e.kind, "_&_")) {
        emit_expr_binary(ctx, "and", e, t0);
    } else if (str_eq(e.kind, "_==_")) {
        emit_expr_cmp(ctx, "eq", e, t0);
    } else if (str_eq(e.kind, "_!=_")) {
        emit_expr_cmp(ctx, "ne", e, t0);
    } else if (str_eq(e.kind, "_<_")) {
        emit_expr_cmp(ctx, "lt", e, t0);
    } else if (str_eq(e.kind, "_<=_")) {
        emit_expr_cmp(ctx, "le", e, t0);
    } else if (str_eq(e.kind, "_>_")) {
        emit_expr_cmp(ctx, "gt", e, t0);
    } else if (str_eq(e.kind, "_>=_")) {
        emit_expr_cmp(ctx, "ge", e, t0);
    } else if (str_eq(e.kind, "_<<_")) {
        emit_expr_binary(ctx, "lsl", e, t0);
    } else if (str_eq(e.kind, "_>>_")) {
        emit_expr_binary(ctx, "lsr", e, t0);
    } else if (str_eq(e.kind, "_+_")) {
        emit_expr_binary(ctx, "add", e, t0);
    } else if (str_eq(e.kind, "_-_")) {
        emit_expr_binary(ctx, "sub", e, t0);
    } else if (str_eq(e.kind, "_*_")) {
        emit_expr_binary(ctx, "mul", e, t0);
    } else if (str_eq(e.kind, "_/_")) {
        emit_expr_binary(ctx, "sdiv", e, t0);
    } else if (str_eq(e.kind, "_%_")) {
        emit_operands(ctx, e, 1, 2);
        printf("  sdiv x%d, x%d, x%d\n", 0, 1, 2);
        printf("  msub x%d, x%d, x%d, x%d\n", t0, 0, 2, 1);
    } else if (str_eq(e.kind, "_?_:_")) {
        var label = next_label(ctx);
        printf(".L%d.if:\n", label);
        emit_expr(ctx, e.children[0], 0);
        printf("  cbz x0, .L%d.else\n", label);
        printf(".L%d.then:\n", label);
        emit_expr(ctx, e.children[1], t0);
        printf("  b .L%d.end\n", label);
        printf(".L%d.else:\n", label);
        if (e.children[2]) {
            emit_expr(ctx, e.children[2], t0);
        }
        printf(".L%d.end:\n", label);
    } else if (str_eq(e.kind, "_=_") || str_eq(e.kind, "_+=_") || str_eq(e.kind, "_-=_")) {
        var lhs = e.children[0];
        emit_operands_lvalue(ctx, e, 0, 1);
        if (str_eq(e.kind, "_+=_") || str_eq(e.kind, "_-=_")) {
            printf("  %s2, [x0]\n", ldrx(lhs.type));
            if (str_eq(e.kind, "_+=_")) {
                printf("  add x1, x2, x1\n");
            } else if (str_eq(e.kind, "_-=_")) {
                printf("  sub x1, x2, x1\n");
            } else {
                assert(false, "emit_expr: Unreachable.");
            }
        }
        printf("  %s1, [x0]\n", strx(lhs.type));
    } else if (str_eq(e.kind, "<memcpy>")) {
        emit_operands(ctx, e, 0, 1);
        printf("  mov x2, #%d\n", type_size(e.children[0].type.base));
        printf("  bl memcpy\n");
    } else if (str_eq(e.kind, "<cast>")) {
        var target = e.type;
        var source = e.children[0].type;
        assert(is_scalar(target) && is_scalar(source), "emit_expr: <cast> should have scalar types.");
        emit_expr(ctx, e.children[0], t0);
        if (target.kind == Type_Bool) {
            printf("  cmp x%d, #0\n", t0);
            printf("  cset w%d, ne\n", t0);
        } else if (type_size(target) < type_size(source)) {
            emit_sign_extend(ctx, target, t0, t0);
        } else {
            // no-op
        }
    } else if (str_eq(e.kind, "<block>")) {
        var i = 0;
        while (i < e.child_count) {
            emit_expr(ctx, e.children[i], 0);
            i += 1;
        }
    } else if (str_eq(e.kind, "<skip>")) {
        // noop
    } else if (str_eq(e.kind, "<while>")) {
        var label = next_label(ctx);
        var outer_loop = ctx.current_loop;
        ctx.current_loop = label;
        printf(".L%d.next:\n", label);
        emit_expr(ctx, e.children[0], 0);
        printf("  cbz x0, .L%d.done\n", label);
        printf(".L%d.do:\n", label);
        emit_expr(ctx, e.children[1], 0);
        printf("  b .L%d.next\n", label);
        printf(".L%d.done:\n", label);
        ctx.current_loop = outer_loop;
    } else if (str_eq(e.kind, "<break>")) {
        printf("  b .L%d.done\n", ctx.current_loop);
    } else if (str_eq(e.kind, "<continue>")) {
        printf("  b .L%d.next\n", ctx.current_loop);
    } else if (str_eq(e.kind, "<return>")) {
        if (e.children[0]) {
            emit_expr(ctx, e.children[0], 0);
        }
        printf("  b .L.%s.ret\n", ctx.current_func.name);
    } else {
        assert(false, "emit_expr: Unreachable.");
    }
}

func emit_func(ctx: *CodegenCtx, sym: *Sym) {
    ctx.current_func = sym;
    ctx.frame_size = align_up(sym.locals_size, 16) + FRAME_TEMP_SIZE + FRAME_ARGS_SIZE;
    printf("  .text\n");
    printf("  .align 2\n");
    printf("  .global %s\n", sym.name);
    printf("%s:\n", sym.name);
    printf("  stp x29, x30, [sp, #-16]!\n");
    printf("  mov x29, sp\n");
    printf("  sub sp, sp, #%d\n", ctx.frame_size);
    var i = 0;
    while (i < sym.param_count) {
        var param = sym.params[i];
        printf("  %s%d, [sp, #%d] // %s\n", strx(param.type), i, ctx.frame_size - param.offset, param.name);
        i += 1;
    }
    emit_expr(ctx, sym.body, 0);
    printf(".L.%s.ret:\n", sym.name);
    printf("  add sp, sp, #%d\n", ctx.frame_size);
    printf("  ldp x29, x30, [sp], #16\n");
    printf("  ret\n");
}

func emit_global(ctx: *CodegenCtx, sym: *Sym) {
    printf("  .global %s\n", sym.name);
    printf("  .bss\n");
    printf(".align %d\n", type_align(sym.type));
    printf("%s:\n", sym.name);
    printf("  .zero %d\n", type_size(sym.type));
}

func emit_program(env: *Env) {
    var ctx = calloc(1, sizeof(CodegenCtx)) as *CodegenCtx;
    var i = 0;
    while (i < env.sym_count) {
        var sym = env.syms[i];
        if (sym.kind == Sym_Global && sym.is_defined) {
            emit_global(ctx, sym);
        } else if (sym.kind == Sym_Func && sym.is_defined) {
            emit_func(ctx, sym);
        }
        i += 1;
    }
}

//= Parsing

struct Parser {
    lexer: *Lexer,
    tok: Int,
    tok_pos: Pos,
    lexeme: *Char,
    env: *Env,
}

func parser_init(self: *Parser, lexer: *Lexer, env: *Env) {
    memset(self, 0, sizeof(Parser));
    self.lexer = lexer;
    self.env = env;
}

func next_tok(self: *Parser) {
    var tok: Tok;
    scan_tok(self.lexer, &tok);
    self.tok = tok.kind;
    self.tok_pos = tok.pos;
    self.lexeme = tok.lexeme;
}

func make_parser(file_path: *Char, file: *File, env: *Env): *Parser {
    var lexer = malloc(sizeof(Lexer)) as *Lexer;
    lexer_init(lexer, file, file_path);

    var parser = malloc(sizeof(Parser)) as *Parser;
    parser_init(parser, lexer, env);

    next_char(lexer);
    next_tok(parser);

    return parser;
}

func at(str: *Char, self: *Parser): Bool {
    return (self.tok == Tok_Sym || self.tok == Tok_Wrd)
        && str_eq(self.lexeme, str);
}

func eat(str: *Char, self: *Parser): Bool {
    if (!at(str, self))
        return false;
    next_tok(self);
    return true;
}

func expect(str: *Char, self: *Parser) {
    if (!eat(str, self)) {
        error_at(&self.tok_pos);
        fprintf(stderr, "'%s' expected.\n", str);
        exit(1);
    }
}

func p_lexeme(self: *Parser): *Char {
    var prev_lexeme = self.lexeme;
    next_tok(self);
    return prev_lexeme;
}

func p_ident(self: *Parser): *Char {
    if (self.tok != Tok_Wrd) {
        error_at(&self.tok_pos);
        fprintf(stderr, "Identifier expected.\n");
        exit(1);
    }
    return p_lexeme(self);
}

func p_str(self: *Parser): *Char {
    if (self.tok != Tok_Str) {
        error_at(&self.tok_pos);
        fprintf(stderr, "String literal expected.\n");
        exit(1);
    }
    return p_lexeme(self);
}

func p_comma(end: *Char, self: *Parser) {
    if (!eat(",", self) && !at(end, self)) {
        error_at(&self.tok_pos);
        fprintf(stderr, "',' or '%s' expected.\n", end);
        exit(1);
    }
}

func p_const_expr(self: *Parser): Int;

func p_type(self: *Parser): *Type {
    if (eat("(", self)) {
        var type = p_type(self);
        expect(")", self);
        return type;
    } else if (eat("Void", self)) {
        return mk_void_type();
    } else if (eat("Bool", self)) {
        return mk_bool_type();
    } else if (eat("Char", self) || eat("Int8", self)) {
        return mk_int_type(1);
    } else if (eat("Int16", self)) {
        return mk_int_type(2);
    } else if (eat("Int32", self)) {
        return mk_int_type(4);
    } else if (eat("Int", self) || eat("Int64", self)) {
        return mk_int_type(8);
    } else if (eat("*", self)) {
        return mk_ptr_type(p_type(self));
    } else if (eat("[", self)) {
        var type = p_type(self);
        expect(";", self);
        var len = p_const_expr(self);
        expect("]", self);
        return mk_array_type(type, len);
    } else if (self.tok == Tok_Wrd) {
        var sym = find_sym(self.env, self.lexeme);
        if (!sym) {
            error_at(&self.tok_pos);
            fprintf(stderr, "Undeclared symbol '%s'.\n", self.lexeme);
            exit(1);
        }
        if (sym.kind != Sym_Type) {
            error_at(&self.tok_pos);
            fprintf(stderr, "'%s' is not a type.\n", self.lexeme);
            exit(1);
        }
        next_tok(self);
        return sym.type;
    } else {
        error_at(&self.tok_pos);
        fprintf(stderr, "Type expected.\n");
        exit(1);
    }
}

enum {
    Prec_Assign,
    Prec_Cond,
    Prec_CondOr,
    Prec_CondAnd,
    Prec_BitOr,
    Prec_BitXor,
    Prec_BitAnd,
    Prec_Cmp,
    Prec_Shift,
    Prec_Add,
    Prec_Mul,
    Prec_Cast,
    Prec_Unary,
    Prec_Postfix,
}

func build_unary_expr(op: *Char, rhs: *Expr): *Expr {
    if (str_eq(op, "*_")) {
        if (rhs.type.kind != Type_Ptr) {
            error_at(&rhs.pos);
            fprintf(stderr, "Pointer type expected.\n");
            exit(1);
        }
        return mk_expr_1("*_", rhs, rhs.type.base);
    } else if (str_eq(op, "&_")) {
        if (!is_lvalue(rhs)) {
            error_at(&rhs.pos);
            fprintf(stderr, "L-value expected.\n");
            exit(1);
        }
        return mk_expr_1("&_", rhs, mk_ptr_type(rhs.type));
    } else if (str_eq(op, "!_")) {
        check_type(rhs, mk_bool_type());
        return mk_expr_1("!_", rhs, mk_bool_type());
    } else {
        check_type_int(rhs);
        return mk_expr_1(op, rhs, rhs.type);
    }
}

func build_binary_expr(lhs: *Expr, op: *Char, rhs: *Expr): *Expr {
    if (str_eq(op, "_=_") || str_eq(op, "_+=_") || str_eq(op, "_-=_")) {
        if (!is_lvalue(lhs)) {
            error_at(&lhs.pos);
            fprintf(stderr, "L-value expected.\n");
            exit(1);
        }
        if (!str_eq(op, "_=_")) {
            check_type_int(lhs);
        }
        check_type(rhs, lhs.type);
        if (!is_scalar(lhs.type)) {
            assert(is_lvalue(lhs), "build_binary_expr: lhs must be an lvalue.");
            lhs = mk_expr_1("&_", lhs, mk_ptr_type(lhs.type));
            rhs = mk_expr_1("&_", rhs, mk_ptr_type(rhs.type));
            return mk_expr_2("<memcpy>", lhs, rhs, mk_void_type());
        } else {
            return mk_expr_2(op, lhs, rhs, mk_void_type());
        }
    } else if (str_eq(op, "_||_") || str_eq(op, "_&&_")) {
        check_type_bool(lhs);
        check_type_bool(rhs);
        return mk_expr_2(op, lhs, rhs, mk_bool_type());
    }  else if (str_eq(op, "_==_") || str_eq(op, "_!=_") || str_eq(op, "_<_") || str_eq(op, "_<=_") || str_eq(op, "_>_") || str_eq(op, "_>=_")) {
        unify_types(lhs, rhs);
        if (!is_scalar(lhs.type)) {
            error_at(&lhs.pos);
            fprintf(stderr, "Type ");
            print_type(stderr, lhs.type);
            fprintf(stderr, " is not comparable.\n");
            exit(1);
        }
        return mk_expr_2(op, lhs, rhs, mk_bool_type());
    } else {
        check_type_int(lhs);
        check_type_int(rhs);
        unify_types(lhs, rhs);
        return mk_expr_2(op, lhs, rhs, lhs.type);
    }
}

func p_expr(self: *Parser, max_prec: Int): *Expr;

func p_var_or_call_expr(self: *Parser): *Expr {
    var name_pos = self.tok_pos;
    var name = p_ident(self);
    var sym = find_sym(self.env, name);
    if (!sym) {
        error_at(&name_pos);
        fprintf(stderr, "Undeclared symbol '%s'.\n", name);
        exit(1);
    }
    if (eat("(", self)) {
        if (sym.kind != Sym_Func) {
            error_at(&name_pos);
            fprintf(stderr, "Function expected.\n");
            exit(1);
        }
        var expr = mk_expr("_(_)", sym.type, &name_pos);
        expr.sym = sym;
        while (!eat(")", self)) {
            var arg = p_expr(self, 0);
            p_comma(")", self);
            if (expr.child_count == MAX_PARAMS) {
                error_at(&arg.pos);
                fprintf(stderr, "Too many arguments.\n");
                exit(1);
            }
            expr_add_child(expr, arg);
        }
        if (expr.child_count < sym.param_count) {
            error_at(&expr.pos);
            fprintf(stderr, "Not enough arguments provided (%d < %d).\n", expr.child_count, sym.param_count);
            exit(1);
        }
        if (!sym.is_variadic && expr.child_count > sym.param_count) {
            error_at(&expr.pos);
            fprintf(stderr, "Too many arguments provided (%d > %d).\n", expr.child_count, sym.param_count);
            exit(1);
        }
        var i = 0;
        while (i < sym.param_count) {
            check_type(expr.children[i], sym.params[i].type);
            i += 1;
        }
        while (i < expr.child_count) {
            if (!is_scalar(expr.children[i].type)) {
                error_at(&self.tok_pos);
                fprintf(stderr, "Variadic argument must be scalar.\n");
                exit(1);
            }
            i += 1;
        }
        return expr;
    } else {
        if (sym.kind == Sym_Local || sym.kind == Sym_Global) {
            var expr = mk_expr("<var>", sym.type, &self.tok_pos);
            expr.sym = sym;
            return expr;
        } else if (sym.kind == Sym_Const) {
            var expr = mk_expr("<int>", sym.type, &self.tok_pos);
            expr.int_val = sym.value;
            return expr;
        } else {
            error_at(&self.tok_pos);
            fprintf(stderr, "'%s' is not a variable or constant.\n", name);
            exit(1);
        }
    }
}

func p_ternary_expr(self: *Parser, cond: *Expr): *Expr {
    var ift = p_expr(self, Prec_Cond);
    expect(":", self);
    var iff = p_expr(self, Prec_Cond);
    check_type_bool(cond);
    unify_types(ift, iff);
    return mk_expr_3("_?_:_", cond, ift, iff, ift.type);
}

func p_cast_expr(self: *Parser, lhs: *Expr): *Expr {
    var type = p_type(self);
    if (!(is_scalar(type) && is_scalar(lhs.type))) {
        error_at(&self.tok_pos);
        fprintf(stderr, "Invalid cast type.\n");
        exit(1);
    }
    return mk_cast_expr(lhs, type);
}

func p_index_expr(self: *Parser, lhs: *Expr): *Expr {
    var rhs = p_expr(self, 0);
    expect("]", self);
    if (lhs.type.kind != Type_Arr && lhs.type.kind != Type_Ptr) {
        error_at(&lhs.pos);
        fprintf(stderr, "Expression is not indexable.\n");
        exit(1);
    }
    check_type_int(rhs);
    return mk_expr_2("_[_]", lhs, rhs, lhs.type.base);
}

func p_field_expr(self: *Parser, lhs: *Expr): *Expr {
    var field_name = p_ident(self);
    if (lhs.type.kind == Type_Ptr && lhs.type.base.kind == Type_Struct) {
        lhs = mk_expr_1("*_", lhs, lhs.type.base);
    }
    if (lhs.type.kind != Type_Struct) {
        error_at(&lhs.pos);
        fprintf(stderr, "Struct type expected.\n");
        exit(1);
    }
    var field_index = find_field(lhs.type, field_name);
    if (field_index == -1) {
        error_at(&self.tok_pos);
        fprintf(stderr, "Unknown field '%s'.\n", field_name);
        exit(1);
    }
    var field_type = lhs.type.field_types[field_index];
    lhs = mk_expr_1("_._", lhs, field_type);
    lhs.field_index = field_index;
    return lhs;
}

func p_expr(self: *Parser, max_prec: Int): *Expr {
    var lhs: *Expr;
    if (eat("(", self)) {
        lhs = p_expr(self, 0);
        expect(")", self);
    } else if (eat("null", self)) {
        lhs = mk_expr("<int>", mk_ptr_type(mk_void_type()), &self.tok_pos);
    } else if (at("true", self) || at("false", self)) {
        lhs = mk_expr("<int>", mk_bool_type(), &self.tok_pos);
        lhs.int_val = (eat("true", self) || !eat("false", self)) as Int;
    } else if (self.tok == Tok_Int) {
        lhs = mk_expr("<int>", mk_int_type(8), &self.tok_pos);
        lhs.int_val = atoi(p_lexeme(self));
    } else if (self.tok == Tok_Chr) {
        lhs = mk_expr("<int>", mk_int_type(1), &self.tok_pos);
        lhs.int_val = p_lexeme(self)[0];
    } else if (self.tok == Tok_Str) {
        lhs = mk_expr("<str>", mk_ptr_type(mk_int_type(1)), &self.tok_pos);
        lhs.str_val = p_lexeme(self);
    } else if (eat("sizeof", self)) {
        expect("(", self);
        var type = p_type(self);
        expect(")", self);
        lhs = mk_expr("<int>", mk_int_type(8), &self.tok_pos);
        lhs.int_val = type_size(type);
    } else if (self.tok == Tok_Wrd) {
        lhs = p_var_or_call_expr(self);
    } else if (max_prec <= Prec_Unary && eat("*", self)) {
        lhs = build_unary_expr("*_", p_expr(self, Prec_Unary));
    } else if (max_prec <= Prec_Unary && eat("&", self)) {
        lhs = build_unary_expr("&_", p_expr(self, Prec_Unary));
    } else if (max_prec <= Prec_Unary && (eat("!", self))) {
        lhs = build_unary_expr("!_", p_expr(self, Prec_Unary));
    } else if (max_prec <= Prec_Unary && eat("~", self)) {
        lhs = build_unary_expr("~_", p_expr(self, Prec_Unary));
    } else if (max_prec <= Prec_Unary && eat("-", self)) {
        lhs = build_unary_expr("-_", p_expr(self, Prec_Unary));
    } else {
        error_at(&self.tok_pos);
        fprintf(stderr, "Expression expected.\n");
        exit(1);
    }

    while (true) {
        if (max_prec <= Prec_Assign && eat("=", self)) {
            lhs = build_binary_expr(lhs, "_=_", p_expr(self, Prec_Assign + 1));
        } else if (max_prec <= Prec_Assign && eat("+=", self)) {
            lhs = build_binary_expr(lhs, "_+=_", p_expr(self, Prec_Assign + 1));
        } else if (max_prec <= Prec_Assign && eat("-=", self)) {
            lhs = build_binary_expr(lhs, "_-=_", p_expr(self, Prec_Assign + 1));
        } else if (max_prec <= Prec_Cond && eat("?", self)) {
            lhs = p_ternary_expr(self, lhs);
        } else if (max_prec <= Prec_CondOr && eat("||", self)) {
            lhs = build_binary_expr(lhs, "_||_", p_expr(self, Prec_CondOr + 1));
        } else if (max_prec <= Prec_CondAnd && eat("&&", self)) {
            lhs = build_binary_expr(lhs, "_&&_", p_expr(self, Prec_CondAnd + 1));
        } else if (max_prec <= Prec_BitOr && eat("|", self)) {
            lhs = build_binary_expr(lhs, "_|_", p_expr(self, Prec_BitOr + 1));
        } else if (max_prec <= Prec_BitXor && eat("^", self)) {
            lhs = build_binary_expr(lhs, "_^_", p_expr(self, Prec_BitXor + 1));
        } else if (max_prec <= Prec_BitAnd && eat("&", self)) {
            lhs = build_binary_expr(lhs, "_&_", p_expr(self, Prec_BitAnd + 1));
        } else if (max_prec <= Prec_Cmp && eat("==", self)) {
            lhs = build_binary_expr(lhs, "_==_", p_expr(self, Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("!=", self)) {
            lhs = build_binary_expr(lhs, "_!=_", p_expr(self, Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("<", self)) {
            lhs = build_binary_expr(lhs, "_<_", p_expr(self, Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("<=", self)) {
            lhs = build_binary_expr(lhs, "_<=_", p_expr(self, Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat(">", self)) {
            lhs = build_binary_expr(lhs, "_>_", p_expr(self, Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat(">=", self)) {
            lhs = build_binary_expr(lhs, "_>=_", p_expr(self, Prec_Cmp + 1));
        } else if (max_prec <= Prec_Shift && eat("<<", self)) {
            lhs = build_binary_expr(lhs, "_<<_", p_expr(self, Prec_Shift + 1));
        } else if (max_prec <= Prec_Shift && eat(">>", self)) {
            lhs = build_binary_expr(lhs, "_>>_", p_expr(self, Prec_Shift + 1));
        } else if (max_prec <= Prec_Add && eat("+", self)) {
            lhs = build_binary_expr(lhs, "_+_", p_expr(self, Prec_Add + 1));
        } else if (max_prec <= Prec_Add && eat("-", self)) {
            lhs = build_binary_expr(lhs, "_-_", p_expr(self, Prec_Add + 1));
        } else if (max_prec <= Prec_Mul && eat("*", self)) {
            lhs = build_binary_expr(lhs, "_*_", p_expr(self, Prec_Mul + 1));
        } else if (max_prec <= Prec_Mul && eat("/", self)) {
            lhs = build_binary_expr(lhs, "_/_", p_expr(self, Prec_Mul + 1));
        } else if (max_prec <= Prec_Mul && eat("%", self)) {
            lhs = build_binary_expr(lhs, "_%_", p_expr(self, Prec_Mul + 1));
        } else if (max_prec <= Prec_Cast && eat("as", self)) {
            lhs = p_cast_expr(self, lhs);
        } else if (max_prec <= Prec_Postfix && eat("[", self)) {
            lhs = p_index_expr(self, lhs);
        } else if (max_prec <= Prec_Postfix && eat(".", self)) {
            lhs = p_field_expr(self, lhs);
        } else {
            return lhs;
        }
    }
}

func p_const_expr(self: *Parser): Int {
    var expr = p_expr(self, 0);
    check_type_int(expr);
    return const_eval(expr);
}

func p_stmt(self: *Parser): *Expr;

func p_block_stmt(self: *Parser): *Expr {
    var start_pos = self.tok_pos;
    expect("{", self);
    var block = mk_expr("<block>", mk_void_type(), &start_pos);
    enter_scope(&self.env);
    while (!eat("}", self)) {
        var stmt = p_stmt(self);
        expr_add_child(block, stmt);
    }
    leave_scope(&self.env);
    return block;
}

func p_var_stmt(self: *Parser): *Expr {
    var start_pos = self.tok_pos;
    expect("var", self);

    var name_pos = self.tok_pos;
    var name = p_ident(self);
    var type: *Type = null;
    if (eat(":", self)) {
        type = p_type(self);
    }
    var init: *Expr = null;
    if (eat("=", self)) {
        init = p_expr(self, 0);
    }
    expect(";", self);

    if (type != null) {
        if (init != null) {
            check_type(init, type);
        }
    } else {
        if (init != null) {
            type = init.type;
        } else {
            error_at(&name_pos);
            fprintf(stderr, "Type or initializer expected.\n");
            exit(1);
        }
    }
    if (type_size(type) == -1) {
        error_at(&name_pos);
        fprintf(stderr, "Variable must have a size.\n");
        exit(1);
    }

    var sym = add_local(self.env, name, type, &name_pos);

    if (init != null) {
        var dest = mk_expr("<var>", type, &name_pos);
        dest.sym = sym;
        return build_binary_expr(dest, "_=_", init);
    } else {
        return mk_expr("<skip>", mk_void_type(), &start_pos);
    }
}

func p_if_stmt(self: *Parser): *Expr {
    expect("if", self);
    expect("(", self);
    var cond = p_expr(self, 0);
    check_type_bool(cond);
    expect(")", self);
    var ift = p_stmt(self);
    var iff: *Expr = null;
    if (eat("else", self)) {
        iff = p_stmt(self);
    }
    return mk_expr_3("_?_:_", cond, ift, iff, mk_void_type());
}

func p_while_stmt(self: *Parser): *Expr {
    expect("while", self);
    var outer_loop = self.env.current_loop;
    self.env.current_loop = 1;
    expect("(", self);
    var cond = p_expr(self, 0);
    check_type_bool(cond);
    expect(")", self);
    var body = p_stmt(self);
    self.env.current_loop = outer_loop;
    return mk_expr_2("<while>", cond, body, mk_void_type());
}

func p_break_stmt(self: *Parser): *Expr {
    var start_pos = self.tok_pos;
    expect("break", self);
    expect(";", self);
    if (self.env.current_loop == 0) {
        error_at(&self.tok_pos);
        fprintf(stderr, "Break statement outside of loop.\n");
        exit(1);
    }
    return mk_expr("<break>", mk_void_type(), &start_pos);
}

func p_continue_stmt(self: *Parser): *Expr {
    var start_pos = self.tok_pos;
    expect("continue", self);
    expect(";", self);
    if (self.env.current_loop == 0) {
        error_at(&self.tok_pos);
        fprintf(stderr, "Continue statement outside of loop.\n");
        exit(1);
    }
    return mk_expr("<continue>", mk_void_type(), &start_pos);
}

func p_return_stmt(self: *Parser): *Expr {
    var start_pos = self.tok_pos;
    expect("return", self);
    var expr: *Expr = null;
    if (!at(";", self)) {
        expr = p_expr(self, 0);
    }
    expect(";", self);

    var return_type = self.env.current_func.type;
    if (expr) {
        check_type(expr, return_type);
    } else if (return_type.kind != Type_Void) {
        error_at(&self.tok_pos);
        fprintf(stderr, "Return value expected.\n");
        exit(1);
    }

    var return_stmt = mk_expr("<return>", mk_void_type(), &start_pos);
    expr_add_child(return_stmt, expr);
    return return_stmt;
}

func p_stmt(self: *Parser): *Expr {
    if (at("{", self)) {
        return p_block_stmt(self);
    } else if (at("var", self)) {
        return p_var_stmt(self);
    } else if (at("if", self)) {
        return p_if_stmt(self);
    } else if (at("while", self)) {
        return p_while_stmt(self);
    } else if (at("break", self)) {
        return p_break_stmt(self);
    } else if (at("continue", self)) {
        return p_continue_stmt(self);
    } else if (at("return", self)) {
        return p_return_stmt(self);
    } else {
        var expr = p_expr(self, 0);
        expect(";", self);
        return expr;
    }
}

func p_file(self: *Parser);

func p_func_decl(self: *Parser) {
    expect("func", self);
    var name_pos = self.tok_pos;
    var name = p_ident(self);
    var sym = mk_sym(Sym_Func, name);
    sym.type = mk_void_type();
    self.env.current_func = sym;

    enter_scope(&self.env);
    add_sym(self.env, sym, &name_pos);
    expect("(", self);
    while (!at(")", self) && !at("...", self)) {
        var param_pos = self.tok_pos;
        var param_name = p_ident(self);
        expect(":", self);
        var param_type = p_type(self);
        p_comma(")", self);

        if (sym.param_count == MAX_PARAMS) {
            error_at(&self.tok_pos);
            fprintf(stderr, "Too many parameters.\n");
            exit(1);
        }
        if (!is_scalar(param_type)) {
            error_at(&param_pos);
            fprintf(stderr, "Parameter must be of scalar type.\n");
            exit(1);
        }
        sym.params[sym.param_count] = add_local(self.env, param_name, param_type, &param_pos);
        sym.param_count += 1;
    }
    if (eat("...", self)) {
        sym.is_variadic = true;
    }
    expect(")", self);
    if (eat(":", self)) {
        sym.type = p_type(self);
    }

    if (at("{", self)) {
        sym.body = p_stmt(self);
        sym.is_defined = true;
    } else {
        expect(";", self);
    }
    leave_scope(&self.env);
    add_sym(self.env, sym, &name_pos);
}

func p_var_decl(self: *Parser, is_extern: Bool) {
    expect("var", self);
    var name = p_ident(self);
    expect(":", self);
    var type = p_type(self);
    expect(";", self);
    add_global(self.env, !is_extern, name, type, &self.tok_pos);
}

func p_const_decl(self: *Parser) {
    expect("const", self);
    var name = p_ident(self);
    expect("=", self);
    var value = p_const_expr(self);
    expect(";", self);
    add_const(self.env, name, value, &self.tok_pos);
}

func p_struct_decl(self: *Parser) {
    expect("struct", self);
    var name_pos = self.tok_pos;
    var name = p_ident(self);

    declare_struct(self.env, name, &name_pos);

    if (eat("{", self)) {
        var fields = mk_struct_type(name);
        while (!eat("}", self)) {
            var field_pos = self.tok_pos;
            var field_name = p_ident(self);
            expect(":", self);
            var field_type = p_type(self);
            p_comma("}", self);
            add_field(fields, field_name, field_type, &field_pos);
        }
        if (fields.field_count == 0) {
            error_at(&name_pos);
            fprintf(stderr, "Struct must have at least one field.\n");
            exit(1);
        }
        define_struct(self.env, name, fields, &name_pos);
    } else {
        expect(";", self);
    }
}

func p_enum_decl(self: *Parser) {
    expect("enum", self);
    var value = 0;
    expect("{", self);
    while (!eat("}", self)) {
        var name = p_ident(self);
        if (eat("=", self)) {
            value = p_const_expr(self);
        }
        p_comma("}", self);
        add_const(self.env, name, value, &self.tok_pos);
        value += 1;
    }
}

func p_include(self: *Parser) {
    var start_pos = self.tok_pos;
    expect("include", self);
    var file_name = p_str(self);
    expect(";", self);

    var input_file_path = self.tok_pos.file;
    if (!input_file_path) {
        input_file_path = ".";
    }

    var file_dir = get_directory(input_file_path);
    var file_path = malloc(strlen(file_dir) + strlen(file_name) + 2);
    sprintf(file_path, "%s/%s", file_dir, file_name);
    var file = fopen(file_path, "r");
    if (!file) {
        error_at(&start_pos);
        fprintf(stderr, "Unable to open file '%s'.\n", file_path);
        exit(1);
    }

    var other = make_parser(file_path, file, self.env);
    p_file(other);
}

func p_decl(self: *Parser) {
    var is_extern = false;
    if (eat("extern", self)) {
        // FIXME: extern is now a storage class specifier, doesn't make sense for structs.
        if (!at("func", self) && !at("var", self) && !at("struct", self)) {
            error_at(&self.tok_pos);
            fprintf(stderr, "External declaration expected.\n");
            exit(1);
        }
        is_extern = true;
    }

    if (at("func", self)) {
        p_func_decl(self);
    } else if (at("var", self)) {
        p_var_decl(self, is_extern);
    } else if (at("const", self)) {
        p_const_decl(self);
    } else if (at("struct", self)) {
        p_struct_decl(self);
    } else if (at("enum", self)) {
        p_enum_decl(self);
    } else if (at("include", self)) {
        p_include(self);
    } else {
        error_at(&self.tok_pos);
        fprintf(stderr, "Declaration expected.\n");
        exit(1);
    }
}

func p_file(self: *Parser) {
    while (self.tok != Tok_Eof) {
        p_decl(self);
    }
}

func main(argc: Int32, argv: *(*Char)): Int32 {
    if (argc > 2) {
        fprintf(stderr, "Usage: %s [file]\n", argv[0]);
        return 1;
    }

    var input_path: *Char = null;
    var input_file: *File = stdin;
    if (argc == 2) {
        input_path = argv[1];
        input_file = fopen(input_path, "r");
        if (!input_file) {
            fprintf(stderr, "Error opening file '%s'.\n", input_path);
            return 1;
        }
    }

    var root_env = calloc(1, sizeof(Env)) as *Env;

    var parser = make_parser(input_path, input_file, root_env);

    p_file(parser);
    emit_program(root_env);
    return 0;
}
