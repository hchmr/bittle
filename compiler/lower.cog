include "cog.cogs";

func translate_binary_op(tok_kind: Int32): Int32 {
    return
        tok_kind == Tok_Amp ? HirOp_And :
        tok_kind == Tok_Bar ? HirOp_Or :
        tok_kind == Tok_Caret ? HirOp_Xor :
        tok_kind == Tok_LtLt ? HirOp_Shl :
        tok_kind == Tok_GtGt ? HirOp_Shr :
        tok_kind == Tok_EqEq ? HirOp_Eq :
        tok_kind == Tok_BangEq ? HirOp_Ne :
        tok_kind == Tok_Lt ? HirOp_Lt :
        tok_kind == Tok_LtEq ? HirOp_Le :
        tok_kind == Tok_Gt ? HirOp_Gt :
        tok_kind == Tok_GtEq ? HirOp_Ge :
        tok_kind == Tok_Plus ? HirOp_Add :
        tok_kind == Tok_Minus ? HirOp_Sub :
        tok_kind == Tok_Star ? HirOp_Mul :
        tok_kind == Tok_Slash ? HirOp_Div :
        tok_kind == Tok_Percent ? HirOp_Rem :
        unreachable("translate_binary_op");
}

func translate_assign_op(tok_kind: Int32): Int32 {
    return
        tok_kind == Tok_AmpEq ? HirOp_And :
        tok_kind == Tok_BarEq ? HirOp_Or :
        tok_kind == Tok_CaretEq ? HirOp_Xor :
        tok_kind == Tok_LtLtEq ? HirOp_Shl :
        tok_kind == Tok_GtGtEq ? HirOp_Shr :
        tok_kind == Tok_PlusEq ? HirOp_Add :
        tok_kind == Tok_MinusEq ? HirOp_Sub :
        tok_kind == Tok_StarEq ? HirOp_Mul :
        tok_kind == Tok_SlashEq ? HirOp_Div :
        tok_kind == Tok_PercentEq ? HirOp_Rem :
        unreachable("translate_assign_op");
}

func mk_skip_stmt(pos: *Pos): *HirExpr {
    var result: *HirExpr = calloc(1, sizeof(HirExpr));
    *result = HirExpr(HirExpr_Skip, mk_void_type(), *pos);
    return result;
}

func mk_seq_hir_expr(first: *HirExpr, second: *HirExpr): *SeqHirExpr {
    var result: *SeqHirExpr = calloc(1, sizeof(SeqHirExpr));
    *result = SeqHirExpr(HirExpr_Seq, first.type, first.pos, first, second);
    return result;
}

func mk_let_hir_expr(temp: *HirTemp, init: *HirExpr, body: *HirExpr, pos: *Pos): *LetHirExpr {
    var result: *LetHirExpr = calloc(1, sizeof(LetHirExpr));
    *result = LetHirExpr(HirExpr_Let, body.type, *pos, temp, init, body);
    return result;
}

func mk_int_hir_expr(value: Int, type: *Type, pos: *Pos): *IntHirExpr {
    var result: *IntHirExpr = calloc(1, sizeof(IntHirExpr));
    *result = IntHirExpr(HirExpr_Int, type, *pos, value);
    return result;
}

func mk_str_hir_expr(value: *Char, pos: *Pos): *StrHirExpr {
    var result: *StrHirExpr = calloc(1, sizeof(StrHirExpr));
    *result = StrHirExpr(HirExpr_Str, mk_ptr_type(mk_int_type(1)), *pos, value);
    return result;
}

func mk_var_hir_expr(sym: *Sym, type: *Type, pos: *Pos): *VarHirExpr {
    var result: *VarHirExpr = calloc(1, sizeof(VarHirExpr));
    *result = VarHirExpr(HirExpr_Var, type, *pos, sym);
    return result;
}

func mk_temp_hir_expr(temp: *HirTemp, pos: *Pos): *TempHirExpr {
    var result: *TempHirExpr = calloc(1, sizeof(TempHirExpr));
    *result = TempHirExpr(HirExpr_Temp, temp.type, *pos, temp);
    return result;
}

func mk_cond_hir_expr(cond: *HirExpr, then_expr: *HirExpr, else_expr: *HirExpr, pos: *Pos): *CondHirExpr {
    var result: *CondHirExpr = calloc(1, sizeof(CondHirExpr));
    *result = CondHirExpr(HirExpr_Cond, then_expr.type, *pos, cond, then_expr, else_expr);
    return result;
}

func mk_loop_hir_expr(cond: *HirExpr, body: *HirExpr, step: *HirExpr, pos: *Pos): *LoopHirExpr {
    var result: *LoopHirExpr = calloc(1, sizeof(LoopHirExpr));
    *result = LoopHirExpr(HirExpr_Loop, body.type, *pos, cond, body, step);
    return result;
}

func mk_return_hir_expr(expr: *HirExpr, pos: *Pos): *ReturnHirExpr {
    var result: *ReturnHirExpr = calloc(1, sizeof(ReturnHirExpr));
    *result = ReturnHirExpr(HirExpr_Return, mk_void_type(), *pos, expr);
    return result;
}

func mk_jump_hir_expr(is_break: Bool, pos: *Pos): *JumpHirExpr {
    var result: *JumpHirExpr = calloc(1, sizeof(JumpHirExpr));
    *result = JumpHirExpr(HirExpr_Jump, mk_void_type(), *pos, is_break);
    return result;
}

func mk_assign_hir_expr(dst: *HirExpr, src: *HirExpr): *AssignHirExpr {
    var result: *AssignHirExpr = calloc(1, sizeof(AssignHirExpr));
    *result = AssignHirExpr(HirExpr_Assign, mk_void_type(), dst.pos, dst, src);
    return result;
}

func mk_binary_op_hir_expr(op: Int32, left: *HirExpr, right: *HirExpr, type: *Type): *BinaryOpHirExpr {
    var result: *BinaryOpHirExpr = calloc(1, sizeof(BinaryOpHirExpr));
    *result = BinaryOpHirExpr(HirExpr_BinaryOp, type, left.pos, op, left, right);
    return result;
}

func mk_neg_hir_expr(expr: *HirExpr): *HirExpr {
    var zero = mk_int_hir_expr(0, expr.type, &expr.pos);
    return mk_binary_op_hir_expr(HirOp_Sub, zero, expr, expr.type);
}

func mk_not_hir_expr(expr: *HirExpr): *HirExpr {
    var one = mk_int_hir_expr(1, expr.type, &expr.pos);
    return mk_binary_op_hir_expr(HirOp_Xor, expr, one, expr.type);
}

func mk_bit_not_hir_expr(expr: *HirExpr): *HirExpr {
    var minus_one = mk_int_hir_expr(-1, expr.type, &expr.pos);
    return mk_binary_op_hir_expr(HirOp_Xor, expr, minus_one, expr.type);
}

func mk_call_hir_expr(callee: *FuncSym, args: *List, pos: *Pos): *CallHirExpr {
    var result: *CallHirExpr = calloc(1, sizeof(CallHirExpr));
    *result = CallHirExpr(HirExpr_Call, callee.return_type, *pos, callee, args);
    return result;
}

func mk_member_hir_expr(left: *HirExpr, name: *Char, field_index: Int, field_type: *Type): *MemberHirExpr {
    var result: *MemberHirExpr = calloc(1, sizeof(MemberHirExpr));
    *result = MemberHirExpr(HirExpr_Member, field_type, left.pos, left, name, field_index);
    return result;
}

func mk_index_hir_expr(indexee: *HirExpr, index: *HirExpr): *IndexHirExpr {
    assert(
        indexee.type.kind == Type_Ptr || indexee.type.kind == Type_Arr,
        "mk_index_hir_expr: indexee should have a pointer or array type"
    );
    var result_type = indexee.type.kind == Type_Ptr
        ? (indexee.type as *PtrType).pointee
        : (indexee.type as *ArrType).elem;

    var result: *IndexHirExpr = calloc(1, sizeof(IndexHirExpr));
    *result = IndexHirExpr(HirExpr_Index, result_type, indexee.pos, indexee, index);
    return result;
}

func mk_deref_hir_expr(expr: *HirExpr, pos: *Pos): *DerefHirExpr {
    assert(expr.type.kind == Type_Ptr, "mk_deref_hir_expr: expr should have a pointer type");
    var deref_type = (expr.type as *PtrType).pointee;

    var result: *DerefHirExpr = calloc(1, sizeof(DerefHirExpr));
    *result = DerefHirExpr(HirExpr_Deref, deref_type, *pos, expr);
    return result;
}

func mk_addr_hir_expr(expr: *HirExpr, pos: *Pos): *AddrHirExpr {
    var result: *AddrHirExpr = calloc(1, sizeof(AddrHirExpr));
    *result = AddrHirExpr(HirExpr_Addr, mk_ptr_type(expr.type), *pos, expr);
    return result;
}

func mk_cast_hir_expr(expr: *HirExpr, type: *Type): *CastHirExpr {
    var result: *CastHirExpr = calloc(1, sizeof(CastHirExpr));
    *result = CastHirExpr(HirExpr_Cast, type, expr.pos, expr);
    return result;
}

//==============================================================================
//== Context

struct Context {
    func_: *Sym,
    temps: *List, // List<*HirTemp>
}

func mk_temp_var(ctx: *Context, type: *Type): *HirTemp {
    var temp: *HirTemp = calloc(1, sizeof(HirTemp));
    *temp = HirTemp(
        id: list_len(ctx.temps),
        type,
        offset: -1
    );
    list_push(ctx.temps, temp);
    return temp;
}

//==============================================================================
//== Expressions

func lower_expr(ctx: *Context, expr: *Expr): *HirExpr;

func lower_assign_expr(ctx: *Context, dest: *HirExpr, src: *Expr, pos: *Pos): *HirExpr;

func lower_ident_expr(ctx: *Context, expr: *IdentExpr): *HirExpr {
    var sym = expr.sym;
    if (sym.kind == Sym_Global || sym.kind == Sym_Local) {
        return mk_var_hir_expr(sym, expr.type, &expr.pos);
    } else if (sym.kind == Sym_Const) {
        var value = (sym as *ConstSym).value;
        return mk_int_hir_expr(value, expr.type, &expr.pos);
    } else {
        unreachable("elab_ident_expr");
    }
}

func lower_literal_expr(ctx: *Context, expr: *LiteralExpr): *HirExpr {
    var literal = expr.literal;

    var result: *HirExpr;
    if (literal.kind == Literal_Null) {
        result = mk_int_hir_expr(0, expr.type, &expr.pos);
    } else if (literal.kind == Literal_Bool) {
        result = mk_int_hir_expr((literal as *BoolLiteral).value as Int, expr.type, &expr.pos);
    } else if (literal.kind == Literal_Int) {
        result = mk_int_hir_expr((literal as *IntLiteral).value, expr.type, &expr.pos);
    } else if (literal.kind == Literal_Char) {
        result = mk_int_hir_expr((literal as *CharLiteral).value, expr.type, &expr.pos);
    } else if (literal.kind == Literal_String) {
        result = mk_str_hir_expr((literal as *StringLiteral).value, &expr.pos);
    } else {
        unreachable("elab_literal_expr");
    }
    return result;
}

func lower_array_expr(ctx: *Context, expr: *ArrayExpr): *HirExpr {
    die_at(&expr.pos, "Array literal outside of an assignment statement");
}

func lower_call_expr(ctx: *Context, expr: *CallExpr): *HirExpr {
    assert(expr.resolved_callee.kind == Sym_Func, "lower_call_expr: callee should be a function");
    var resolved_callee = expr.resolved_callee as *FuncSym;
    var ast_args = expr.args;

    var hir_args = list_new();
    for (var i = 0; i < list_len(ast_args); i += 1) {
        var ast_arg: *CallArg = list_get(ast_args, i);
        var hir_arg = lower_expr(ctx, ast_arg.expr);
        list_push(hir_args, hir_arg);
    }
    return mk_call_hir_expr(resolved_callee, hir_args, &expr.pos);
}

func lower_index_expr(ctx: *Context, expr: *IndexExpr): *HirExpr {
    var ast_indexee = expr.indexee;
    var ast_index = expr.index;

    var hir_indexee = lower_expr(ctx, ast_indexee);
    var hir_index = lower_expr(ctx, ast_index);

    return mk_index_hir_expr(hir_indexee, hir_index);
}

func lower_member_expr(ctx: *Context, expr: *MemberExpr): *HirExpr {
    var ast_left = expr.left;
    var name = expr.name;
    var field_index = expr.resolved_field;

    var hir_left = lower_expr(ctx, ast_left);
    if (hir_left.type.kind == Type_Ptr) {
        hir_left = mk_deref_hir_expr(hir_left, &expr.pos);
    }

    return mk_member_hir_expr(hir_left, name, field_index, expr.type);
}

func lower_sizeof_expr(ctx: *Context, expr: *SizeofExpr): *HirExpr {
    var size = expr.size;
    return mk_int_hir_expr(size, expr.type, &expr.pos);
}

func lower_unary_expr(ctx: *Context, expr: *UnaryExpr): *HirExpr {
    var op = expr.op;
    var ast_right = expr.right;

    var right = lower_expr(ctx, ast_right);

    var result: *HirExpr;
    if (op == Tok_Minus) {
        result = mk_neg_hir_expr(right);
    } else if (op == Tok_Tilde) {
        result = mk_bit_not_hir_expr(right);
    } else if (op == Tok_Bang) {
        result = mk_not_hir_expr(right);
    } else if (op == Tok_Star) {
        result = mk_deref_hir_expr(right, &expr.pos);
    } else if (op == Tok_Amp) {
        result = mk_addr_hir_expr(right, &expr.pos);
    } else {
        unreachable("elab_unary_expr");
    }

    return result;
}

func lower_binary_expr(ctx: *Context, expr: *BinaryExpr): *HirExpr {
    var ast_op = expr.op;
    var ast_left = expr.left;
    var ast_right = expr.right;

    var left = lower_expr(ctx, ast_left);

    var result: *HirExpr;
    if (ast_op == Tok_Eq) {
        result = lower_assign_expr(ctx, left, ast_right, &expr.pos);
    } else if (ast_op == Tok_AmpEq || ast_op == Tok_BarEq || ast_op == Tok_CaretEq || ast_op == Tok_LtLtEq || ast_op == Tok_GtGtEq || ast_op == Tok_PlusEq || ast_op == Tok_MinusEq || ast_op == Tok_StarEq || ast_op == Tok_SlashEq || ast_op == Tok_PercentEq) {
        /*
            Desugar
                left op= right
            to
                let temp: *typeof(left) = &left in
                *temp = *temp op right
        */
        var right = lower_expr(ctx, ast_right);
        var typeof_addr_left = mk_ptr_type(left.type);
        var op = translate_assign_op(ast_op);
        var temp_var = mk_temp_var(ctx, typeof_addr_left);
        var temp = mk_temp_hir_expr(temp_var, &expr.pos);
        var addr_left = mk_addr_hir_expr(left, &expr.pos);
        var temp_deref = mk_deref_hir_expr(temp, &expr.pos);
        var computation = mk_binary_op_hir_expr(op, temp_deref, right, left.type);
        var assign_temp = mk_assign_hir_expr(temp_deref, computation);
        result = mk_let_hir_expr(temp_var, addr_left, assign_temp, &expr.pos);
    } else if (ast_op == Tok_AmpAmp || ast_op == Tok_BarBar) {
        var right = lower_expr(ctx, ast_right);
        if (ast_op == Tok_AmpAmp) {
            result = mk_cond_hir_expr(left, right, mk_int_hir_expr(0, expr.type, &right.pos), &expr.pos);
        } else {
            result = mk_cond_hir_expr(left, mk_int_hir_expr(1, expr.type, &right.pos), right, &expr.pos);
        }
    } else if (ast_op == Tok_EqEq || ast_op == Tok_BangEq || ast_op == Tok_Lt || ast_op == Tok_LtEq || ast_op == Tok_Gt || ast_op == Tok_GtEq || ast_op == Tok_Amp || ast_op == Tok_Bar || ast_op == Tok_Caret || ast_op == Tok_LtLt || ast_op == Tok_GtGt || ast_op == Tok_Plus || ast_op == Tok_Minus || ast_op == Tok_Star || ast_op == Tok_Slash || ast_op == Tok_Percent) {
        var right = lower_expr(ctx, ast_right);
        var op = translate_binary_op(ast_op);
        result = mk_binary_op_hir_expr(op, left, right, expr.type);
    } else {
        unreachable("elab_binary_expr");
    }
    return result;
}

func lower_ternary_expr(ctx: *Context, expr: *TernaryExpr): *HirExpr {
    var ast_cond = expr.cond;
    var ast_then_expr = expr.then_expr;
    var ast_else_expr = expr.else_expr;

    var cond = lower_expr(ctx, ast_cond);
    var then_expr = lower_expr(ctx, ast_then_expr);
    var else_expr = lower_expr(ctx, ast_else_expr);

    return mk_cond_hir_expr(cond, then_expr, else_expr, &expr.pos);
}

func lower_cast_expr(ctx: *Context, expr: *CastExpr): *HirExpr {
    var ast_expr = expr.expr;
    var target_type = expr.type;

    var hir_expr = lower_expr(ctx, ast_expr);

    return mk_cast_hir_expr(hir_expr, target_type);
}

func lower_expr(ctx: *Context, expr: *Expr): *HirExpr {
    if (expr.kind == Expr_Ident) {
        return lower_ident_expr(ctx, expr as *IdentExpr);
    } else if (expr.kind == Expr_Literal) {
        return lower_literal_expr(ctx, expr as *LiteralExpr);
    } else if (expr.kind == Expr_Array) {
        return lower_array_expr(ctx, expr as *ArrayExpr);
    } else if (expr.kind == Expr_Call) {
        return lower_call_expr(ctx, expr as *CallExpr);
    } else if (expr.kind == Expr_Index) {
        return lower_index_expr(ctx, expr as *IndexExpr);
    } else if (expr.kind == Expr_Member) {
        return lower_member_expr(ctx, expr as *MemberExpr);
    } else if (expr.kind == Expr_Sizeof) {
        return lower_sizeof_expr(ctx, expr as *SizeofExpr);
    } else if (expr.kind == Expr_Unary) {
        return lower_unary_expr(ctx, expr as *UnaryExpr);
    } else if (expr.kind == Expr_Binary) {
        return lower_binary_expr(ctx, expr as *BinaryExpr);
    } else if (expr.kind == Expr_Ternary) {
        return lower_ternary_expr(ctx, expr as *TernaryExpr);
    } else if (expr.kind == Expr_Cast) {
        return lower_cast_expr(ctx, expr as *CastExpr);
    } else {
        unreachable("lower_expr");
    }
}

func lower_assign_expr(ctx: *Context, dst: *HirExpr, ast_src: *Expr, pos: *Pos): *HirExpr {
    var type = dst.type;
    assert(type_eq(type, ast_src.type), "lower_assign_expr: type mismatch");

    if (ast_src.kind == Expr_Call && (ast_src as *CallExpr).resolved_callee.kind == Sym_Struct) {
        /*
            desugar
                x = List(1, List(2, null))
            to
                let t1: *List = &x in
                    (*t1).value = 1;
                    let t2: *List = &t1.next in
                        (*t2).value = 2;
                        (*t2).next = null
        */

        var resolved_callee = (ast_src as *CallExpr).resolved_callee;
        var args = (ast_src as *CallExpr).args;
        var structSym = resolved_callee;
        var fields = (structSym as *StructSym).fields;

        var addr_dst = mk_addr_hir_expr(dst, &dst.pos);
        var temp_var = mk_temp_var(ctx, addr_dst.type);
        var temp = mk_temp_hir_expr(temp_var, pos);
        var body = mk_skip_stmt(pos);

        for (var i = 0; i < args.len; i += 1) {
            var ast_arg: *CallArg = list_get(args, i);
            var field: *StructField = list_get(fields, i);

            var temp_deref = mk_deref_hir_expr(temp, pos);
            var field_access = mk_member_hir_expr(temp_deref, field.name, i, field.type);
            var assignment = lower_assign_expr(ctx, field_access, ast_arg.expr, &ast_arg.expr.pos);
            body = mk_seq_hir_expr(body, assignment);
        }

        return mk_let_hir_expr(temp_var, addr_dst, body, pos);
    } else if (ast_src.kind == Expr_Array) {
        /*
            desugar
                x = [a, b, c]
            to
                let t1: *T = &x[0] in
                    t1[0] = a;
                    t1[1] = b;
                    t1[2] = c
        */

        var elems = (ast_src as *ArrayExpr).elems;
        var elem_type = (type as *ArrType).elem;
        assert(elem_type, "lower_assign_expr: array type should have an element type");
        var array_size = (type as *ArrType).size;

        var zero = mk_int_hir_expr(0, mk_int_type(4), pos);
        var zero_index = mk_index_hir_expr(dst, zero);
        var addr_zero_index = mk_addr_hir_expr(zero_index, pos);

        var temp_var = mk_temp_var(ctx, addr_zero_index.type);
        var temp = mk_temp_hir_expr(temp_var, pos);
        var body = mk_skip_stmt(pos);

        for (var i = 0; i < array_size; i += 1) {
            var ast_elem: *Expr = list_get(elems, i);
            var index = mk_int_hir_expr(i, mk_int_type(4), pos);
            var index_expr = mk_index_hir_expr(temp, index);
            var assignment = lower_assign_expr(ctx, index_expr, ast_elem, &ast_elem.pos);
            body = mk_seq_hir_expr(body, assignment);
        }

        // something is null...
        assert(addr_zero_index.type, "lower_assign_expr: addr_zero_index should have a type");
        assert(addr_zero_index.expr.type, "lower_assign_expr: addr_zero_index should have a type");

        return mk_let_hir_expr(temp_var, addr_zero_index, body, pos);
    } else {
        var src = lower_expr(ctx, ast_src);
        return mk_assign_hir_expr(dst, src);
    }
}

//==============================================================================
//== Statements

func lower_stmt(ctx: *Context, stmt: *Stmt): *HirExpr;

func lower_block_stmt(ctx: *Context, stmt: *BlockStmt): *HirExpr {
    var current = mk_skip_stmt(&stmt.pos);

    for (var i = 0; i < stmt.stmts.len; i += 1) {
        var ast_stmt = list_get(stmt.stmts, i);
        var hir_stmt = lower_stmt(ctx, ast_stmt);

        current = mk_seq_hir_expr(current, hir_stmt);
    }

    return current;
}

func lower_local_stmt(ctx: *Context, stmt: *LocalStmt): *HirExpr {
    var sym = stmt.sym;
    var type = sym.type;
    var ast_init = stmt.init;

    if (!ast_init) {
        return mk_skip_stmt(&stmt.pos);
    }

    var var_expr = mk_var_hir_expr(sym, type, &stmt.pos);
    return lower_assign_expr(ctx, var_expr, ast_init, &ast_init.pos);
}

func lower_if_stmt(ctx: *Context, stmt: *IfStmt): *HirExpr {
    var ast_cond = stmt.cond;
    var ast_then_block = stmt.then_stmt;
    var ast_else_block = stmt.else_stmt;

    var cond = lower_expr(ctx, ast_cond);
    var then_block = lower_stmt(ctx, ast_then_block);
    var else_block = ast_else_block
        ? lower_stmt(ctx, ast_else_block)
        : mk_skip_stmt(&stmt.pos);

    return mk_cond_hir_expr(cond, then_block, else_block, &stmt.pos);
}

func lower_while_stmt(ctx: *Context, stmt: *WhileStmt): *HirExpr {
    var ast_cond = stmt.cond;
    var ast_body = stmt.body;

    var cond = lower_expr(ctx, ast_cond);
    var body = lower_stmt(ctx, ast_body);
    var step = mk_skip_stmt(&stmt.pos);

    return mk_loop_hir_expr(cond, body, step, &stmt.pos);
}

func lower_for_stmt(ctx: *Context, stmt: *ForStmt): *HirExpr {
    var ast_init = stmt.init;
    var ast_cond = stmt.cond;
    var ast_step = stmt.step;
    var ast_body = stmt.body;

    var init = ast_init ? lower_stmt(ctx, ast_init) : mk_skip_stmt(&stmt.pos);
    var cond = ast_cond ? lower_expr(ctx, ast_cond) : mk_int_hir_expr(1, mk_int_type(4), &stmt.pos);
    var step = ast_step ? lower_expr(ctx, ast_step) : mk_skip_stmt(&stmt.pos);
    var body = lower_stmt(ctx, ast_body);

    return mk_seq_hir_expr(init, mk_loop_hir_expr(cond, body, step, &stmt.pos));
}

func lower_return_stmt(ctx: *Context, stmt: *ReturnStmt): *HirExpr {
    var ast_expr = stmt.expr;

    var expr = ast_expr ? lower_expr(ctx, ast_expr) : null;

    return mk_return_hir_expr(expr, &stmt.pos);
}

func lower_break_stmt(ctx: *Context, stmt: *Stmt): *HirExpr {
    return mk_jump_hir_expr(true, &stmt.pos);
}

func lower_continue_stmt(ctx: *Context, stmt: *Stmt): *HirExpr {
    return mk_jump_hir_expr(false, &stmt.pos);
}

func lower_expr_stmt(ctx: *Context, stmt: *ExprStmt): *HirExpr {
    var ast_expr = stmt.expr;
    return lower_expr(ctx, ast_expr);
}

func lower_stmt(ctx: *Context, stmt: *Stmt): *HirExpr {
    if (stmt.kind == Stmt_Block) {
        return lower_block_stmt(ctx, stmt as *BlockStmt);
    } else if (stmt.kind == Stmt_Local) {
        return lower_local_stmt(ctx, stmt as *LocalStmt);
    } else if (stmt.kind == Stmt_If) {
        return lower_if_stmt(ctx, stmt as *IfStmt);
    } else if (stmt.kind == Stmt_While) {
        return lower_while_stmt(ctx, stmt as *WhileStmt);
    } else if (stmt.kind == Stmt_For) {
        return lower_for_stmt(ctx, stmt as *ForStmt);
    } else if (stmt.kind == Stmt_Return) {
        return lower_return_stmt(ctx, stmt as *ReturnStmt);
    } else if (stmt.kind == Stmt_Break) {
        return lower_break_stmt(ctx, stmt);
    } else if (stmt.kind == Stmt_Continue) {
        return lower_continue_stmt(ctx, stmt);
    } else if (stmt.kind == Stmt_Expr) {
        return lower_expr_stmt(ctx, stmt as *ExprStmt);
    } else {
        unreachable("lower_stmt");
    }
}

//==============================================================================
//== Top-level declarations

func lower(func_: *Sym, body: *Stmt): *HirExpr {
    var ctx: *Context = calloc(1, sizeof(Context));
    ctx.func_ = func_;
    ctx.temps = list_new();

    return lower_stmt(ctx, body);
}
