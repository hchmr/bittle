include "cog.cogs";

struct CodegenCtx {
    frame_size: Int,
    label_count: Int,
    temp_size: Int,
    current_func: *Sym,
    current_loop: Int,
}

func next_label(ctx: *CodegenCtx): Int {
    ctx.label_count += 1;
    return ctx.label_count;
}

func strx(type: *Type): *Char {
    if (type_size(type) == 1)
        return "strb w";
    if (type_size(type) == 2)
        return "strh w";
    if (type_size(type) == 4)
        return "str w";
    if (type_size(type) == 8)
        return "str x";
    assert(false, "strx: Unreachable.");
}

func ldrx(type: *Type): *Char {
    if (type.kind == Type_Bool)
        return "ldrb w";
    if (type.kind == Type_Int && type.size == 1)
        return "ldrsb x";
    if (type.kind == Type_Int && type.size == 2)
        return "ldrsh x";
    if (type.kind == Type_Int && type.size == 4)
        return "ldrsw x";
    if (type_size(type) == 8)
        return "ldr x";
    assert(false, "ldrx: Unreachable.");
}

func emit_push(ctx: *CodegenCtx, reg: Int) {
    if (ctx.temp_size + 8 >= FRAME_TEMP_SIZE) {
        fprintf(stderr, "Ran out of space for temporaries while compiling expression.\n");
        exit(1);
    }
    ctx.temp_size += 8;
    printf("  str x%d, [sp, #%d] // push\n", reg, FRAME_ARGS_SIZE + FRAME_TEMP_SIZE - ctx.temp_size);
}

func emit_pop(ctx: *CodegenCtx, reg: Int) {
    printf("  ldr x%d, [sp, #%d] // pop\n", reg, FRAME_ARGS_SIZE + FRAME_TEMP_SIZE - ctx.temp_size);
    ctx.temp_size -= 8;
}

func emit_sign_extend(ctx: *CodegenCtx, source: *Type, t0: Int, t1: Int) {
    assert(is_scalar(source), "emit_sign_extend: source should be a scalar.");
    if (source.kind == Type_Int && source.size < 8) {
        var suffix = "_bh_w"[source.size];
        printf("  sxt%c x%d, w%d\n", suffix, t0, t1);
    } else {
        if (t0 != t1) {
            printf("  mov x%d, x%d\n", t0, t1);
        }
    }
}

func emit_expr(ctx: *CodegenCtx, e: *Expr, t0: Int);

func emit_expr_lvalue(ctx: *CodegenCtx, e: *Expr, t0: Int);

func emit_operands(ctx: *CodegenCtx, e: *Expr, t0: Int, t1: Int) {
    emit_expr(ctx, e.children[0], t0);
    emit_push(ctx, t0);
    emit_expr(ctx, e.children[1], t1);
    emit_pop(ctx, t0);
}

func emit_operands_lvalue(ctx: *CodegenCtx, e: *Expr, t0: Int, t1: Int) {
    emit_expr_lvalue(ctx, e.children[0], t0);
    emit_push(ctx, t0);
    emit_expr(ctx, e.children[1], t1);
    emit_pop(ctx, t0);
}

func emit_expr_binary(ctx: *CodegenCtx, op: *Char, e: *Expr, t0: Int) {
    emit_operands(ctx, e, 0, 1);
    printf("  %s x%d, x%d, x%d\n", op, t0, 0, 1);
}

func emit_expr_cmp(ctx: *CodegenCtx, op: *Char, e: *Expr, t0: Int) {
    emit_operands(ctx, e, 0, 1);
    printf("  cmp x%d, x%d\n", 0, 1);
    printf("  cset x%d, %s\n", t0, op);
}

func emit_expr_lvalue(ctx: *CodegenCtx, e: *Expr, t0: Int) {
    if (str_eq(e.kind, "<var>") && e.sym.kind == Sym_Local) {
        var name = e.sym.name;
        printf("  add x%d, sp, #%d // &%s\n", t0, ctx.frame_size - e.sym.offset, name);
    } else if (str_eq(e.kind, "<var>") && e.sym.kind == Sym_Global) {
        var name = e.sym.name;
        if (e.sym.is_defined) {
            printf("  adrp x%d, %s\n", t0, name);
            printf("  add x%d, x%d, :lo12:%s // &%s\n", t0, t0, name, name);
        } else {
            printf("  adrp x%d, :got:%s\n", t0, name);
            printf("  ldr x%d, [x%d, :got_lo12:%s] // &%s\n", t0, t0, name, name);
        }
    } else if (str_eq(e.kind, "_._")) {
        var lhs_type = e.children[0].type;
        var field_name = lhs_type.field_names[e.field_index];
        var field_offset = lhs_type.field_offsets[e.field_index];
        emit_expr_lvalue(ctx, e.children[0], t0);
        printf("  add x%d, x%d, #%d // &%s\n", t0, t0, field_offset, field_name);
    } else if (str_eq(e.kind, "*_")) {
        emit_expr(ctx, e.children[0], t0);
    } else if (str_eq(e.kind, "_[_]")) {
        if (e.children[0].type.kind == Type_Ptr) {
            emit_operands(ctx, e, 0, 1);
        } else {
            emit_operands_lvalue(ctx, e, 0, 1);
        }
        var elem_size = type_size(e.children[0].type.base);
        printf("  add x%d, x0, x1, lsl #%d // &_[_]\n", t0, ilog2(elem_size));
    } else {
        assert(false, "emit_expr_lvalue: Unreachable.");
    }
}

func emit_expr(ctx: *CodegenCtx, e: *Expr, t0: Int) {
    if (is_lvalue(e)) {
        emit_expr_lvalue(ctx, e, t0);
        printf("  %s%d, [x%d]\n", ldrx(e.type), t0, t0);
    } else if (str_eq(e.kind, "<int>")) {
        printf("  mov x%d, #%d\n", t0, e.int_val);
    } else if (str_eq(e.kind, "<str>")) {
        var label = next_label(ctx);
        printf("  .text\n");
        printf("  .section .rodata\n");
        printf("  .align 3\n");
        printf(".str.%d:\n", label);
        printf("  .string \"");
        var i = 0;
        while (e.str_val[i] != '\0') {
            if (!is_print(e.str_val[i]) || e.str_val[i] == '\"' || e.str_val[i] == '\\') {
                printf("\\%03o", e.str_val[i]);
            } else {
                printf("%c", e.str_val[i]);
            }
            i += 1;
        }
        printf("\"\n");
        printf("  .text\n");
        printf("  adrp x%d, .str.%d\n", t0, label);
        printf("  add x%d, x%d, :lo12:.str.%d\n", t0, t0, label);
    } else if (str_eq(e.kind, "_(_)")) {
        var sym = e.sym;
        var i = 0;
        while (i < e.child_count) {
            emit_expr(ctx, e.children[i], 0);
            if (i >= MAX_PARAMS) {
                printf("  str x0, [sp, #%d]\n", 8 * (i - sym.param_count));
            } else {
                emit_push(ctx, 0);
            }
            i += 1;
        }
        i = int_min(e.child_count, MAX_PARAMS);
        while (i > 0) {
            i -= 1;
            emit_pop(ctx, i);
        }
        printf("  bl %s\n", e.sym.name);
        if (e.type.kind != Type_Void) {
            emit_sign_extend(ctx, e.type, t0, 0);
        }
    } else if (str_eq(e.kind, "&_")) {
        emit_expr_lvalue(ctx, e.children[0], t0);
    } else if (str_eq(e.kind, "!_")) {
        emit_expr(ctx, e.children[0], t0);
        printf("  eor x%d, x%d, #1\n", t0, t0);
    } else if (str_eq(e.kind, "~_")) {
        emit_expr(ctx, e.children[0], t0);
        printf("  mvn x%d, x%d\n", t0, t0);
    } else if (str_eq(e.kind, "-_")) {
        emit_expr(ctx, e.children[0], t0);
        printf("  neg x%d, x%d\n", t0, t0);
    } else if (str_eq(e.kind, "_&&_") || str_eq(e.kind, "_||_")) {
        var label = next_label(ctx);
        printf(".L%d.begin: // %s\n", label, e.kind);
        emit_expr(ctx, e.children[0], t0);
        if (str_eq(e.kind, "_&&_")) {
            printf("  cbz x%d, .L%d.end\n", t0, label);
        } else {
            printf("  cbnz x%d, .L%d.end\n", t0, label);
        }
        emit_expr(ctx, e.children[1], t0);
        printf(".L%d.end:\n", label);
    } else if (str_eq(e.kind, "_|_")) {
        emit_expr_binary(ctx, "orr", e, t0);
    } else if (str_eq(e.kind, "_^_")) {
        emit_expr_binary(ctx, "eor", e, t0);
    } else if (str_eq(e.kind, "_&_")) {
        emit_expr_binary(ctx, "and", e, t0);
    } else if (str_eq(e.kind, "_==_")) {
        emit_expr_cmp(ctx, "eq", e, t0);
    } else if (str_eq(e.kind, "_!=_")) {
        emit_expr_cmp(ctx, "ne", e, t0);
    } else if (str_eq(e.kind, "_<_")) {
        emit_expr_cmp(ctx, "lt", e, t0);
    } else if (str_eq(e.kind, "_<=_")) {
        emit_expr_cmp(ctx, "le", e, t0);
    } else if (str_eq(e.kind, "_>_")) {
        emit_expr_cmp(ctx, "gt", e, t0);
    } else if (str_eq(e.kind, "_>=_")) {
        emit_expr_cmp(ctx, "ge", e, t0);
    } else if (str_eq(e.kind, "_<<_")) {
        emit_expr_binary(ctx, "lsl", e, t0);
    } else if (str_eq(e.kind, "_>>_")) {
        emit_expr_binary(ctx, "lsr", e, t0);
    } else if (str_eq(e.kind, "_+_")) {
        emit_expr_binary(ctx, "add", e, t0);
    } else if (str_eq(e.kind, "_-_")) {
        emit_expr_binary(ctx, "sub", e, t0);
    } else if (str_eq(e.kind, "_*_")) {
        emit_expr_binary(ctx, "mul", e, t0);
    } else if (str_eq(e.kind, "_/_")) {
        emit_expr_binary(ctx, "sdiv", e, t0);
    } else if (str_eq(e.kind, "_%_")) {
        emit_operands(ctx, e, 1, 2);
        printf("  sdiv x%d, x%d, x%d\n", 0, 1, 2);
        printf("  msub x%d, x%d, x%d, x%d\n", t0, 0, 2, 1);
    } else if (str_eq(e.kind, "_?_:_")) {
        var label = next_label(ctx);
        printf(".L%d.if:\n", label);
        emit_expr(ctx, e.children[0], 0);
        printf("  cbz x0, .L%d.else\n", label);
        printf(".L%d.then:\n", label);
        emit_expr(ctx, e.children[1], t0);
        printf("  b .L%d.end\n", label);
        printf(".L%d.else:\n", label);
        if (e.children[2]) {
            emit_expr(ctx, e.children[2], t0);
        }
        printf(".L%d.end:\n", label);
    } else if (str_eq(e.kind, "_=_") || str_eq(e.kind, "_+=_") || str_eq(e.kind, "_-=_")) {
        var lhs = e.children[0];
        emit_operands_lvalue(ctx, e, 0, 1);
        if (str_eq(e.kind, "_+=_") || str_eq(e.kind, "_-=_")) {
            printf("  %s2, [x0]\n", ldrx(lhs.type));
            if (str_eq(e.kind, "_+=_")) {
                printf("  add x1, x2, x1\n");
            } else if (str_eq(e.kind, "_-=_")) {
                printf("  sub x1, x2, x1\n");
            } else {
                assert(false, "emit_expr: Unreachable.");
            }
        }
        printf("  %s1, [x0]\n", strx(lhs.type));
    } else if (str_eq(e.kind, "<memcpy>")) {
        emit_operands(ctx, e, 0, 1);
        printf("  mov x2, #%d\n", type_size(e.children[0].type.base));
        printf("  bl memcpy\n");
    } else if (str_eq(e.kind, "<cast>")) {
        var target = e.type;
        var source = e.children[0].type;
        assert(is_scalar(target) && is_scalar(source), "emit_expr: <cast> should have scalar types.");
        emit_expr(ctx, e.children[0], t0);
        if (target.kind == Type_Bool) {
            printf("  cmp x%d, #0\n", t0);
            printf("  cset w%d, ne\n", t0);
        } else if (type_size(target) < type_size(source)) {
            emit_sign_extend(ctx, target, t0, t0);
        } else {
            // no-op
        }
    } else if (str_eq(e.kind, "<block>")) {
        var i = 0;
        while (i < e.child_count) {
            emit_expr(ctx, e.children[i], 0);
            i += 1;
        }
    } else if (str_eq(e.kind, "<skip>")) {
        // noop
    } else if (str_eq(e.kind, "<while>")) {
        var label = next_label(ctx);
        var outer_loop = ctx.current_loop;
        ctx.current_loop = label;
        printf(".L%d.next:\n", label);
        emit_expr(ctx, e.children[0], 0);
        printf("  cbz x0, .L%d.done\n", label);
        printf(".L%d.do:\n", label);
        emit_expr(ctx, e.children[1], 0);
        printf("  b .L%d.next\n", label);
        printf(".L%d.done:\n", label);
        ctx.current_loop = outer_loop;
    } else if (str_eq(e.kind, "<break>")) {
        printf("  b .L%d.done\n", ctx.current_loop);
    } else if (str_eq(e.kind, "<continue>")) {
        printf("  b .L%d.next\n", ctx.current_loop);
    } else if (str_eq(e.kind, "<return>")) {
        if (e.children[0]) {
            emit_expr(ctx, e.children[0], 0);
        }
        printf("  b .L.%s.ret\n", ctx.current_func.name);
    } else {
        assert(false, "emit_expr: Unreachable.");
    }
}

func emit_func(ctx: *CodegenCtx, sym: *Sym) {
    ctx.current_func = sym;
    ctx.frame_size = align_up(sym.locals_size, 16) + FRAME_TEMP_SIZE + FRAME_ARGS_SIZE;
    printf("  .text\n");
    printf("  .align 2\n");
    printf("  .global %s\n", sym.name);
    printf("%s:\n", sym.name);
    printf("  stp x29, x30, [sp, #-16]!\n");
    printf("  mov x29, sp\n");
    printf("  sub sp, sp, #%d\n", ctx.frame_size);
    var i = 0;
    while (i < sym.param_count) {
        var param = sym.params[i];
        printf("  %s%d, [sp, #%d] // %s\n", strx(param.type), i, ctx.frame_size - param.offset, param.name);
        i += 1;
    }
    emit_expr(ctx, sym.body, 0);
    printf(".L.%s.ret:\n", sym.name);
    printf("  add sp, sp, #%d\n", ctx.frame_size);
    printf("  ldp x29, x30, [sp], #16\n");
    printf("  ret\n");
}

func emit_global(ctx: *CodegenCtx, sym: *Sym) {
    printf("  .global %s\n", sym.name);
    printf("  .bss\n");
    printf(".align %d\n", type_align(sym.type));
    printf("%s:\n", sym.name);
    printf("  .zero %d\n", type_size(sym.type));
}

func emit_program(env: *Env) {
    var ctx = calloc(1, sizeof(CodegenCtx)) as *CodegenCtx;
    var i = 0;
    while (i < env.sym_count) {
        var sym = env.syms[i];
        if (sym.kind == Sym_Global && sym.is_defined) {
            emit_global(ctx, sym);
        } else if (sym.kind == Sym_Func && sym.is_defined) {
            emit_func(ctx, sym);
        }
        i += 1;
    }
}
