include "cog.cogs";

func is_operator(c: Char): Bool {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '=' || c == '!' || c == '<' || c == '>' ||
           c == '&' || c == '|' || c == '.';
}

func lexer_init(self: *Lexer, file: *File, file_name: *Char) {
    self.file = file;
    self.pos.file = file_name;
    self.pos.line = 1;
}

func next_char(self: *Lexer) {
    if (self.chr == '\n') {
        self.pos.line += 1;
        self.pos.col = 1;
    } else {
        self.pos.col += 1;
    }
    self.chr = fgetc(self.file) as Char;
}

func scan_char(self: *Lexer, tok: *Tok) {
    var c: Char;
    if (self.chr == '\\') {
        next_char(self);
        if (self.chr == '0') {
            c = '\0';
        } else if (self.chr == 'n') {
            c = '\n';
        } else if (self.chr == 'r') {
            c = '\r';
        } else if (self.chr == 't') {
            c = '\t';
        } else if (self.chr == '\\') {
            c = '\\';
        } else if (self.chr == '\'') {
            c = '\'';
        } else if (self.chr == '\"') {
            c = '\"';
        } else {
            error_at(&self.pos);
            fprintf(stderr, "Invalid escape sequence.\n");
            exit(1);
        }
    } else if (is_print(self.chr)) {
        c = self.chr;
    } else {
        error_at(&self.pos);
        fprintf(stderr, "Illegal character.\n");
        exit(1);
    }
    sb_push(&tok.lexeme, c);
    next_char(self);
}

func scan_tok(self: *Lexer, tok: *Tok) {
    tok.pos = self.pos;
    tok.lexeme = null;
    if (self.chr == -1) {
        tok.kind = Tok_Eof;
    } else if (is_space(self.chr)) {
        next_char(self);
        return scan_tok(self, tok);
    } else if (is_digit(self.chr)) {
        while (is_digit(self.chr)) {
            sb_push(&tok.lexeme, self.chr);
            next_char(self);
        }
        tok.kind = Tok_Int;
    } else if (self.chr == '\'') {
        next_char(self);
        if (self.chr == '\'') {
            error_at(&self.pos);
            fprintf(stderr, "Empty character.\n");
            exit(1);
        }
        scan_char(self, tok);
        if (self.chr != '\'') {
            error_at(&self.pos);
            fprintf(stderr, "Expected closing quote.\n");
            exit(1);
        }
        next_char(self);
        tok.kind = Tok_Chr;
    } else if (self.chr == '\"') {
        next_char(self);
        while (self.chr != -1 && self.chr != '\"') {
            scan_char(self, tok);
        }
        if (self.chr != '\"') {
            error_at(&self.pos);
            fprintf(stderr, "Expected closing quote.\n");
            exit(1);
        }
        next_char(self);
        tok.kind = Tok_Str;
    } else if (is_alpha(self.chr) || self.chr == '_') {
        while (is_alpha(self.chr) || is_digit(self.chr) || self.chr == '_') {
            sb_push(&tok.lexeme, self.chr);
            next_char(self);
        }
        tok.kind = Tok_Wrd;
    } else if (is_operator(self.chr)) {
        while (is_operator(self.chr)) {
            sb_push(&tok.lexeme, self.chr);
            next_char(self);
            if (str_eq(tok.lexeme, "//")) {
                while (self.chr != '\n' && self.chr != -1) {
                    next_char(self);
                }
                return scan_tok(self, tok);
            }
        }
        tok.kind = Tok_Sym;
    } else {
        sb_push(&tok.lexeme, self.chr);
        next_char(self);
        tok.kind = Tok_Sym;
    }
    sb_push(&tok.lexeme, '\0');
}
