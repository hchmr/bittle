include "cog.cogs";

func mk_type(kind: Int): *Type {
    var type: *Type = calloc(1, sizeof(Type));
    type.kind = kind;
    return type;
}

func mk_void_type(): *Type {
    return mk_type(Type_Void);
}

func mk_bool_type(): *Type {
    return mk_type(Type_Bool);
}

func mk_int_type(size: Int): *Type {
    var type = mk_type(Type_Int);
    type.size = size;
    return type;
}

func mk_ptr_type(base: *Type): *Type {
    var type = mk_type(Type_Ptr);
    type.base = base;
    return type;
}

func mk_array_type(base: *Type, len: Int): *Type {
    var type = mk_type(Type_Arr);
    type.base = base;
    type.len = len;
    return type;
}

func mk_struct_type(name: *Char): *Type {
    var type = mk_type(Type_Struct);
    type.name = name;
    return type;
}

func mk_never_type(): *Type {
    return mk_type(Type_Never);
}

func type_align(type: *Type): Int {
    if (type.kind == Type_Void)
        return 1;
    if (type.kind == Type_Bool)
        return 1;
    if (type.kind == Type_Int)
        return type.size;
    if (type.kind == Type_Ptr)
        return 8;
    if (type.kind == Type_Arr)
        return type_align(type.base);
    if (type.kind == Type_Struct)
        return 8; // Maximum possible alignment.
    if (type.kind == Type_Never)
        return 1;
    unreachable("type_align");
}

func type_size(type: *Type): Int {
    if (type.kind == Type_Void)
        return -1;
    if (type.kind == Type_Bool)
        return 1;
    if (type.kind == Type_Int)
        return type.size;
    if (type.kind == Type_Ptr)
        return 8;
    if (type.kind == Type_Arr)
        return type.len * align_up(type_size(type.base), type_align(type.base));
    if (type.kind == Type_Struct)
        return type.field_count == 0 ? -1 : align_up(type.unpadded_size, type_align(type));
    if (type.kind == Type_Never)
        return -1;
    unreachable("type_size");
}

func type_eq(t1: *Type, t2: *Type): Bool {
    if (t1.kind != t2.kind)
        return false;
    if (t1.kind == Type_Int)
        return t1.size == t2.size;
    if (t1.kind == Type_Ptr)
        return type_eq(t1.base, t2.base);
    if (t1.kind == Type_Arr)
        return t1.len == t2.len && type_eq(t1.base, t2.base);
    if (t1.kind == Type_Struct)
        return t1 == t2;
    return true;
}

func is_scalar(type: *Type): Bool {
    return type.kind == Type_Bool || type.kind == Type_Int || type.kind == Type_Ptr;
}

func type_le(t1: *Type, t2: *Type): Bool {
    if (t1.kind == Type_Never)
        return true;
    if (is_scalar(t1) && t2.kind == Type_Bool)
        return true;
    if (t1.kind == Type_Int && t2.kind == Type_Int)
        return t1.size <= t2.size;
    if (t1.kind == Type_Ptr && t2.kind == Type_Ptr)
        return t1.base.kind == Type_Void;
    return false;
}

func find_field(type: *Type, name: *Char): Int {
    assert(type.kind == Type_Struct, "find_field: type should be a struct.");
    var i = 0;
    while (i < type.field_count) {
        if (str_eq(type.field_names[i], name)) {
            return i;
        }
        i += 1;
    }
    return -1;
}

func add_field(type: *Type, field_name: *Char, field_type: *Type, pos: *Pos) {
    assert(type.kind == Type_Struct, "add_field: type should be a struct.");

    var existing = find_field(type, field_name);
    if (existing != -1) {
        error_at(pos);
        fprintf(stderr, "Field '%s' is already defined.\n", field_name);
        exit(1);
    }

    if (type_size(field_type) == -1) {
        error_at(pos);
        fprintf(stderr, "Field '%s' has incomplete type.\n", field_name);
        exit(1);
    }

    var i = type.field_count;
    type.field_count += 1;
    type.field_names = realloc(type.field_names, type.field_count * sizeof(*Char));
    type.field_types = realloc(type.field_types, type.field_count * sizeof(*Type));
    type.field_offsets = realloc(type.field_offsets, type.field_count * sizeof(Int));
    type.field_names[i] = field_name;
    type.field_types[i] = field_type;
    type.field_offsets[i] = align_up(type.unpadded_size, type_align(field_type));
    type.unpadded_size = type.field_offsets[i] + type_size(field_type);
}

func print_type(file: *File, type: *Type) {
    if (type.kind == Type_Void) {
        fprintf(file, "Void");
    } else if (type.kind == Type_Bool) {
        fprintf(file, "Bool");
    } else if (type.kind == Type_Int) {
        fprintf(file, "Int%d", type.size * 8);
    } else if (type.kind == Type_Ptr) {
        fprintf(file, "*");
        print_type(file, type.base);
    } else if (type.kind == Type_Arr) {
        fprintf(file, "[");
        print_type(file, type.base);
        fprintf(file, "; %d]", type.len);
    } else if (type.kind == Type_Struct) {
        fprintf(file, "%s", type.name);
    } else if (type.kind == Type_Never) {
        fprintf(file, "!");
    } else {
        unreachable("print_type");
    }
}
