include "bittle.btls";

func assert(cond: Bool, because: *Char) {
    if (!cond) {
        fprintf(stderr, "\n*** Assertion failed: %s\n", because);
        exit(1);
    }
}

func unreachable(function: *Char): ! {
    fprintf(stderr, "\n*** Unreachable code reached in %s\n", function);
    exit(1);
}

func error_at(pos: *Pos) {
    fprintf(stderr, "%s:%d:%d: Error: ", pos.file, pos.row, pos.col);
}

func die(msg: *Char): ! {
    fprintf(stderr, "%s\n", msg);
    exit(1);
}

func die_at(pos: *Pos, msg: *Char): ! {
    error_at(pos);
    fprintf(stderr, "%s\n", msg);
    exit(1);
}

struct StringBuffer {
    buf: *Char,
    len: Int,
    cap: Int,
}

func sb_new(): *StringBuffer {
    return calloc(1, sizeof(StringBuffer));
}

func sb_len(self: *StringBuffer): Int {
    return self.len;
}

func sb_cstr(self: *StringBuffer): *Char {
    return self.buf;
}

func sb_ensure_cap(self: *StringBuffer, cap: Int) {
    if (self.cap >= cap) {
        return;
    }
    var new_cap = 1;
    while (new_cap < cap) {
        new_cap *= 2;
    }
    self.buf = realloc(self.buf, new_cap);
    self.cap = new_cap;
}

func sb_shrink_to_fit(self: *StringBuffer) {
    self.buf = realloc(self.buf, self.len + 1);
    self.cap = self.len + 1;
}

func sb_push(self: *StringBuffer, c: Char) {
    sb_ensure_cap(self, self.len + 2);
    self.buf[self.len] = c;
    self.buf[self.len + 1] = '\0';
    self.len += 1;
}

func sb_append(self: *StringBuffer, s: *Char) {
    var i = 0;
    while (s[i]) {
        sb_push(self, s[i]);
        i += 1;
    }
}

func sb_finish(self: *StringBuffer): *Char {
    sb_shrink_to_fit(self);
    var buf = self.buf;
    free(self);
    return buf;
}

func list_ensure_cap(self: *List, cap: Int) {
    if (self.cap >= cap) {
        return;
    }
    var new_cap = 1;
    while (new_cap < cap) {
        new_cap *= 2;
    }
    self.elems = realloc(self.elems, new_cap * sizeof(*Void));
    self.cap = new_cap;
}

func list_new(): *List {
    return calloc(1, sizeof(List));
}

func list_new_with_cap(cap: Int64): *List {
    var list = calloc(1, sizeof(List));
    list_ensure_cap(list, cap);
    return list;
}

func list_len(self: *List): Int {
    return self.len;
}

func list_get(self: *List, i: Int): *Void {
    assert(i >= 0 && i < self.len, "list_get: index out of bounds");
    return self.elems[i];
}

func list_set(self: *List, i: Int, elem: *Void) {
    assert(i >= 0 && i < self.len, "list_set: index out of bounds");
    self.elems[i] = elem;
}

func list_push(self: *List, elem: *Void) {
    list_ensure_cap(self, self.len + 1);
    self.elems[self.len] = elem;
    self.len += 1;
}

func str_eq(a: *Char, b: *Char): Bool {
    return strcmp(a, b) == 0;
}

func align_up(size: Int , align: Int): Int {
    return (size + align - 1) / align * align;
}

func ilog2(n: Int): Int {
    var i = 0;
    while (n > 1) {
        n /= 2;
        i += 1;
    }
    return i;
}

func int_min(a: Int, b: Int): Int {
    return a > b ? b : a;
}

func read_file(file: *File): *Char {
    var len = 0;
    var cap = 4096;
    var buf = malloc(cap) as *Char;
    while (true) {
        var avail = cap - len;
        var n = fread(&buf[len], 1, avail, file);
        len += n;
        if (n != avail) {
            break;
        }
        cap *= 2;
        buf = realloc(buf, cap) as *Char;
    }
    buf = realloc(buf, len + 1) as *Char;
    buf[len] = '\0';
    return buf;
}

func get_directory(path: *Char): *Char {
    var i = strlen(path);
    while (true) {
        if (i == 0)
            return ".";
        i -= 1;
        if (path[i] == '/') {
            var dir = malloc(i + 1) as *Char;
            memcpy(dir, path, i);
            dir[i] = '\0';
            return dir;
        }
    }
    unreachable("get_directory");
}

func join_paths(dir: *Char, file: *Char): *Char {
    var sb = sb_new();
    sb_append(sb, dir);
    sb_push(sb, '/');
    sb_append(sb, file);
    return sb_finish(sb);
}

func is_whitespace(c: Int32): Bool {
    return c == ' ' || c == '\n' || c == '\r' || c == '\t';
}

func is_digit(c: Int32): Bool {
    return c >= '0' && c <= '9';
}

func is_word_start(c: Int32): Bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}

func is_word_part(c: Int32): Bool {
    return is_word_start(c) || is_digit(c);
}

func is_print(c: Int32): Bool {
    return c >= ' ' && c <= '~';
}

func parse_char(s: *Char): Char {
    var string = parse_string(s);
    assert(strlen(string) <= 1, "parse_char: expected single character");
    var char = string[0];
    free(string);
    return char;
}

func parse_string(s: *Char): *Char {
    var sb = sb_new();
    var i = 0;
    var quote = s[i];
    assert(quote == '"' || quote == '\'', "parse_string: expected quote");
    i += 1;
    while (s[i] && s[i] != quote) {
        if (s[i] == '\\') {
            i += 1;
            if (s[i] == '0') {
                sb_push(sb, '\0');
            } else if (s[i] == '\\') {
                sb_push(sb, '\\');
            } else if (s[i] == '\'') {
                sb_push(sb, '\'');
            } else if (s[i] == '\"') {
                sb_push(sb, '\"');
            } else if (s[i] == 'n') {
                sb_push(sb, '\n');
            } else if (s[i] == 'r') {
                sb_push(sb, '\r');
            } else if (s[i] == 't') {
                sb_push(sb, '\t');
            } else {
                die("Invalid escape sequence.");
            }
            i += 1;
        } else {
            sb_push(sb, s[i]);
            i += 1;
        }
    }
    assert(s[i] == quote, "parse_string: expected quote");

    return sb_finish(sb);
}
