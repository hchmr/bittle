include "bittle.btls";

//==============================================================================
//== Scope

struct ScopeEntry {
    name: *Char,
    sym_index: Int,
}

struct Scope {
    entries: *List, // List<ScopeEntry>
    parent: *Scope,
}

func scope_new(parent: *Scope): *Scope {
    var scope: *Scope = calloc(1, sizeof(Scope));
    *scope = Scope(entries: list_new(), parent: parent);
    return scope;
}

func scope_drop(scope: *Scope) {
    free(scope.entries);
    free(scope);
}

func scope_lookup(scope: *Scope, name: *Char, max_depth: Int): Int {
    if (scope == null || max_depth == 0) {
        return -1;
    }
    for (var i = 0; i < scope.entries.len; i += 1) {
        var entry: *ScopeEntry = list_get(scope.entries, i);
        if (str_eq(entry.name, name)) {
            return entry.sym_index;
        }
    }
    return scope_lookup(scope.parent, name, max_depth - 1);
}

//==============================================================================
//== Context

struct ElabCtx {
    syms: *List, // List<Sym>
    scope: *Scope,
    current_func: *FuncSym,
    loop_depth: Int,
}

func enter_scope(ctx: *ElabCtx) {
    ctx.scope = scope_new(ctx.scope);
}

func exit_scope(ctx: *ElabCtx) {
    var scope = ctx.scope;
    ctx.scope = scope.parent;
    scope_drop(scope);
}

//==============================================================================
//== Symbol declaration & lookup

func lookup(ctx: *ElabCtx, name: *Char): *Sym {
    var sym_index = scope_lookup(ctx.scope, name, -1);
    if (sym_index == -1) {
        return null;
    }
    return list_get(ctx.syms, sym_index);
}

func try_get_existing(ctx: *ElabCtx, name: *Char): *Sym {
    var sym_index = scope_lookup(ctx.scope, name, 1);
    if (sym_index == -1) {
        return null;
    }
    return list_get(ctx.syms, sym_index);
}

func add_sym(ctx: *ElabCtx, sym: *Sym) {
    var entry: *ScopeEntry = calloc(1, sizeof(ScopeEntry));
    *entry = ScopeEntry(name: sym.name, sym_index: ctx.syms.len);
    list_push(ctx.syms, sym);
    list_push(ctx.scope.entries, entry);
}

func define_enum(ctx: *ElabCtx, pos: *Pos, name: *Char): *EnumSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        die_at(pos, "Symbol is already defined");
    }

    var sym = calloc(1, sizeof(EnumSym)) as *EnumSym;
    *sym = EnumSym(Sym_Enum, name, size: 4);
    add_sym(ctx, sym);
    return sym;
}

func declare_struct(
    ctx: *ElabCtx,
    pos: *Pos,
    name: *Char,
    is_definition: Bool
): *StructSym {
    var sym = try_get_existing(ctx, name);
    if (sym) {
        if (sym.kind != Sym_Struct) {
            die_at(pos, "redeclared as different kind of symbol");
        }
        if (sym_is_defined(sym) && is_definition) {
            die_at(pos, "redefinition of existing symbol");
        }
    } else {
        sym = calloc(1, sizeof(StructSym)) as *StructSym;
        *sym = Sym(Sym_Struct, name); // TODO
        add_sym(ctx, sym);
    }
    return sym as *StructSym;
}

func params_eq(xs: *List, ys: *List): Bool {
    if (xs.len != ys.len) {
        return false;
    }
    for (var i = 0; i < xs.len; i += 1) {
        var param1: *FuncParam = list_get(xs, i);
        var param2: *FuncParam = list_get(ys, i);
        if (!type_eq(param1.type, param2.type)) {
            return false;
        }
    }
    return true;
}

func declare_func(
    ctx: *ElabCtx,
    pos: *Pos,
    name: *Char,
    params: *List,
    return_type: *Type,
    is_variadic: Bool,
    is_definition: Bool
): *FuncSym {
    var sym = try_get_existing(ctx, name);
    if (sym) {
        if (sym.kind != Sym_Func) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        var sym = sym as *FuncSym;
        if (!params_eq(sym.params, params)) {
            die_at(pos, "Symbol redeclared with different parameters");
        }
        if (!type_eq(sym.return_type, return_type)) {
            die_at(pos, "Symbol redeclared with different return type");
        }
        if (sym.is_variadic != is_variadic) {
            die_at(pos, "Symbol redeclared with different variadicity");
        }
        if (sym_is_defined(sym) && is_definition) {
            die_at(pos, "Symbol is already defined");
        }
    } else {
        sym = calloc(1, sizeof(FuncSym)) as *FuncSym;
        *(sym as *FuncSym) = FuncSym(Sym_Func, name,
            params: params,
            return_type: return_type,
            is_variadic: is_variadic,
            is_defined: is_definition,
            locals: list_new(),
            body: null
        );
        add_sym(ctx, sym);
    }
    return sym as *FuncSym;
}

func define_const(ctx: *ElabCtx, pos: *Pos, name: *Char, type: *Type, value: Int32) {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        die_at(pos, "Symbol is already defined");
    }

    var sym = calloc(1, sizeof(ConstSym)) as *ConstSym;
    *sym = ConstSym(Sym_Const, name, type, value);
    add_sym(ctx, sym);
}

func declare_global(ctx: *ElabCtx, pos: *Pos, name: *Char, type: *Type, is_definition: Bool): *GlobalSym {
    var sym = try_get_existing(ctx, name);
    if (sym) {
        if (sym.kind != Sym_Global) {
            die_at(pos, "Another symbol with the same name already exists");
        }
        if (!type_eq((sym as *GlobalSym).type, type)) {
            die_at(pos, "Symbol redeclared with different type");
        }
        if (sym_is_defined(sym) && is_definition) {
            die_at(pos, "Symbol is already defined");
        }
    } else {
        sym = calloc(1, sizeof(GlobalSym)) as *GlobalSym;
        *(sym as *GlobalSym) = GlobalSym(Sym_Global, name, type, is_defined: false);
        add_sym(ctx, sym);
    }
    return sym as *GlobalSym;
}

func define_local(ctx: *ElabCtx, pos: *Pos, name: *Char, type: *Type): *LocalSym {
    var existing = try_get_existing(ctx, name);
    if (existing) {
        die_at(pos, "Symbol is already defined");
    }

    var sym = calloc(1, sizeof(LocalSym)) as *LocalSym;
    *sym = LocalSym(Sym_Local, name, type, frame_offset: -1);
    add_sym(ctx, sym);

    list_push((ctx.current_func).locals, sym);

    return sym;
}

func define_params(ctx: *ElabCtx, param_decls: *List, params: *List) {
    for (var i = 0; i < list_len(params); i += 1) {
        var param_decl: *FuncParamDecl = list_get(param_decls, i);
        var param: *FuncParam = list_get(params, i);
        define_local(ctx, &param_decl.pos, param.name, param.type);
    }
}

//==============================================================================
//== Type checking

func try_coerce(e: *Expr, target: *Type): *Expr {
    if (type_eq(e.type, target)) {
        // Ok
    } else if (type_le(e.type, target)) {
        var cast: *CastExpr = calloc(1, sizeof(CastExpr));
        *cast = CastExpr(Expr_Cast, e.pos, target, expr: e, type_expr: null);
        e = cast;
    } else if (e.kind == Expr_Literal && (e as *LiteralExpr).literal.kind == Literal_Int && target.kind == Type_Int) {
        var target = target as *IntType;
        var integer_value = ((e as *LiteralExpr).literal as *IntLiteral).value;
        var size = ilog2(integer_value) + 1;
        if (size < target.size) {
            e.type = target;
        }
    } else {
        // Err
    }
    return e;
}

func check_type(e: **Expr, expected: *Type) {
    *e = try_coerce((*e), expected);
    if (expected.kind == Type_Ptr && (expected as *PtrType).pointee.kind == Type_Void && (*e).type.kind == Type_Ptr) {
        return;
    }
    if (!type_eq((*e).type, expected)) {
        error_at(&(*e).pos);
        fprintf(stderr, "Type mismatch: ");
        pretty_type(stderr, (*e).type);
        fprintf(stderr, " != ");
        pretty_type(stderr, expected);
        fprintf(stderr, ".\n");
        exit(1);
    }
}

func check_type_int(e: **Expr) {
    if ((*e).type.kind != Type_Int) {
        die_at(&(*e).pos, "Integer expression expected");
    }
}

func check_type_bool(e: **Expr) {
    check_type(e, mk_bool_type());
}

func unify_types(e1: **Expr, e2: **Expr) {
    *e2 = try_coerce(*e2, (*e1).type);
    *e1 = try_coerce(*e1, (*e2).type);
    check_type(e2, (*e1).type);
}

//==============================================================================
//== Types

func const_eval(ctx: *ElabCtx, expr: *Expr): Int32;

func eval_type(ctx: *ElabCtx, type_expr: *TypeExpr): *Type {
    if (type_expr.kind == TypeExpr_Named) {
        var name: *Char = (type_expr as *NamedTypeExpr).name;
        if (str_eq(name, "Void")) {
            return mk_void_type();
        } else if (str_eq(name, "Bool")) {
            return mk_bool_type();
        } else if (str_eq(name, "Char") || str_eq(name, "Int8")) {
            return mk_int_type(1);
        } else if (str_eq(name, "Int16")) {
            return mk_int_type(2);
        } else if (str_eq(name, "Int32")) {
            return mk_int_type(4);
        } else if (str_eq(name, "Int") || str_eq(name, "Int64")) {
            return mk_int_type(8);
        } else {
            var sym = lookup(ctx, name);
            if (!sym) {
                die_at(&type_expr.pos, "Unknown type");
            }
            if (sym.kind == Sym_Enum) {
                return mk_enum_type(sym as *EnumSym);
            } else if (sym.kind == Sym_Struct) {
                return mk_struct_type(sym as *StructSym);
            } else {
                die_at(&type_expr.pos, "Expected a type");
            }
        }
    } else if (type_expr.kind == TypeExpr_Ptr) {
        var pointee = eval_type(ctx, (type_expr as *PtrTypeExpr).pointee);
        return mk_ptr_type(pointee);
    } else if (type_expr.kind == TypeExpr_Arr) {
        var type_expr = type_expr as *ArrTypeExpr;
        var elem = eval_type(ctx, type_expr.elem);
        var size = const_eval(ctx, type_expr.size);
        return mk_array_type(elem, size);
    } else if (type_expr.kind == TypeExpr_Never) {
        return mk_never_type();
    } else {
        unreachable("eval_type");
    }
}

//==============================================================================
//== Constants

func invalid_const_expr(ctx: *ElabCtx, expr: *Expr): ! {
    die_at(&expr.pos, "Invalid constant expression");
}

func const_eval(ctx: *ElabCtx, expr: *Expr): Int32 {
    if (expr.kind == Expr_Literal && (expr as *LiteralExpr).literal.kind == Literal_Int) {
        return ((expr as *LiteralExpr).literal as *IntLiteral).value as Int32;
    } else if (expr.kind == Expr_Unary) {
        var expr = expr as *UnaryExpr;
        var op = expr.op;
        var right_expr = expr.right;
        if (op == Tok_Minus) {
            return -const_eval(ctx, right_expr);
        } else {
            invalid_const_expr(ctx, expr);
        }
    } else if (expr.kind == Expr_Binary) {
        var expr = expr as *BinaryExpr;
        var op = expr.op;
        var left_expr = expr.left;
        var right_expr = expr.right;
        var left = const_eval(ctx, left_expr);
        var right = const_eval(ctx, right_expr);
        if (op == Tok_Plus) {
            return left + right;
        } else if (op == Tok_Minus) {
            return left - right;
        } else if (op == Tok_Star) {
            return left * right;
        } else if (op == Tok_Slash) {
            return left / right;
        } else if (op == Tok_Percent) {
            return left % right;
        } else {
            invalid_const_expr(ctx, expr);
        }
    } else if (expr.kind == Expr_Sizeof) {
        var type = eval_type(ctx, (expr as *SizeofExpr).type_expr);
        return type_size(type) as Int32;
    } else if (expr.kind == Expr_Ident) {
        var sym = lookup(ctx, (expr as *IdentExpr).name);
        if (!sym) {
            die_at(&expr.pos, "Unknown symbol");
        }
        if (sym.kind == Sym_Const) {
            return (sym as *ConstSym).value;
        } else {
            invalid_const_expr(ctx, expr);
        }
    } else {
        invalid_const_expr(ctx, expr);
    }
}

//==============================================================================
//== Expressions

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr);

func elab_expr_expect(ctx: *ElabCtx, expr: **Expr, expected: *Type) {
    elab_expr_infer(ctx, *expr);
    check_type(expr, expected);
}

func elab_expr_bool(ctx: *ElabCtx, expr: **Expr) {
    elab_expr_expect(ctx, expr, mk_bool_type());
}

func elab_expr_int(ctx: *ElabCtx, expr: **Expr) {
    elab_expr_infer(ctx, *expr);
    check_type_int(expr);
}

func elab_ident_expr(ctx: *ElabCtx, expr: *IdentExpr) {
    var name = expr.name;

    var sym = lookup(ctx, name);
    if (!sym) {
        die_at(&expr.pos, "Unknown symbol");
    }

    var type: *Type;
    if (sym.kind == Sym_Local) {
        type = (sym as *LocalSym).type;
    } else if (sym.kind == Sym_Global) {
        type = (sym as *GlobalSym).type;
    } else if (sym.kind == Sym_Const) {
        type = (sym as *ConstSym).type;
    } else {
        die_at(&expr.pos, "Expected a variable or constant");
    }

    expr.sym = sym;
    expr.type = type;
}

func elab_literal_expr(ctx: *ElabCtx, expr: *LiteralExpr) {
    var literal = expr.literal;

    if (literal.kind == Literal_Null) {
        expr.type = mk_ptr_type(mk_void_type());
    } else if (literal.kind == Literal_Bool) {
        expr.type = mk_bool_type();
    } else if (literal.kind == Literal_Int) {
        expr.type = mk_int_type(8);
    } else if (literal.kind == Literal_Char) {
        expr.type = mk_int_type(1);
    } else if (literal.kind == Literal_String) {
        expr.type = mk_ptr_type(mk_int_type(1));
    } else {
        unreachable("elab_literal_expr");
    }
}

func elab_array_expr(ctx: *ElabCtx, expr: *ArrayExpr) {
    var elems = expr.elems;

    var elem_type: *Type = null;
    var elem_count = list_len(elems);

    for (var i = 0; i < elem_count; i += 1) {
        var elem: *Expr = list_get(elems, i);
        elab_expr_infer(ctx, elem);
        if (i == 0) {
            elem_type = elem.type;
        } else {
            var prev_expr: *Expr = list_get(elems, i - 1);
            unify_types(&elem, &prev_expr);
            list_set(elems, i, elem);
            list_set(elems, i - 1, prev_expr);
        }
    }

    if (!elem_type) {
        die_at(&expr.pos, "Empty array");
    }

    if (!is_sized(elem_type)) {
        die_at(&expr.pos, "Array element type is not sized");
    }

    expr.type = mk_array_type(elem_type, elem_count);
}

func elab_call_expr_part2(
    ctx: *ElabCtx,
    sym: *Sym,
    expr: *Expr,
    params: *List, // List<FuncParam>
    args: *List, // List<CallArg>
    is_variadic: Bool,
    return_type: *Type
) {
    (expr as *CallExpr).resolved_callee = sym;

    var param_count = list_len(params);
    var arg_count = list_len(args);

    if (sym.kind != Sym_Struct && arg_count > MAX_PARAMS) {
        die_at(&expr.pos, "Too many arguments");
    }
    if (arg_count < param_count) {
        error_at(&expr.pos);
        fprintf(stderr, "Not enough arguments provided (%d < %d).\n", arg_count, param_count);
        exit(1);
    }
    if (!is_variadic && arg_count > param_count) {
        error_at(&expr.pos);
        fprintf(stderr, "Too many arguments provided (%d > %d).\n", arg_count, param_count);
        exit(1);
    }
    var i = 0;
    for (; i < param_count; i += 1) {
        var param: *FuncParam = list_get(params, i);
        var arg: *CallArg = list_get(args, i);
        if (arg.label && !str_eq(arg.label, param.name)) {
            die_at(&arg.expr.pos, "Argument label does not match parameter name");
        }
        elab_expr_expect(ctx, &arg.expr, param.type);
    }
    for (; i < arg_count; i += 1) {
        var arg: *CallArg = list_get(args, i);
        elab_expr_infer(ctx, arg.expr);
        if (!is_scalar(arg.expr.type)) {
            die_at(&expr.pos, "Variadic argument must be scalar.");
        }
    }
    expr.type = return_type;
}

func elab_call_expr(ctx: *ElabCtx, expr: *CallExpr) {
    var callee = expr.callee;
    var args = expr.args;

    if (callee.kind != Expr_Ident) {
        die_at(&callee.pos, "Expected function name");
    }
    var sym = lookup(ctx, (callee as *IdentExpr).name);
    if (!sym) {
        die_at(&callee.pos, "Unknown function");
    }
    if (sym.kind == Sym_Func) {
        var params = (sym as *FuncSym).params;
        var return_type = (sym as *FuncSym).return_type;
        var is_variadic = (sym as *FuncSym).is_variadic;
        elab_call_expr_part2(
            ctx,
            sym,
            expr,
            params,
            args,
            is_variadic,
            return_type
        );
    } else if (sym.kind == Sym_Struct) {
        var sym = sym as *StructSym;
        var fields = sym.fields;
        var return_type = mk_struct_type(sym);
        elab_call_expr_part2(
            ctx,
            sym,
            expr,
            fields, // StructField has the same layout as FuncParam
            args,
            false,
            return_type
        );
    } else {
        die_at(&callee.pos, "Expected a function");
    }
}

func elab_index_expr(ctx: *ElabCtx, expr: *IndexExpr) {
    var indexee = expr.indexee;
    var index = expr.index;

    elab_expr_infer(ctx, indexee);
    elab_expr_infer(ctx, index);

    var indexee_type = indexee.type;
    if (indexee_type.kind != Type_Arr && indexee_type.kind != Type_Ptr) {
        die_at(&indexee.pos, "Expression is not indexable");
    }

    var elem_type = indexee_type.kind == Type_Arr
        ? (indexee_type as *ArrType).elem
        : (indexee_type as *PtrType).pointee;

    check_type_int(&index);
    expr.type = elem_type;
    expr.index = index;
}

func elab_member_expr(ctx: *ElabCtx, expr: *MemberExpr) {
    var left = expr.left;
    var field_name = expr.name;

    elab_expr_infer(ctx, left);

    var struc_type = left.type;
    // TODO: implicit dereference
    if (struc_type.kind == Type_Ptr) {
        struc_type = (struc_type as *PtrType).pointee;
    }
    if (struc_type.kind != Type_Struct) {
        die_at(&left.pos, "Expected a struct");
    }
    var struct_type = struc_type as *StructType;

    var struct_sym = struct_type.sym;
    var field_index = find_struct_field(struct_sym, field_name);
    if (field_index == -1) {
        die_at(&expr.pos, "Unknown field");
    }

    var field: *StructField = list_get(struct_sym.fields, field_index);
    expr.resolved_field = field_index;
    expr.type = field.type;
}

func elab_sizeof_expr(ctx: *ElabCtx, expr: *SizeofExpr) {
    var type = eval_type(ctx, expr.type_expr);
    var size = type_size(type);
    expr.size = size;
    expr.type = mk_int_type(8);
}

func elab_unary_expr(ctx: *ElabCtx, expr: *UnaryExpr) {
    var op = expr.op;
    var right = expr.right;

    elab_expr_infer(ctx, right);

    if (op == Tok_Minus || op == Tok_Tilde) {
        check_type_int(&right);
        expr.type = right.type;
        expr.right = right;
    } else if (op == Tok_Bang) {
        check_type_bool(&right);
        expr.type = mk_bool_type();
        expr.right = right;
    } else if (op == Tok_Star) {
        var pointee_type = right.type;
        if (pointee_type.kind != Type_Ptr) {
            die_at(&right.pos, "Expected a pointer");
        }
        expr.type = (pointee_type as *PtrType).pointee;
    } else if (op == Tok_Amp) {
        if (!is_lvalue(right)) {
            die_at(&right.pos, "Expected an lvalue");
        }
        expr.type = mk_ptr_type(right.type);
    } else {
        unreachable("elab_unary_expr");
    }
}

func elab_binary_expr(ctx: *ElabCtx, expr: *BinaryExpr) {
    var op = expr.op;
    var left = expr.left;
    var right = expr.right;

    if (op == Tok_Eq || op == Tok_AmpEq || op == Tok_BarEq || op == Tok_CaretEq || op == Tok_LtLtEq || op == Tok_GtGtEq || op == Tok_PlusEq || op == Tok_MinusEq || op == Tok_StarEq || op == Tok_SlashEq || op == Tok_PercentEq) {
        if (!is_lvalue(left)) {
            die_at(&left.pos, "L-value expected");
        }
        if (op != Tok_Eq) {
            elab_expr_int(ctx, &left);
        } else {
            elab_expr_infer(ctx, left);
        }
        elab_expr_expect(ctx, &right, left.type);
        if (!is_sized(left.type)) {
            die_at(&left.pos, "Cannot assign to an unsized type");
        }
        expr.type = mk_void_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_AmpAmp || op == Tok_BarBar) {
        elab_expr_bool(ctx, &left);
        elab_expr_bool(ctx, &right);
        expr.type = mk_bool_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_EqEq || op == Tok_BangEq || op == Tok_Lt || op == Tok_LtEq || op == Tok_Gt || op == Tok_GtEq) {
        elab_expr_infer(ctx, left);
        elab_expr_infer(ctx, right);
        unify_types(&left, &right);
        if (!is_scalar(left.type)) {
            die_at(&left.pos, "Operands type is not comparable");
        }
        expr.type = mk_bool_type();
        expr.left = left;
        expr.right = right;
    } else if (op == Tok_Amp || op == Tok_Bar || op == Tok_Caret || op == Tok_LtLt || op == Tok_GtGt || op == Tok_Plus || op == Tok_Minus || op == Tok_Star || op == Tok_Slash || op == Tok_Percent) {
        elab_expr_int(ctx, &left);
        elab_expr_int(ctx, &right);
        unify_types(&left, &right);
        expr.type = left.type;
        expr.left = left;
        expr.right = right;
    } else {
        unreachable("elab_binary_expr");
    }
}

func elab_ternary_expr(ctx: *ElabCtx, expr: *TernaryExpr) {
    var cond = expr.cond;
    var then_expr = expr.then_expr;
    var else_expr = expr.else_expr;

    elab_expr_bool(ctx, &cond);
    elab_expr_infer(ctx, then_expr);
    elab_expr_infer(ctx, else_expr);

    unify_types(&then_expr, &else_expr);
    expr.type = then_expr.type;
    expr.cond = cond;
    expr.then_expr = then_expr;
    expr.else_expr = else_expr;
}

func elab_cast_expr(ctx: *ElabCtx, expr: *CastExpr) {
    var type = eval_type(ctx, expr.type_expr);
    var subexpr = expr.expr;

    elab_expr_infer(ctx, subexpr);
    if (!is_scalar(subexpr.type)) {
        die_at(&subexpr.pos, "Cannot cast non-scalar type");
    }
    expr.type = type;
}

func elab_expr_infer2(ctx: *ElabCtx, expr: *Expr) {
    if (expr.kind == Expr_Ident) {
        elab_ident_expr(ctx, expr as *IdentExpr);
    } else if (expr.kind == Expr_Literal) {
        elab_literal_expr(ctx, expr as *LiteralExpr);
    } else if (expr.kind == Expr_Array) {
        elab_array_expr(ctx, expr as *ArrayExpr);
    } else if (expr.kind == Expr_Call) {
        elab_call_expr(ctx, expr as *CallExpr);
    } else if (expr.kind == Expr_Index) {
        elab_index_expr(ctx, expr as *IndexExpr);
    } else if (expr.kind == Expr_Member) {
        elab_member_expr(ctx, expr as *MemberExpr);
    } else if (expr.kind == Expr_Sizeof) {
        elab_sizeof_expr(ctx, expr as *SizeofExpr);
    } else if (expr.kind == Expr_Unary) {
        elab_unary_expr(ctx, expr as *UnaryExpr);
    } else if (expr.kind == Expr_Binary) {
        elab_binary_expr(ctx, expr as *BinaryExpr);
    } else if (expr.kind == Expr_Ternary) {
        elab_ternary_expr(ctx, expr as *TernaryExpr);
    } else if (expr.kind == Expr_Cast) {
        elab_cast_expr(ctx, expr as *CastExpr);
    } else {
        unreachable("elab_expr_infer");
    }
}

func elab_expr_infer(ctx: *ElabCtx, expr: *Expr) {
    elab_expr_infer2(ctx, expr);
    assert(expr.type, "elab_expr_infer");
}

//==============================================================================
//== Statements

func elab_stmt(ctx: *ElabCtx, stmt: *Stmt);

func elab_stmt_with_scope(ctx: *ElabCtx, stmt: *Stmt) {
    enter_scope(ctx);
    elab_stmt(ctx, stmt);
    exit_scope(ctx);
}

func elab_block_stmt(ctx: *ElabCtx, stmt: *BlockStmt) {
    enter_scope(ctx);
    for (var i = 0; i < stmt.stmts.len; i += 1) {
        var stmt = list_get(stmt.stmts, i);
        elab_stmt(ctx, stmt);
    }
    exit_scope(ctx);
}

func elab_local_stmt(ctx: *ElabCtx, stmt: *LocalStmt) {
    var name = stmt.name;
    var typeExpr = stmt.type;
    var init = stmt.init;

    var type: *Type = typeExpr ? eval_type(ctx, typeExpr) : null;
    if (init) {
        if (!type) {
            elab_expr_infer(ctx, init);
            type = init.type;
        } else {
            elab_expr_expect(ctx, &init, type);
            stmt.init = init;
        }
    } else {
        if (!type) {
            die_at(&stmt.pos, "Type required when no initializer is provided");
        }
    }

    if (!is_sized(type)) {
        die_at(&stmt.pos, "Variable must have a size.");
    }

    var sym = define_local(ctx, &stmt.pos, name, type);
    stmt.sym = sym;
}

func elab_if_stmt(ctx: *ElabCtx, stmt: *IfStmt) {
    var cond = stmt.cond;
    var then_stmt = stmt.then_stmt;
    var else_stmt = stmt.else_stmt;

    elab_expr_bool(ctx, &cond);
    stmt.cond = cond;

    elab_stmt_with_scope(ctx, then_stmt);
    if (else_stmt) {
        elab_stmt_with_scope(ctx, else_stmt);
    }
}

func elab_while_stmt(ctx: *ElabCtx, stmt: *WhileStmt) {
    var cond = stmt.cond;
    var body = stmt.body;

    elab_expr_bool(ctx, &cond);
    stmt.cond = cond;

    ctx.loop_depth += 1;
    elab_stmt_with_scope(ctx, body);
    ctx.loop_depth -= 1;
}

func elab_for_stmt(ctx: *ElabCtx, stmt: *ForStmt) {
    var init = stmt.init;
    var cond = stmt.cond;
    var step = stmt.step;
    var body = stmt.body;

    enter_scope(ctx);

    if (init) {
        elab_stmt(ctx, init);
    }
    if (cond) {
        elab_expr_bool(ctx, &cond);
        stmt.cond = cond;
    }
    if (step) {
        elab_expr_infer(ctx, step);
    }

    ctx.loop_depth += 1;
    elab_stmt_with_scope(ctx, body);
    ctx.loop_depth -= 1;

    exit_scope(ctx);
}

func elab_return_stmt(ctx: *ElabCtx, stmt: *ReturnStmt) {
    var return_expr = stmt.expr;

    var return_type = ctx.current_func.return_type;
    if (return_expr) {
        elab_expr_expect(ctx, &return_expr, return_type);
        stmt.expr = return_expr;
    } else if (return_type.kind != Type_Void) {
        die_at(&stmt.pos, "Missing return value");
    }
}

func elab_break_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (!ctx.loop_depth) {
        die_at(&stmt.pos, "Break statement outside of loop");
    }
}

func elab_continue_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (!ctx.loop_depth) {
        die_at(&stmt.pos, "Continue statement outside of loop");
    }
}

func elab_expr_stmt(ctx: *ElabCtx, stmt: *ExprStmt) {
    var expr = stmt.expr;
    elab_expr_infer(ctx, expr);
}

func elab_stmt(ctx: *ElabCtx, stmt: *Stmt) {
    if (stmt.kind == Stmt_Block) {
        elab_block_stmt(ctx, stmt as *BlockStmt);
    } else if (stmt.kind == Stmt_Local) {
        elab_local_stmt(ctx, stmt as *LocalStmt);
    } else if (stmt.kind == Stmt_If) {
        elab_if_stmt(ctx, stmt as *IfStmt);
    } else if (stmt.kind == Stmt_While) {
        elab_while_stmt(ctx, stmt as *WhileStmt);
    } else if (stmt.kind == Stmt_For) {
        elab_for_stmt(ctx, stmt as *ForStmt);
    } else if (stmt.kind == Stmt_Return) {
        elab_return_stmt(ctx, stmt as *ReturnStmt);
    } else if (stmt.kind == Stmt_Break) {
        elab_break_stmt(ctx, stmt);
    } else if (stmt.kind == Stmt_Continue) {
        elab_continue_stmt(ctx, stmt);
    } else if (stmt.kind == Stmt_Expr) {
        elab_expr_stmt(ctx, stmt as *ExprStmt);
    } else {
        unreachable("elab_stmt");
    }
}

//==============================================================================
//== Top-level declarations

func elab_enum_member(ctx: *ElabCtx, member_decl: *EnumMember, type: *Type, next_value: Int32): Int32 {
    var name = member_decl.name;
    var value = member_decl.value
        ? const_eval(ctx, member_decl.value)
        : next_value;

    define_const(ctx, &member_decl.pos, name, type, value);
    return value;
}

func elab_enum_decl(ctx: *ElabCtx, decl: *EnumDecl) {
    var type: *Type;
    if (decl.name) {
        var sym = define_enum(ctx, &decl.pos, decl.name);
        type = mk_enum_type(sym);
    } else {
        type = mk_int_type(4);
    }

    var member_decls = decl.members;

    var next_value: Int32 = 0;
    for (var i = 0; i < list_len(member_decls); i += 1) {
        var member_decl: *EnumMember = list_get(member_decls, i);
        var value = elab_enum_member(ctx, member_decl, type, next_value);
        next_value = value + 1;
    }
}

func add_struct_field(ctx: *ElabCtx, sym: *Sym, field_decl: *StructFieldDecl) {
    var field_name = field_decl.name;

    var existing_index = find_struct_field(sym, field_name);
    if (existing_index != -1) {
        die_at(&field_decl.pos, "Duplicate field");
    }

    var field_type = eval_type(ctx, field_decl.type);
    var field_size = type_size(field_type);
    var field_align = type_align(field_type);
    if (!is_sized(field_type)) {
        die_at(&field_decl.pos, "Field has unsized type");
    }
    var struct_size = (sym as *StructSym).unpadded_size;
    var field_offset = align_up(struct_size, field_align);

    var field: *StructField = calloc(1, sizeof(StructField));
    *field = StructField(
        name: field_name,
        type: field_type,
        offset: field_offset
    );

    list_push((sym as *StructSym).fields, field);
    (sym as *StructSym).unpadded_size = field_offset + field_size;
}

func elab_struct_base(ctx: *ElabCtx, base: *TypeExpr, struct_sym: *StructSym) {
    var base_type = eval_type(ctx, base);
    if (base_type.kind != Type_Struct) {
        die_at(&base.pos, "Expected a struct type");
    }
    var baseSym = (base_type as *StructType).sym;
    if (baseSym == struct_sym) {
        die_at(&base.pos, "Struct cannot inherit from itself");
    }
    if (!baseSym.is_defined) {
        die_at(&base.pos, "Base has incomplete type");
    }
    var base_fields = baseSym.fields;
    var fields = list_new_with_cap(list_len(base_fields));
    for (var i = 0; i < list_len(base_fields); i += 1) {
        var field: *StructField = list_get(base_fields, i);
        var copy: *StructField = calloc(1, sizeof(StructField));
        *copy = *field;
        list_push(fields, copy);
    }

    *struct_sym = StructSym(
        kind: Sym_Struct,
        name: struct_sym.name,
        base: baseSym,
        fields: fields,
        unpadded_size: baseSym.unpadded_size,
        is_defined: false
    );
}

func elab_struct_decl(ctx: *ElabCtx, decl: *StructDecl) {
    var name = decl.name;
    var base = decl.base;
    var field_decls = decl.fields;

    var is_definition = field_decls != null;

    var sym = declare_struct(ctx, &decl.pos, name, is_definition);

    if (base) {
        elab_struct_base(ctx, base, sym);
    }

    if (field_decls) {
        if (!sym.fields) {
            sym.fields = list_new();
        }
        var fields = sym.fields;

        for (var i = 0; i < list_len(field_decls); i += 1) {
            var field_decl: *StructFieldDecl = list_get(field_decls, i);
            add_struct_field(ctx, sym, field_decl);
        }

        if (list_len(fields) == 0) {
            die_at(&decl.pos, "Empty struct");
        }
    }

    if (sym.fields) {
        sym.is_defined = true;
    }
}

func string_list_contains(list: *List, value: *Char): Bool {
    for (var i = 0; i < list_len(list); i += 1) {
        var item: *Char = list_get(list, i);
        if (str_eq(item, value)) {
            return true;
        }
    }
    return false;
}

func ensure_unique_params(ctx: *ElabCtx, params_decls: *List) {
    var seen = list_new();
    for (var i = 0; i < list_len(params_decls); i += 1) {
        var param_decl: *FuncParamDecl = list_get(params_decls, i);
        var name = param_decl.name;
        if (string_list_contains(seen, name)) {
            die_at(&param_decl.pos, "Duplicate parameter name");
        }
        list_push(seen, name);
    }
}

func elab_param(ctx: *ElabCtx, param_decl: *FuncParamDecl): *FuncParam {
    var name = param_decl.name;
    var type = eval_type(ctx, param_decl.type);

    if (!is_scalar(type)) {
        die_at(&param_decl.pos, "Parameter must be of scalar type.");
    }

    var result: *FuncParam = calloc(1, sizeof(FuncParam));
    *result = FuncParam(name, type);
    return result;
}

func elab_func_decl(ctx: *ElabCtx, decl: *FuncDecl) {
    var name = decl.name;

    var param_decls = decl.params;

    if (list_len(param_decls) > MAX_PARAMS) {
        die_at(&decl.pos, "Too many parameters");
    }

    var params = list_new();
    for (var i = 0; i < list_len(param_decls); i += 1) {
        var param_decl = list_get(param_decls, i);
        var param = elab_param(ctx, param_decl);
        list_push(params, param);
    }

    var return_type = decl.return_type
        ? eval_type(ctx, decl.return_type)
        : mk_void_type();

    var is_variadic = decl.is_variadic;

    var is_definition = decl.body != null;

    var sym = declare_func(ctx, &decl.pos, name, params, return_type, is_variadic, is_definition);

    if (decl.body) {
        enter_scope(ctx);
        ctx.current_func = sym;

        define_params(ctx, param_decls, params);
        elab_stmt(ctx, decl.body);

        ctx.current_func = null;
        exit_scope(ctx);

        sym.body = decl.body;
        sym.is_defined = true;
    } else {
        ensure_unique_params(ctx, param_decls);
    }
}

func elab_const_decl(ctx: *ElabCtx, decl: *ConstDecl) {
    var name = decl.name;
    var value_expr = decl.value;

    var type = mk_int_type(4);
    var value = const_eval(ctx, value_expr);
    define_const(ctx, &decl.pos, name, type, value);
}

func elab_global_decl(ctx: *ElabCtx, decl: *GlobalDecl) {
    var is_extern = decl.is_extern;
    var name = decl.name;
    var type = eval_type(ctx, decl.type);

    var sym = declare_global(ctx, &decl.pos, name, type, !is_extern);
    sym.is_defined = !is_extern;
}

func elab_decl(ctx: *ElabCtx, decl: *Decl) {
    if (decl.kind == Decl_Struct) {
        elab_struct_decl(ctx, decl as *StructDecl);
    } else if (decl.kind == Decl_Func) {
        elab_func_decl(ctx, decl as *FuncDecl);
    } else if (decl.kind == Decl_Enum) {
        elab_enum_decl(ctx, decl as *EnumDecl);
    } else if (decl.kind == Decl_Const) {
        elab_const_decl(ctx, decl as *ConstDecl);
    } else if (decl.kind == Decl_Global) {
        elab_global_decl(ctx, decl as *GlobalDecl);
    } else {
        unreachable("elab_decl");
    }
}

func elab(ast: *Ast): *List { // *List<*Sym>
    var ctx: *ElabCtx = calloc(1, sizeof(ElabCtx));
    *ctx = ElabCtx(
        syms: list_new(),
        scope: scope_new(null),
        current_func: null,
        loop_depth: 0,
    );

    for (var i = 0; i < ast.decls.len; i += 1) {
        var decl = list_get(ast.decls, i);
        elab_decl(ctx, decl);
    }

    return ctx.syms;
}
