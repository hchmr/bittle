// stdio
extern struct File;
extern var __stdinp: *File;
extern var __stdoutp: *File;
extern var __stderrp: *File;

extern func printf(fmt: *Char, ...): Int32;
extern func fprintf(file: *File, fmt: *Char, ...): Int32;
extern func sprintf(buf: *Char, fmt: *Char, ...): Int32;
extern func getchar(): Int32;

// stdlib
extern func exit(status: Int32);
extern func calloc(count: Int, size: Int): *Void;
extern func realloc(ptr: *Void, size: Int): *Void;
extern func atoi(s: *Char): Int;

// string
extern func strlen(s: *Char): Int;
extern func strcmp(a: *Char, b: *Char): Int32;
extern func strdup(s: *Char): *Char;

//= Misc

struct Pos {
    line: Int,
    col: Int,
}

func error_at(pos: *Pos) {
    fprintf(__stderrp, "%d:%d: Error: ", pos.line, pos.col);
}

func str_eq(a: *Char, b: *Char): Bool {
    return strcmp(a, b) == 0;
}

func align_up(size: Int , align: Int): Int {
    return (size + align - 1) / align * align;
}

func assert(cond: Bool, because: *Char) {
    if (!cond) {
        fprintf(__stderrp, "Assertion failed: %s\n", because);
        exit(1);
    }
}

func ilog2(n: Int): Int {
    var i = 0;
    while (n > 1) {
        n = n / 2;
        i += 1;
    }
    return i;
}

func sb_push(buf_p: *(*Char), c: Char): Void {
    var len = *buf_p ? strlen(*buf_p) : 0;
    *buf_p = realloc(*buf_p, len + 2);
    (*buf_p)[len] = c;
    (*buf_p)[len + 1] = '\0';
}

func sb_append(buf_p: *(*Char), str: *Char): Void {
    while (*str != '\0') {
        sb_push(buf_p, *str);
        str = &str[1];
    }
}

func sb_append_int(buf_p: *(*Char), n: Int): Void {
    var s: [Char; 22]; // sign + 20 digits + \0
    sprintf(&s[0], "%d", n);
    sb_append(buf_p, &s[0]);
}

//= Type System

enum {
    Type_Void,
    Type_Bool,
    Type_Int,
    Type_Ptr,
    Type_Array,
    Type_Struct,
}

struct Type {
    kind: Int,
    // Int
    size: Int,
    // Ptr, Array
    base: *Type,
    // Array
    len: Int,
    name: *Char,
    field_names: *(*Char),
    field_types: *(*Type),
    field_offsets: *Int,
    field_count: Int,
    unpadded_size: Int,
}

func mk_type(kind: Int): *Type {
    var type: *Type = calloc(1, sizeof(Type));
    type.kind = kind;
    return type;
}

func mk_void_type(): *Type {
    return mk_type(Type_Void);
}

func mk_bool_type(): *Type {
    return mk_type(Type_Bool);
}

func mk_int_type(size: Int): *Type {
    var type = mk_type(Type_Int);
    type.size = size;
    return type;
}

func mk_ptr_type(base: *Type): *Type {
    var type = mk_type(Type_Ptr);
    type.base = base;
    return type;
}

func mk_array_type(base: *Type, len: Int): *Type {
    var type = mk_type(Type_Array);
    type.base = base;
    type.len = len;
    return type;
}

func mk_struct_type(name: *Char): *Type {
    var type = mk_type(Type_Struct);
    type.name = name;
    return type;
}

func type_align(type: *Type): Int {
    if (type.kind == Type_Void)
        return 1;
    if (type.kind == Type_Bool)
        return 1;
    if (type.kind == Type_Int)
        return 4;
    if (type.kind == Type_Ptr)
        return 8;
    if (type.kind == Type_Array)
        return type_align(type.base);
    if (type.kind == Type_Struct)
        return 8; // Maximum possible alignment.
    assert(false, "type_align: Unreachable.");
}

func type_size(type: *Type): Int {
    if (type.kind == Type_Void)
        return -1;
    if (type.kind == Type_Bool)
        return 1;
    if (type.kind == Type_Int)
        return 4;
    if (type.kind == Type_Ptr)
        return 8;
    if (type.kind == Type_Array)
        return type.len * align_up(type_size(type.base), type_align(type.base));
    if (type.kind == Type_Struct)
        return type.field_count == 0
            ? -1
            : align_up(type.unpadded_size, type_align(type));
    assert(false, "type_size: Unreachable.");
}

func type_eq(t1: *Type, t2: *Type): Bool {
    if (t1.kind != t2.kind)
        return false;
    if (t1.kind == Type_Int)
        return t1.size == t2.size;
    if (t1.kind == Type_Ptr)
        return type_eq(t1.base, t2.base);
    if (t1.kind == Type_Array)
        return t1.len == t2.len && type_eq(t1.base, t2.base);
    if (t1.kind == Type_Struct)
        return t1 == t2;
    return true;
}

func is_scalar(type: *Type): Bool {
    return type.kind == Type_Bool || type.kind == Type_Int || type.kind == Type_Ptr;
}

func type_le(t1: *Type, t2: *Type): Bool {
    if (is_scalar(t1) && t2.kind == Type_Bool)
        return true;
    if (t1.kind == Type_Int && t2.kind == Type_Int)
        return t1.size <= t2.size;
    if (t1.kind == Type_Ptr && t2.kind == Type_Ptr)
        return t1.base.kind == Type_Void;
    return false;
}

func add_field(type: *Type, field_name: *Char, field_type: *Type) {
    assert(type.kind == Type_Struct, "add_field: type should be a struct.");
    var i = type.field_count;
    type.field_count = i + 1;
    type.field_names = realloc(type.field_names, type.field_count * sizeof(*Char));
    type.field_types = realloc(type.field_types, type.field_count * sizeof(*Type));
    type.field_offsets = realloc(type.field_offsets, type.field_count * sizeof(Int));
    type.field_names[i] = field_name;
    type.field_types[i] = field_type;
    type.field_offsets[i] = align_up(type.unpadded_size, type_align(field_type));
    type.unpadded_size = type.field_offsets[i] + type_size(field_type);
}

func find_field(type: *Type, name: *Char): Int {
    assert(type.kind == Type_Struct, "find_field: type should be a struct.");
    var i = 0;
    while (i < type.field_count) {
        if (str_eq(type.field_names[i], name)) {
            return i;
        }
        i += 1;
    }
    return -1;
}

func print_type(file: *File, type: *Type) {
    if (type.kind == Type_Void) {
        fprintf(file, "Void");
    } else if (type.kind == Type_Bool) {
        fprintf(file, "Bool");
    } else if (type.kind == Type_Int) {
        fprintf(file, "Int%d", type.size * 8);
    } else if (type.kind == Type_Ptr) {
        fprintf(file, "*");
        print_type(file, type.base);
    } else if (type.kind == Type_Array) {
        fprintf(file, "[");
        print_type(file, type.base);
        fprintf(file, "; %d]", type.len);
    } else if (type.kind == Type_Struct) {
        fprintf(file, "%s", type.name);
    } else {
        assert(false, "print_type: Unreachable.");
    }
}

//= Symbols

const MAX_SCOPES = 16;
const MAX_PARAMS = 8;

enum {
    Sym_Type,
    Sym_Func,
    Sym_Global,
    Sym_Local,
    Sym_Const,
}

struct Sym {
    kind: Int,
    name: *Char,
    // Type, Function, Global, Local
    type: *Type,
    // Local variable
    offset: Int,
    // Function, Global
    is_extern: Bool,
    // Global
    value: Int,
    // Function
    param_names: [*Char; MAX_PARAMS + 1],
    param_types: [*Type; MAX_PARAMS + 1],
    param_count: Int,
    defined: Bool,
    is_variadic: Bool,
}

var syms: *(*Sym);
var sym_count: Int;
var first_sym: [Int; MAX_SCOPES];
var scope_depth: Int;
var current_func: *Sym;

func mk_sym(kind: Int, name: *Char): *Sym {
    var sym: *Sym = calloc(1, sizeof(Sym));
    sym.kind = kind;
    sym.name = name;
    return sym;
}

func enter_scope() {
    if (scope_depth == MAX_SCOPES) {
        fprintf(__stderrp, "Maximum scope depth exceeded.\n");
        exit(1);
    }
    scope_depth += 1;
    first_sym[scope_depth] = sym_count;
}

func leave_scope() {
    assert(scope_depth > 0, "leave_scope: there should be a scope to pop.");
    sym_count = first_sym[scope_depth];
    scope_depth -= 1;
}

func func_eq(a: *Sym, b: *Sym): Bool {
    if (a.param_count != b.param_count)
        return false;
    if (a.is_variadic != b.is_variadic)
        return false;
    if (!type_eq(a.type, b.type))
        return false;
    var i = 0;
    while (i < a.param_count) {
        if (!type_eq(a.param_types[i], b.param_types[i]))
            return false;
        i += 1;
    }
    return true;
}

func find_sym(name: *Char, depth: Int): *Sym {
    var i = sym_count - 1;
    while (i >= first_sym[depth]) {
        if (str_eq(syms[i].name, name)) {
            return syms[i];
        }
        i -= 1;
    }
    return null;
}

func add_sym(sym: *Sym, pos: *Pos) {
    var existing = find_sym(sym.name, scope_depth);
    if (existing && !(sym.kind == Sym_Func && existing.kind == Sym_Func && !existing.defined && func_eq(sym, existing))) {
        error_at(pos);
        fprintf(__stderrp, "Symbol '%s' already defined.\n", sym.name);
        exit(1);
    }
    sym_count += 1;
    syms = realloc(syms, sym_count * sizeof(Sym));
    syms[sym_count - 1] = sym;
}

func add_local(name: *Char, type: *Type, pos: *Pos) {
    var sym = mk_sym(Sym_Local, name);
    sym.type = type;
    sym.offset = -1; // TODO
    add_sym(sym, pos);
}

func add_global(name: *Char, type: *Type, pos: *Pos) {
    var sym = mk_sym(Sym_Global, name);
    sym.type = type;
    add_sym(sym, pos);
}

func add_const(name: *Char, value: Int, pos: *Pos) {
    var sym = mk_sym(Sym_Const, name);
    sym.type = mk_int_type(4);
    sym.value = value;
    add_sym(sym, pos);
}

//= Abstract Syntax Tree

struct Expr {
    kind: *Char,
    type: *Type,
    pos: Pos,
    // Null, Bool, Int
    int_val: Int,
    // Str
    str_val: *Char,
    // Var, Call
    sym: *Sym,
    // Call, Unary, Binary, Etc.
    args: [*Expr; MAX_PARAMS + 1],
    arg_count: Int,
    // Field
    field: Int,
}

func mk_expr(kind: *Char, type: *Type, pos: *Pos): *Expr {
    var expr: *Expr = calloc(1, sizeof(Expr));
    expr.kind = kind;
    expr.type = type;
    expr.pos = *pos;
    return expr;
}

func mk_expr_3(kind: *Char, e1: *Expr, e2: *Expr, e3: *Expr, type: *Type): *Expr {
    var expr = mk_expr(kind, type, &e1.pos);
    expr.args[0] = e1;
    expr.args[1] = e2;
    expr.args[2] = e3;
    return expr;
}

func mk_expr_2(kind: *Char, e1: *Expr, e2: *Expr, type: *Type): *Expr {
    return mk_expr_3(kind, e1, e2, null, type);
}

func mk_expr_1(kind: *Char, e1: *Expr, type: *Type): *Expr {
    return mk_expr_2(kind, e1, null, type);
}

func mk_cast_expr(expr: *Expr, type: *Type): *Expr {
    var cast = mk_expr("<cast>", type, &expr.pos);
    cast.args[0] = expr;
    return cast;
}

func is_lvalue(expr: *Expr): Bool {
    return str_eq(expr.kind, "<var>") || str_eq(expr.kind, "*_") || str_eq(expr.kind, "_._") || str_eq(expr.kind, "_[_]");
}

//= Constant Folding

func const_eval(e: *Expr): Int {
    if (str_eq(e.kind, "<int>")) {
        return e.int_val;
    } else if (str_eq(e.kind, "_+_")) {
        return const_eval(e.args[0]) + const_eval(e.args[1]);
    } else if (str_eq(e.kind, "_-_")) {
        return const_eval(e.args[0]) - const_eval(e.args[1]);
    } else {
        error_at(&e.pos);
        fprintf(__stderrp, "Failed to evaluate constant expression.\n", e.kind);
        exit(1);
    }
}

//= Type Checking

func copy_expr(expr: *Expr): *Expr {
    var copy = mk_expr(expr.kind, expr.type, &expr.pos);
    *copy = *expr;
    return copy;
}

func try_coerce(expr: *Expr, target: *Type) {
    if (type_eq(expr.type, target))
        return;
    if (type_le(expr.type, target)) {
        *expr = *mk_cast_expr(copy_expr(expr), target);
    } else if (expr.kind == "<int>" && target.kind == Type_Int) {
        var size = ilog2(expr.int_val) + 1;
        if (size < target.size) {
            expr.type = target;
        }
    }
}

func check_type(e: *Expr, expected: *Type) {
    try_coerce(e, expected);
    if (expected.kind == Type_Ptr && expected.base.kind == Type_Void && e.type.kind == Type_Ptr)
        return;
    if (!type_eq(e.type, expected)) {
        error_at(&e.pos);
        var sb: *Char = null;
        fprintf(__stderrp, "Type mismatch: ", sb);
        print_type(__stderrp, e.type);
        fprintf(__stderrp, " != ", sb);
        print_type(__stderrp, expected);
        fprintf(__stderrp, ".\n", sb);
        exit(1);
    }
}

func check_type_int(e: *Expr) {
    if (e.type.kind != Type_Int) {
        error_at(&e.pos);
        fprintf(__stderrp, "Integer type expected.\n");
        exit(1);
    }
}

func check_type_bool(e: *Expr) {
    check_type(e, mk_bool_type());
}

func unify_types(e1: *Expr, e2: *Expr) {
    try_coerce(e2, e1.type);
    try_coerce(e1, e2.type);
    check_type(e2, e1.type);
}

//= Codegen

const MAX_LOCAL_SIZE = 320;
const MAX_TEMP_SIZE = 128;
const MAX_ARGS_SIZE = 64;
const FRAME_SIZE = MAX_LOCAL_SIZE + MAX_TEMP_SIZE + MAX_ARGS_SIZE;

//= Characters

var chr: Char;
var chr_pos: Pos;

func next_char() {
    if (chr_pos.line == 0) {
        chr_pos.line = 1;
    }
    if (chr == '\n') {
        chr_pos.line += 1;
        chr_pos.col = 1;
    } else {
        chr_pos.col += 1;
    }
    chr = getchar() as Char;
}

func is_space(c: Char): Bool {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}

func is_print(c: Char): Bool {
    return c >= 32 as Char && c <= 126 as Char;
}

func is_digit(c: Char): Bool {
    return c >= '0' && c <= '9';
}

func is_alpha(c: Char): Bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

func is_operator(c: Char): Bool {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '=' || c == '!' || c == '<' || c == '>' ||
           c == '&' || c == '|' || c == '.';
}

//= Tokens

enum {
    Tok_Eof,
    Tok_Int,
    Tok_Chr,
    Tok_Str,
    Tok_Wrd,
    Tok_Sym,
}

var tok: Int;
var tok_pos: Pos;
var lexeme: *Char;

func scan_char() {
    var c: Char;
    if (chr == '\\') {
        next_char();
        if (chr == '0') {
            c = '\0';
        } else if (chr == 'n') {
            c = '\n';
        } else if (chr == 'r') {
            c = '\r';
        } else if (chr == 't') {
            c = '\t';
        } else if (chr == '\\') {
            c = '\\';
        } else if (chr == '\'') {
            c = '\'';
        } else if (chr == '\"') {
            c = '\"';
        } else {
            error_at(&chr_pos);
            fprintf(__stderrp, "Invalid escape sequence.\n");
            exit(1);
        }
    } else if (is_print(chr)) {
        c = chr;
    } else {
        error_at(&chr_pos);
        fprintf(__stderrp, "Illegal character.\n");
        exit(1);
    }
    sb_push(&lexeme, c);
    next_char();
}

func next_tok() {
    tok_pos = chr_pos;
    lexeme = null;
    if (chr == -1) {
        tok = Tok_Eof;
    } else if (is_space(chr)) {
        next_char();
        return next_tok();
    } else if (is_digit(chr)) {
        while (is_digit(chr)) {
            sb_push(&lexeme, chr);
            next_char();
        }
        tok = Tok_Int;
    } else if (chr == '\'') {
        next_char();
        if (chr == '\'') {
            error_at(&chr_pos);
            fprintf(__stderrp, "Empty character.\n");
            exit(1);
        }
        scan_char();
        if (chr != '\'') {
            error_at(&chr_pos);
            fprintf(__stderrp, "Expected closing quote.\n");
            exit(1);
        }
        next_char();
        tok = Tok_Chr;
    } else if (chr == '\"') {
        next_char();
        while (chr != -1 && chr != '\"') {
            scan_char();
        }
        if (chr != '\"') {
            error_at(&chr_pos);
            fprintf(__stderrp, "Expected closing quote.\n");
            exit(1);
        }
        next_char();
        tok = Tok_Str;
    } else if (is_alpha(chr) || chr == '_') {
        while (is_alpha(chr) || is_digit(chr) || chr == '_') {
            sb_push(&lexeme, chr);
            next_char();
        }
        tok = Tok_Wrd;
    } else if (is_operator(chr)) {
        while (is_operator(chr)) {
            sb_push(&lexeme, chr);
            next_char();
            if (str_eq(lexeme, "//")) {
                while (chr != '\n' && chr != -1) {
                    next_char();
                }
                return next_tok();
            }
        }
        tok = Tok_Sym;
    } else {
        sb_push(&lexeme, chr);
        next_char();
        tok = Tok_Sym;
    }
    sb_push(&lexeme, '\0');
    printf("tok = \"%s\"\n", lexeme);
}

//= Parsing

func at(str: *Char): Bool {
    return (tok == Tok_Sym || tok == Tok_Wrd) && str_eq(lexeme, str);
}

func eat(str: *Char): Bool {
    if (!at(str))
        return false;
    next_tok();
    return true;
}

func expect(str: *Char) {
    printf("expect(\"%s\")\n", str);
    if (!eat(str)) {
        error_at(&tok_pos);
        fprintf(__stderrp, "'%s' expected.\n", str);
        exit(1);
    }
}

func p_lexeme(): *Char {
    var prev_lexeme = strdup(lexeme);
    next_tok();
    return prev_lexeme;
}

func p_ident(): *Char {
    if (tok != Tok_Wrd) {
        error_at(&tok_pos);
        fprintf(__stderrp, "Identifier expected.\n");
        exit(1);
    }
    return p_lexeme();
}

func p_comma(end: *Char) {
    if (!eat(",") && !at(end)) {
        error_at(&tok_pos);
        fprintf(__stderrp, "',' or '%s' expected.\n", end);
        exit(1);
    }
}

func p_const_expr(): Int;

func p_type(): *Type {
    printf("p_type()\n");
    if (eat("(")) {
        var type = p_type();
        expect(")");
        return type;
    } else if (eat("Void")) {
        return mk_void_type();
    } else if (eat("Bool")) {
        return mk_bool_type();
    } else if (eat("Char") || eat("Int8")) {
        return mk_int_type(1);
    } else if (eat("Int16")) {
        return mk_int_type(2);
    } else if (eat("Int32")) {
        return mk_int_type(4);
    } else if (eat("Int") || eat("Int64")) {
        return mk_int_type(8);
    } else if (eat("*")) {
        return mk_ptr_type(p_type());
    } else if (eat("[")) {
        var type = p_type();
        expect(";");
        var len = p_const_expr();
        expect("]");
        return mk_array_type(type, len);
    } else if (tok == Tok_Wrd) {
        var name = p_ident();
        var sym = find_sym(name, 0);
        if (!sym) {
            error_at(&tok_pos);
            fprintf(__stderrp, "Undeclared symbol '%s'.\n", name);
            exit(1);
        }
        if (sym.kind != Sym_Type) {
            error_at(&tok_pos);
            fprintf(__stderrp, "'%s' is not a type.\n", name);
            exit(1);
        }
        return sym.type;
    } else {
        error_at(&tok_pos);
        fprintf(__stderrp, "Type expected.\n");
        exit(1);
    }
}

enum {
    Prec_Assign,
    Prec_Cond,
    Prec_CondOr,
    Prec_CondAnd,
    Prec_BitOr,
    Prec_BitXor,
    Prec_BitAnd,
    Prec_Cmp,
    Prec_Shift,
    Prec_Add,
    Prec_Mul,
    Prec_Cast,
    Prec_Unary,
    Prec_Postfix,
}

func build_unary_expr(op: *Char, rhs: *Expr): *Expr {
    if (str_eq(op, "*_")) {
        if (rhs.type.kind != Type_Ptr) {
            error_at(&rhs.pos);
            fprintf(__stderrp, "Pointer type expected.\n");
            exit(1);
        }
        return mk_expr_1("*_", rhs, rhs.type.base);
    } else if (str_eq(op, "&_")) {
        if (!is_lvalue(rhs)) {
            error_at(&rhs.pos);
            fprintf(__stderrp, "L-value expected.\n");
            exit(1);
        }
        return mk_expr_1("&_", rhs, mk_ptr_type(rhs.type));
    } else if (str_eq(op, "!_")) {
        check_type(rhs, mk_bool_type());
        return mk_expr_1("!_", rhs, mk_bool_type());
    } else {
        check_type_int(rhs);
        return mk_expr_1(op, rhs, rhs.type);
    }
}

func build_binary_expr(lhs: *Expr, op: *Char, rhs: *Expr): *Expr {
    if (str_eq(op, "_=_")) {
        if (!is_lvalue(lhs)) {
            error_at(&lhs.pos);
            fprintf(__stderrp, "L-value expected.\n");
            exit(1);
        }
        unify_types(lhs, rhs);
        return mk_expr_2(op, lhs, rhs, mk_void_type());
    } else if (str_eq(op, "_+=_") || str_eq(op, "_-=_")) {
        if (!is_lvalue(lhs)) {
            error_at(&lhs.pos);
            fprintf(__stderrp, "L-value expected.\n");
            exit(1);
        }
        check_type_int(lhs);
        check_type_int(rhs);
        return mk_expr_2(op, lhs, rhs, lhs.type);
    } else if (str_eq(op, "_||_") || str_eq(op, "_&&_")) {
        check_type_bool(lhs);
        check_type_bool(rhs);
        return mk_expr_2(op, lhs, rhs, mk_bool_type());
    }  else if (str_eq(op, "_==_") || str_eq(op, "_!=_") || str_eq(op, "_<_") || str_eq(op, "_<=_") || str_eq(op, "_>_") || str_eq(op, "_>=_")) {
        unify_types(lhs, rhs);
        if (!is_scalar(lhs.type)) {
            error_at(&lhs.pos);
            fprintf(__stderrp, "Type ");
            print_type(__stderrp, lhs.type);
            fprintf(__stderrp, " is not comparable.\n");
            exit(1);
        }
        return mk_expr_2(op, lhs, rhs, mk_bool_type());
    } else {
        check_type_int(lhs);
        check_type_int(rhs);
        unify_types(lhs, rhs);
        return mk_expr_2(op, lhs, rhs, lhs.type);
    }
}

func p_expr(max_prec: Int): *Expr {
    var lhs: *Expr;
    if (eat("(")) {
        lhs = p_expr(0);
        expect(")");
    } else if (eat("null")) {
        lhs = mk_expr("<int>", mk_ptr_type(mk_void_type()), &tok_pos);
        lhs.int_val = 0;
    } else if (at("true") || at("false")) {
        lhs = mk_expr("<int>", mk_bool_type(), &tok_pos);
        lhs.int_val = (eat("true") || !eat("false")) as Int;
    } else if (tok == Tok_Int) {
        lhs = mk_expr("<int>", mk_int_type(4), &tok_pos);
        lhs.int_val = atoi(p_lexeme());
    } else if (tok == Tok_Chr) {
        lhs = mk_expr("<int>", mk_int_type(1), &tok_pos);
        lhs.int_val = p_lexeme()[0];
    } else if (tok == Tok_Str) {
        lhs = mk_expr("<str>", mk_ptr_type(mk_int_type(1)), &tok_pos);
        lhs.str_val = p_lexeme();
    } else if (eat("sizeof")) {
        expect("(");
        var type = p_type();
        expect(")");
        lhs = mk_expr("<int>", mk_int_type(8), &tok_pos);
        lhs.int_val = type_size(type);
    } else if (tok == Tok_Wrd) {
        var name = p_ident();
        var sym = find_sym(name, 0);
        if (!sym) {
            error_at(&tok_pos);
            fprintf(__stderrp, "Undeclared symbol '%s'.\n", name);
            exit(1);
        }
        if (eat("(")) {
            if (sym.kind != Sym_Func) {
                error_at(&tok_pos);
                exit(1);
            }
            lhs = mk_expr("<call>", sym.type, &tok_pos);
            lhs.sym = sym;
            while (!eat(")")) {
                var arg = p_expr(0);
                p_comma(")");
                if (lhs.arg_count == MAX_PARAMS) {
                    error_at(&tok_pos);
                    fprintf(__stderrp, "Too many arguments.\n");
                    exit(1);
                }
                lhs.args[lhs.arg_count] = arg;
                lhs.arg_count += 1;
            }
            if (lhs.arg_count < sym.param_count) {
                error_at(&tok_pos);
                fprintf(__stderrp, "Too few arguments (%d < %d).\n", lhs.arg_count, sym.param_count);
                exit(1);
            }
            if (!sym.is_variadic && lhs.arg_count > sym.param_count) {
                error_at(&tok_pos);
                fprintf(__stderrp, "Too many arguments (%d > %d).\n", lhs.arg_count, sym.param_count);
                exit(1);
            }
            var i = 0;
            while (i < sym.param_count) {
                check_type(lhs.args[i], sym.param_types[i]);
                i += 1;
            }
            while (i < lhs.arg_count) {
                if (!is_scalar(lhs.args[i].type)) {
                    error_at(&tok_pos);
                    fprintf(__stderrp, "Variadic argument must be scalar.\n");
                    exit(1);
                }
                i += 1;
            }
        } else {
            if (sym.kind == Sym_Local || sym.kind == Sym_Global) {
                lhs = mk_expr("<var>", sym.type, &tok_pos);
                lhs.sym = sym;
            } else if (sym.kind == Sym_Const) {
                lhs = mk_expr("<int>", sym.type, &tok_pos);
                lhs.int_val = sym.value;
            } else {
                error_at(&tok_pos);
                fprintf(__stderrp, "'%s' is not a variable or constant.\n", name);
                exit(1);
            }
        }
    } else if (eat("*")) {
        lhs = build_unary_expr("*_", p_expr(Prec_Unary));
    } else if (eat("&")) {
        lhs = build_unary_expr("&_", p_expr(Prec_Unary));
    } else if ((eat("!"))) {
        lhs = build_unary_expr("!_", p_expr(Prec_Unary));
    } else if (eat("~")) {
        lhs = build_unary_expr("~_", p_expr(Prec_Unary));
    } else if (eat("-")) {
        lhs = build_unary_expr("-_", p_expr(Prec_Unary));
    } else {
        error_at(&tok_pos);
        fprintf(__stderrp, "Expression expected.\n");
        exit(1);
    }

    while (true) {
        if (max_prec <= Prec_Assign && eat("=")) {
            lhs = build_binary_expr(lhs, "_=_", p_expr(Prec_Assign + 1));
        } else if (max_prec <= Prec_Assign && eat("+=")) {
            lhs = build_binary_expr(lhs, "_+=_", p_expr(Prec_Assign + 1));
        } else if (max_prec <= Prec_Assign && eat("-=")) {
            lhs = build_binary_expr(lhs, "_-=_", p_expr(Prec_Assign + 1));
        } else if (max_prec <= Prec_Cond && eat("?")) {
            var ift = p_expr(Prec_Cond);
            expect(":");
            var iff = p_expr(Prec_Cond);
            check_type(lhs, mk_bool_type());
            unify_types(ift, iff);
            lhs = mk_expr_3("_?_:_", lhs, ift, iff, ift.type);
        } else if (max_prec <= Prec_CondOr && eat("||")) {
            lhs = build_binary_expr(lhs, "_||_", p_expr(Prec_CondOr + 1));
        } else if (max_prec <= Prec_CondAnd && eat("&&")) {
            lhs = build_binary_expr(lhs, "_&&_", p_expr(Prec_CondAnd + 1));
        } else if (max_prec <= Prec_BitOr && eat("|")) {
            lhs = build_binary_expr(lhs, "_|_", p_expr(Prec_BitOr + 1));
        } else if (max_prec <= Prec_BitXor && eat("^")) {
            lhs = build_binary_expr(lhs, "_^_", p_expr(Prec_BitXor + 1));
        } else if (max_prec <= Prec_BitAnd && eat("&")) {
            lhs = build_binary_expr(lhs, "_&_", p_expr(Prec_BitAnd + 1));
        } else if (max_prec <= Prec_Cmp && eat("==")) {
            lhs = build_binary_expr(lhs, "_==_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("!=")) {
            lhs = build_binary_expr(lhs, "_!=_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("<")) {
            lhs = build_binary_expr(lhs, "_<_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat("<=")) {
            lhs = build_binary_expr(lhs, "_<=_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat(">")) {
            lhs = build_binary_expr(lhs, "_>_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Cmp && eat(">=")) {
            lhs = build_binary_expr(lhs, "_>=_", p_expr(Prec_Cmp + 1));
        } else if (max_prec <= Prec_Shift && eat("<<")) {
            lhs = build_binary_expr(lhs, "_<<_", p_expr(Prec_Shift + 1));
        } else if (max_prec <= Prec_Shift && eat(">>")) {
            lhs = build_binary_expr(lhs, "_>>_", p_expr(Prec_Shift + 1));
        } else if (max_prec <= Prec_Add && eat("+")) {
            lhs = build_binary_expr(lhs, "_+_", p_expr(Prec_Add + 1));
        } else if (max_prec <= Prec_Add && eat("-")) {
            lhs = build_binary_expr(lhs, "_-_", p_expr(Prec_Add + 1));
        } else if (max_prec <= Prec_Mul && eat("*")) {
            lhs = build_binary_expr(lhs, "_*_", p_expr(Prec_Mul + 1));
        } else if (max_prec <= Prec_Mul && eat("/")) {
            lhs = build_binary_expr(lhs, "_/_", p_expr(Prec_Mul + 1));
        } else if (max_prec <= Prec_Mul && eat("%")) {
            lhs = build_binary_expr(lhs, "_%_", p_expr(Prec_Mul + 1));
        } else if (max_prec <= Prec_Cast && eat("as")) {
            lhs = mk_cast_expr(lhs, p_type());
        } else if (max_prec <= Prec_Postfix && eat("[")) {
            var rhs = p_expr(0);
            expect("]");
            if (lhs.type.kind != Type_Array && lhs.type.kind != Type_Ptr) {
                error_at(&lhs.pos);
                fprintf(__stderrp, "Array or pointer type expected.\n");
                exit(1);
            }
            check_type_int(rhs);
            lhs = mk_expr_2("_[_]", lhs, rhs, lhs.type.base);
        } else if (max_prec <= Prec_Postfix && eat(".")) {
            var name = p_ident();
            if (lhs.type.kind == Type_Ptr && lhs.type.base.kind == Type_Struct) {
                lhs = mk_expr_1("*_", lhs, lhs.type.base);
            }
            if (lhs.type.kind != Type_Struct) {
                error_at(&lhs.pos);
                fprintf(__stderrp, "Struct type expected.\n");
                exit(1);
            }
            var field_index = find_field(lhs.type, name);
            if (field_index == -1) {
                error_at(&tok_pos);
                fprintf(__stderrp, "Struct does not have a field '%s'.\n", name);
                exit(1);
            }
            var field_type = lhs.type.field_types[field_index];
            lhs = mk_expr_1("_._", lhs, field_type);
            lhs.field = field_index;
        } else {
            return lhs;
        }
    }
}

func p_const_expr(): Int {
    var expr = p_expr(0);
    check_type_int(expr);
    return const_eval(expr);
}

func p_stmt() {
    printf("p_stmt()\n");
    if (eat("{")) {
        enter_scope();
        while (!eat("}")) {
            p_stmt();
        }
        leave_scope();
    } else if (eat("var")) {
        var name_pos = tok_pos;
        var name = p_ident();
        var type: *Type = null;
        if (eat(":")) {
            type = p_type();
        }
        var init: *Expr = null;
        if (eat("=")) {
            init = p_expr(0);
        }
        expect(";");

        if (type != null) {
            if (init != null) {
                check_type(init, type);
            }
        } else {
            if (init != null) {
                type = init.type;
            } else {
                error_at(&name_pos);
                fprintf(__stderrp, "Type or initializer expected.\n");
                exit(1);
            }
        }
        if (type_size(type) == -1) {
            error_at(&name_pos);
            fprintf(__stderrp, "Variable must have a size.\n");
            exit(1);
        }

        add_local(name, type, &name_pos);
    } else if (eat("if")) {
        expect("(");
        var cond = p_expr(0);
        check_type_bool(cond);
        expect(")");
        p_stmt();
        if (eat("else")) {
            p_stmt();
        }
    } else if (eat("while")) {
        expect("(");
        var cond = p_expr(0);
        check_type_bool(cond);
        expect(")");
        p_stmt();
    } else if (eat("return")) {
        var expr: *Expr = null;
        if (!eat(";")) {
            expr = p_expr(0);
        }
        expect(";");

        if (expr) {
            check_type(expr, current_func.type);
        } else if (current_func.type.kind != Type_Void) {
            error_at(&tok_pos);
            fprintf(__stderrp, "Return value expected.\n");
            exit(1);
        }
    } else {
        p_expr(0);
        expect(";");
    }
}

func p_func(is_extern: Bool) {
    var name_pos = tok_pos;
    var name = p_ident();
    var sym = mk_sym(Sym_Func, name);
    sym.type = mk_void_type();
    current_func = sym;

    enter_scope();
    add_sym(sym, &name_pos);
    expect("(");
    while (!at(")") && !at("...")) {
        var param_pos = tok_pos;
        var param_name = p_ident();
        expect(":");
        var param_type = p_type();
        p_comma(")");

        if (sym.param_count == MAX_PARAMS) {
            error_at(&tok_pos);
            fprintf(__stderrp, "Too many parameters.\n");
            exit(1);
        }
        if (!is_scalar(param_type)) {
            error_at(&param_pos);
            fprintf(__stderrp, "Parameter must be of scalar type.\n");
            exit(1);
        }
        sym.param_names[sym.param_count] = param_name;
        sym.param_types[sym.param_count] = param_type;
        sym.param_count += 1;

        add_local(param_name, param_type, &param_pos);
    }
    if (eat("...")) {
        sym.is_variadic = true;
    }
    expect(")");
    if (eat(":")) {
        sym.type = p_type();
    }
    if (!is_extern && at("{")) {
        sym.defined = true;
        printf("  .global _%s\n", name);
        printf("_%s:\n", name);
        printf("  stp fp, lr, [sp, -16]!\n");
        printf("  mov fp, sp\n");
        printf("  sub sp, sp, %d\n", FRAME_SIZE);
        p_stmt();
        printf("  .L.%s.ret:\n", name);
        printf("  add sp, sp, %d\n", FRAME_SIZE);
        printf("  ldp fp, lr, [sp], 16\n");
        printf("  ret\n");
    } else {
        expect(";");
    }
    leave_scope();
    add_sym(sym, &name_pos);
}

func p_decl() {
    var is_extern = false;
    if (eat("extern")) {
        if (!at("func") && !at("var") && !at("struct")) {
            error_at(&tok_pos);
            fprintf(__stderrp, "External declaration expected.\n");
            exit(1);
        }
        is_extern = true;
    }

    if (eat("func")) {
        p_func(is_extern);
    } else if (eat("var")) {
        var name = p_ident();
        expect(":");
        var type = p_type();
        expect(";");
        add_global(name, type, &tok_pos);
        if (!is_extern) {
            printf("  .global _%s\n", name);
            printf(".zerofill __DATA, __common, _%s, %d, %d\n", name, type_size(type), type_align(type));
        }
    } else if (eat("const")) {
        var name = p_ident();
        expect("=");
        var value = p_const_expr();
        expect(";");
        add_const(name, value, &tok_pos);
    } else if (eat("struct")) {
        var name = p_ident();
        var sym = mk_sym(Sym_Type, name);
        sym.type = mk_struct_type(name);
        add_sym(sym, &tok_pos);
        if (!is_extern) {
            expect("{");
            while (!eat("}")) {
                var field_name = p_ident();
                expect(":");
                var field_type = p_type();
                p_comma("}");
                add_field(sym.type, field_name, field_type);
            }
        } else {
            expect(";");
        }
    } else if (eat("enum")) {
        var value = 0;
        expect("{");
        while (!eat("}")) {
            var name = p_ident();
            if (eat("=")) {
                value = p_const_expr();
            }
            p_comma("}");
            add_const(name, value, &tok_pos);
            value += 1;
        }
    } else {
        error_at(&tok_pos);
        fprintf(__stderrp, "Declaration expected.\n");
        exit(1);
    }
}

func main(): Int {
    next_char();
    next_tok();
    while (tok != Tok_Eof) {
        p_decl();
    }
    return 0;
}
